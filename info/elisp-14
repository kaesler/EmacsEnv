This is elisp, produced by makeinfo version 4.0f from ./elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This Info file contains edition 2.8 of the GNU Emacs Lisp Reference
Manual, corresponding to Emacs version 21.2.

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
2000, 2001, 2002 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Copying", with the Front-Cover texts being "A
GNU Manual", and with the Back-Cover Texts as in (a) below.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: elisp,  Node: Internals of Debugger,  Prev: Invoking the Debugger,  Up: Debugger

Internals of the Debugger
-------------------------

   This section describes functions and variables used internally by the
debugger.

 - Variable: debugger
     The value of this variable is the function to call to invoke the
     debugger.  Its value must be a function of any number of
     arguments, or, more typically, the name of a function.  This
     function should invoke some kind of debugger.  The default value
     of the variable is `debug'.

     The first argument that Lisp hands to the function indicates why it
     was called.  The convention for arguments is detailed in the
     description of `debug'.

 - Command: backtrace
     This function prints a trace of Lisp function calls currently
     active.  This is the function used by `debug' to fill up the
     `*Backtrace*' buffer.  It is written in C, since it must have
     access to the stack to determine which function calls are active.
     The return value is always `nil'.

     In the following example, a Lisp expression calls `backtrace'
     explicitly.  This prints the backtrace to the stream
     `standard-output', which, in this case, is the buffer
     `backtrace-output'.

     Each line of the backtrace represents one function call.  The line
     shows the values of the function's arguments if they are all
     known; if they are still being computed, the line says so.  The
     arguments of special forms are elided.

          (with-output-to-temp-buffer "backtrace-output"
            (let ((var 1))
              (save-excursion
                (setq var (eval '(progn
                                   (1+ var)
                                   (list 'testing (backtrace))))))))
          
               => nil
          
          ----------- Buffer: backtrace-output ------------
            backtrace()
            (list ...computing arguments...)
            (progn ...)
            eval((progn (1+ var) (list (quote testing) (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            eval-region(1973 2142 #<buffer *scratch*>)
            byte-code("...  for eval-print-last-sexp ...")
            eval-print-last-sexp(nil)
          * call-interactively(eval-print-last-sexp)
          ----------- Buffer: backtrace-output ------------

     The character `*' indicates a frame whose debug-on-exit flag is
     set.

 - Variable: debug-on-next-call
     If this variable is non-`nil', it says to call the debugger before
     the next `eval', `apply' or `funcall'.  Entering the debugger sets
     `debug-on-next-call' to `nil'.

     The `d' command in the debugger works by setting this variable.

 - Function: backtrace-debug level flag
     This function sets the debug-on-exit flag of the stack frame LEVEL
     levels down the stack, giving it the value FLAG.  If FLAG is
     non-`nil', this will cause the debugger to be entered when that
     frame later exits.  Even a nonlocal exit through that frame will
     enter the debugger.

     This function is used only by the debugger.

 - Variable: command-debug-status
     This variable records the debugging status of the current
     interactive command.  Each time a command is called interactively,
     this variable is bound to `nil'.  The debugger can set this
     variable to leave information for future debugger invocations
     during the same command invocation.

     The advantage of using this variable rather than an ordinary global
     variable is that the data will never carry over to a subsequent
     command invocation.

 - Function: backtrace-frame frame-number
     The function `backtrace-frame' is intended for use in Lisp
     debuggers.  It returns information about what computation is
     happening in the stack frame FRAME-NUMBER levels down.

     If that frame has not evaluated the arguments yet, or is a special
     form, the value is `(nil FUNCTION ARG-FORMS...)'.

     If that frame has evaluated its arguments and called its function
     already, the return value is `(t FUNCTION ARG-VALUES...)'.

     In the return value, FUNCTION is whatever was supplied as the CAR
     of the evaluated list, or a `lambda' expression in the case of a
     macro call.  If the function has a `&rest' argument, that is
     represented as the tail of the list ARG-VALUES.

     If FRAME-NUMBER is out of range, `backtrace-frame' returns `nil'.


File: elisp,  Node: Edebug,  Next: Syntax Errors,  Prev: Debugger,  Up: Debugging

Edebug
======

   Edebug is a source-level debugger for Emacs Lisp programs with which
you can:

   * Step through evaluation, stopping before and after each expression.

   * Set conditional or unconditional breakpoints.

   * Stop when a specified condition is true (the global break event).

   * Trace slow or fast, stopping briefly at each stop point, or at
     each breakpoint.

   * Display expression results and evaluate expressions as if outside
     of Edebug.

   * Automatically re-evaluate a list of expressions and display their
     results each time Edebug updates the display.

   * Output trace info on function enter and exit.

   * Stop when an error occurs.

   * Display a backtrace, omitting Edebug's own frames.

   * Specify argument evaluation for macros and defining forms.

   * Obtain rudimentary coverage testing and frequency counts.

   The first three sections below should tell you enough about Edebug to
enable you to use it.

* Menu:

* Using Edebug::		Introduction to use of Edebug.
* Instrumenting::		You must instrument your code
				  in order to debug it with Edebug.
* Modes: Edebug Execution Modes. Execution modes, stopping more or less often.
* Jumping::			Commands to jump to a specified place.
* Misc: Edebug Misc.		Miscellaneous commands.
* Breakpoints::			Setting breakpoints to make the program stop.
* Trapping Errors::		Trapping errors with Edebug.
* Views: Edebug Views.		Views inside and outside of Edebug.
* Eval: Edebug Eval.		Evaluating expressions within Edebug.
* Eval List::			Expressions whose values are displayed
				  each time you enter Edebug.
* Printing in Edebug::		Customization of printing.
* Trace Buffer::		How to produce trace output in a buffer.
* Coverage Testing::		How to test evaluation coverage.
* The Outside Context::		Data that Edebug saves and restores.
* Instrumenting Macro Calls::	Specifying how to handle macro calls.
* Options: Edebug Options.	Option variables for customizing Edebug.


File: elisp,  Node: Using Edebug,  Next: Instrumenting,  Up: Edebug

Using Edebug
------------

   To debug a Lisp program with Edebug, you must first "instrument" the
Lisp code that you want to debug.  A simple way to do this is to first
move point into the definition of a function or macro and then do `C-u
C-M-x' (`eval-defun' with a prefix argument).  See *Note
Instrumenting::, for alternative ways to instrument code.

   Once a function is instrumented, any call to the function activates
Edebug.  Depending on which Edebug execution mode you have selected,
activating Edebug may stop execution and let you step through the
function, or it may update the display and continue execution while
checking for debugging commands.  The default execution mode is step,
which stops execution.  *Note Edebug Execution Modes::.

   Within Edebug, you normally view an Emacs buffer showing the source
of the Lisp code you are debugging.  This is referred to as the "source
code buffer", and it is temporarily read-only.

   An arrow at the left margin indicates the line where the function is
executing.  Point initially shows where within the line the function is
executing, but this ceases to be true if you move point yourself.

   If you instrument the definition of `fac' (shown below) and then
execute `(fac 3)', here is what you would normally see.  Point is at
the open-parenthesis before `if'.

     (defun fac (n)
     =>-!-(if (< 0 n)
           (* n (fac (1- n)))
         1))

   The places within a function where Edebug can stop execution are
called "stop points".  These occur both before and after each
subexpression that is a list, and also after each variable reference.
Here we use periods to show the stop points in the function `fac':

     (defun fac (n)
       .(if .(< 0 n.).
           .(* n. .(fac (1- n.).).).
         1).)

   The special commands of Edebug are available in the source code
buffer in addition to the commands of Emacs Lisp mode.  For example,
you can type the Edebug command <SPC> to execute until the next stop
point.  If you type <SPC> once after entry to `fac', here is the
display you will see:

     (defun fac (n)
     =>(if -!-(< 0 n)
           (* n (fac (1- n)))
         1))

   When Edebug stops execution after an expression, it displays the
expression's value in the echo area.

   Other frequently used commands are `b' to set a breakpoint at a stop
point, `g' to execute until a breakpoint is reached, and `q' to exit
Edebug and return to the top-level command loop.  Type `?' to display a
list of all Edebug commands.


File: elisp,  Node: Instrumenting,  Next: Edebug Execution Modes,  Prev: Using Edebug,  Up: Edebug

Instrumenting for Edebug
------------------------

   In order to use Edebug to debug Lisp code, you must first
"instrument" the code.  Instrumenting code inserts additional code into
it, to invoke Edebug at the proper places.

   Once you have loaded Edebug, the command `C-M-x' (`eval-defun') is
redefined so that when invoked with a prefix argument on a definition,
it instruments the definition before evaluating it.  (The source code
itself is not modified.)  If the variable `edebug-all-defs' is
non-`nil', that inverts the meaning of the prefix argument: in this
case, `C-M-x' instruments the definition _unless_ it has a prefix
argument.  The default value of `edebug-all-defs' is `nil'.  The
command `M-x edebug-all-defs' toggles the value of the variable
`edebug-all-defs'.

   If `edebug-all-defs' is non-`nil', then the commands `eval-region',
`eval-current-buffer', and `eval-buffer' also instrument any
definitions they evaluate.  Similarly, `edebug-all-forms' controls
whether `eval-region' should instrument _any_ form, even non-defining
forms.  This doesn't apply to loading or evaluations in the minibuffer.
The command `M-x edebug-all-forms' toggles this option.

   Another command, `M-x edebug-eval-top-level-form', is available to
instrument any top-level form regardless of the values of
`edebug-all-defs' and `edebug-all-forms'.

   While Edebug is active, the command `I' (`edebug-instrument-callee')
instruments the definition of the function or macro called by the list
form after point, if is not already instrumented.  This is possible
only if Edebug knows where to find the source for that function; for
this reading, after loading Edebug, `eval-region' records the position
of every definition it evaluates, even if not instrumenting it.  See
also the `i' command (*note Jumping::), which steps into the call after
instrumenting the function.

   Edebug knows how to instrument all the standard special forms,
`interactive' forms with an expression argument, anonymous lambda
expressions, and other defining forms.  However, Edebug cannot determine
on its own what a user-defined macro will do with the arguments of a
macro call, so you must provide that information; see *Note
Instrumenting Macro Calls::, for details.

   When Edebug is about to instrument code for the first time in a
session, it runs the hook `edebug-setup-hook', then sets it to `nil'.
You can use this to load Edebug specifications (*note Instrumenting
Macro Calls::) associated with a package you are using, but only when
you use Edebug.

   To remove instrumentation from a definition, simply re-evaluate its
definition in a way that does not instrument.  There are two ways of
evaluating forms that never instrument them: from a file with `load',
and from the minibuffer with `eval-expression' (`M-:').

   If Edebug detects a syntax error while instrumenting, it leaves point
at the erroneous code and signals an `invalid-read-syntax' error.

   *Note Edebug Eval::, for other evaluation functions available inside
of Edebug.


File: elisp,  Node: Edebug Execution Modes,  Next: Jumping,  Prev: Instrumenting,  Up: Edebug

Edebug Execution Modes
----------------------

   Edebug supports several execution modes for running the program you
are debugging.  We call these alternatives "Edebug execution modes"; do
not confuse them with major or minor modes.  The current Edebug
execution mode determines how far Edebug continues execution before
stopping--whether it stops at each stop point, or continues to the next
breakpoint, for example--and how much Edebug displays the progress of
the evaluation before it stops.

   Normally, you specify the Edebug execution mode by typing a command
to continue the program in a certain mode.  Here is a table of these
commands; all except for `S' resume execution of the program, at least
for a certain distance.

`S'
     Stop: don't execute any more of the program, but wait for more
     Edebug commands (`edebug-stop').

`<SPC>'
     Step: stop at the next stop point encountered (`edebug-step-mode').

`n'
     Next: stop at the next stop point encountered after an expression
     (`edebug-next-mode').  Also see `edebug-forward-sexp' in *Note
     Edebug Misc::.

`t'
     Trace: pause one second at each Edebug stop point
     (`edebug-trace-mode').

`T'
     Rapid trace: update the display at each stop point, but don't
     actually pause (`edebug-Trace-fast-mode').

`g'
     Go: run until the next breakpoint (`edebug-go-mode').  *Note
     Breakpoints::.

`c'
     Continue: pause one second at each breakpoint, and then continue
     (`edebug-continue-mode').

`C'
     Rapid continue: move point to each breakpoint, but don't pause
     (`edebug-Continue-fast-mode').

`G'
     Go non-stop: ignore breakpoints (`edebug-Go-nonstop-mode').  You
     can still stop the program by typing `S', or any editing command.

   In general, the execution modes earlier in the above list run the
program more slowly or stop sooner than the modes later in the list.

   While executing or tracing, you can interrupt the execution by typing
any Edebug command.  Edebug stops the program at the next stop point and
then executes the command you typed.  For example, typing `t' during
execution switches to trace mode at the next stop point.  You can use
`S' to stop execution without doing anything else.

   If your function happens to read input, a character you type
intending to interrupt execution may be read by the function instead.
You can avoid such unintended results by paying attention to when your
program wants input.

   Keyboard macros containing the commands in this section do not
completely work: exiting from Edebug, to resume the program, loses track
of the keyboard macro.  This is not easy to fix.  Also, defining or
executing a keyboard macro outside of Edebug does not affect commands
inside Edebug.  This is usually an advantage.  See also the
`edebug-continue-kbd-macro' option (*note Edebug Options::).

   When you enter a new Edebug level, the initial execution mode comes
from the value of the variable `edebug-initial-mode'.  By default, this
specifies step mode.  Note that you may reenter the same Edebug level
several times if, for example, an instrumented function is called
several times from one command.


File: elisp,  Node: Jumping,  Next: Edebug Misc,  Prev: Edebug Execution Modes,  Up: Edebug

Jumping
-------

   The commands described in this section execute until they reach a
specified location.  All except `i' make a temporary breakpoint to
establish the place to stop, then switch to go mode.  Any other
breakpoint reached before the intended stop point will also stop
execution.  *Note Breakpoints::, for the details on breakpoints.

   These commands may fail to work as expected in case of nonlocal exit,
as that can bypass the temporary breakpoint where you expected the
program to stop.

`h'
     Proceed to the stop point near where point is (`edebug-goto-here').

`f'
     Run the program forward over one expression
     (`edebug-forward-sexp').

`o'
     Run the program until the end of the containing sexp.

`i'
     Step into the function or macro called by the form after point.

   The `h' command proceeds to the stop point near the current location
of point, using a temporary breakpoint.  See *Note Breakpoints::, for
more information about breakpoints.

   The `f' command runs the program forward over one expression.  More
precisely, it sets a temporary breakpoint at the position that `C-M-f'
would reach, then executes in go mode so that the program will stop at
breakpoints.

   With a prefix argument N, the temporary breakpoint is placed N sexps
beyond point.  If the containing list ends before N more elements, then
the place to stop is after the containing expression.

   You must check that the position `C-M-f' finds is a place that the
program will really get to.  In `cond', for example, this may not be
true.

   For flexibility, the `f' command does `forward-sexp' starting at
point, rather than at the stop point.  If you want to execute one
expression _from the current stop point_, first type `w', to move point
there, and then type `f'.

   The `o' command continues "out of" an expression.  It places a
temporary breakpoint at the end of the sexp containing point.  If the
containing sexp is a function definition itself, `o' continues until
just before the last sexp in the definition.  If that is where you are
now, it returns from the function and then stops.  In other words, this
command does not exit the currently executing function unless you are
positioned after the last sexp.

   The `i' command steps into the function or macro called by the list
form after point, and stops at its first stop point.  Note that the form
need not be the one about to be evaluated.  But if the form is a
function call about to be evaluated, remember to use this command before
any of the arguments are evaluated, since otherwise it will be too late.

   The `i' command instruments the function or macro it's supposed to
step into, if it isn't instrumented already.  This is convenient, but
keep in mind that the function or macro remains instrumented unless you
explicitly arrange to deinstrument it.


File: elisp,  Node: Edebug Misc,  Next: Breakpoints,  Prev: Jumping,  Up: Edebug

Miscellaneous Edebug Commands
-----------------------------

   Some miscellaneous Edebug commands are described here.

`?'
     Display the help message for Edebug (`edebug-help').

`C-]'
     Abort one level back to the previous command level
     (`abort-recursive-edit').

`q'
     Return to the top level editor command loop (`top-level').  This
     exits all recursive editing levels, including all levels of Edebug
     activity.  However, instrumented code protected with
     `unwind-protect' or `condition-case' forms may resume debugging.

`Q'
     Like `q', but don't stop even for protected code
     (`top-level-nonstop').

`r'
     Redisplay the most recently known expression result in the echo
     area (`edebug-previous-result').

`d'
     Display a backtrace, excluding Edebug's own functions for clarity
     (`edebug-backtrace').

     You cannot use debugger commands in the backtrace buffer in Edebug
     as you would in the standard debugger.

     The backtrace buffer is killed automatically when you continue
     execution.

   You can invoke commands from Edebug that activate Edebug again
recursively.  Whenever Edebug is active, you can quit to the top level
with `q' or abort one recursive edit level with `C-]'.  You can display
a backtrace of all the pending evaluations with `d'.


File: elisp,  Node: Breakpoints,  Next: Trapping Errors,  Prev: Edebug Misc,  Up: Edebug

Breakpoints
-----------

   Edebug's step mode stops execution when the next stop point is
reached.  There are three other ways to stop Edebug execution once it
has started: breakpoints, the global break condition, and source
breakpoints.

   While using Edebug, you can specify "breakpoints" in the program you
are testing: these are places where execution should stop.  You can set
a breakpoint at any stop point, as defined in *Note Using Edebug::.  For
setting and unsetting breakpoints, the stop point that is affected is
the first one at or after point in the source code buffer.  Here are the
Edebug commands for breakpoints:

`b'
     Set a breakpoint at the stop point at or after point
     (`edebug-set-breakpoint').  If you use a prefix argument, the
     breakpoint is temporary--it turns off the first time it stops the
     program.

`u'
     Unset the breakpoint (if any) at the stop point at or after point
     (`edebug-unset-breakpoint').

`x CONDITION <RET>'
     Set a conditional breakpoint which stops the program only if
     CONDITION evaluates to a non-`nil' value
     (`edebug-set-conditional-breakpoint').  With a prefix argument, the
     breakpoint is temporary.

`B'
     Move point to the next breakpoint in the current definition
     (`edebug-next-breakpoint').

   While in Edebug, you can set a breakpoint with `b' and unset one
with `u'.  First move point to the Edebug stop point of your choice,
then type `b' or `u' to set or unset a breakpoint there.  Unsetting a
breakpoint where none has been set has no effect.

   Re-evaluating or reinstrumenting a definition removes all of its
previous breakpoints.

   A "conditional breakpoint" tests a condition each time the program
gets there.  Any errors that occur as a result of evaluating the
condition are ignored, as if the result were `nil'.  To set a
conditional breakpoint, use `x', and specify the condition expression
in the minibuffer.  Setting a conditional breakpoint at a stop point
that has a previously established conditional breakpoint puts the
previous condition expression in the minibuffer so you can edit it.

   You can make a conditional or unconditional breakpoint "temporary"
by using a prefix argument with the command to set the breakpoint.
When a temporary breakpoint stops the program, it is automatically
unset.

   Edebug always stops or pauses at a breakpoint, except when the Edebug
mode is Go-nonstop.  In that mode, it ignores breakpoints entirely.

   To find out where your breakpoints are, use the `B' command, which
moves point to the next breakpoint following point, within the same
function, or to the first breakpoint if there are no following
breakpoints.  This command does not continue execution--it just moves
point in the buffer.

* Menu:

* Global Break Condition::	Breaking on an event.
* Source Breakpoints::  	Embedding breakpoints in source code.


File: elisp,  Node: Global Break Condition,  Next: Source Breakpoints,  Up: Breakpoints

Global Break Condition
......................

   A "global break condition" stops execution when a specified
condition is satisfied, no matter where that may occur.  Edebug
evaluates the global break condition at every stop point; if it
evaluates to a non-`nil' value, then execution stops or pauses
depending on the execution mode, as if a breakpoint had been hit.  If
evaluating the condition gets an error, execution does not stop.

   The condition expression is stored in
`edebug-global-break-condition'.  You can specify a new expression
using the `X' command (`edebug-set-global-break-condition').

   The global break condition is the simplest way to find where in your
code some event occurs, but it makes code run much more slowly.  So you
should reset the condition to `nil' when not using it.


File: elisp,  Node: Source Breakpoints,  Prev: Global Break Condition,  Up: Breakpoints

Source Breakpoints
..................

   All breakpoints in a definition are forgotten each time you
reinstrument it.  If you wish to make a breakpoint that won't be
forgotten, you can write a "source breakpoint", which is simply a call
to the function `edebug' in your source code.  You can, of course, make
such a call conditional.  For example, in the `fac' function, you can
insert the first line as shown below, to stop when the argument reaches
zero:

     (defun fac (n)
       (if (= n 0) (edebug))
       (if (< 0 n)
           (* n (fac (1- n)))
         1))

   When the `fac' definition is instrumented and the function is
called, the call to `edebug' acts as a breakpoint.  Depending on the
execution mode, Edebug stops or pauses there.

   If no instrumented code is being executed when `edebug' is called,
that function calls `debug'.


File: elisp,  Node: Trapping Errors,  Next: Edebug Views,  Prev: Breakpoints,  Up: Edebug

Trapping Errors
---------------

   Emacs normally displays an error message when an error is signaled
and not handled with `condition-case'.  While Edebug is active and
executing instrumented code, it normally responds to all unhandled
errors.  You can customize this with the options `edebug-on-error' and
`edebug-on-quit'; see *Note Edebug Options::.

   When Edebug responds to an error, it shows the last stop point
encountered before the error.  This may be the location of a call to a
function which was not instrumented, and within which the error actually
occurred.  For an unbound variable error, the last known stop point
might be quite distant from the offending variable reference.  In that
case, you might want to display a full backtrace (*note Edebug Misc::).

   If you change `debug-on-error' or `debug-on-quit' while Edebug is
active, these changes will be forgotten when Edebug becomes inactive.
Furthermore, during Edebug's recursive edit, these variables are bound
to the values they had outside of Edebug.


File: elisp,  Node: Edebug Views,  Next: Edebug Eval,  Prev: Trapping Errors,  Up: Edebug

Edebug Views
------------

   These Edebug commands let you view aspects of the buffer and window
status as they were before entry to Edebug.  The outside window
configuration is the collection of windows and contents that were in
effect outside of Edebug.

`v'
     Temporarily view the outside window configuration
     (`edebug-view-outside').

`p'
     Temporarily display the outside current buffer with point at its
     outside position (`edebug-bounce-point').  With a prefix argument
     N, pause for N seconds instead.

`w'
     Move point back to the current stop point in the source code buffer
     (`edebug-where').

     If you use this command in a different window displaying the same
     buffer, that window will be used instead to display the current
     definition in the future.

`W'
     Toggle whether Edebug saves and restores the outside window
     configuration (`edebug-toggle-save-windows').

     With a prefix argument, `W' only toggles saving and restoring of
     the selected window.  To specify a window that is not displaying
     the source code buffer, you must use `C-x X W' from the global
     keymap.

   You can view the outside window configuration with `v' or just
bounce to the point in the current buffer with `p', even if it is not
normally displayed.  After moving point, you may wish to jump back to
the stop point with `w' from a source code buffer.

   Each time you use `W' to turn saving _off_, Edebug forgets the saved
outside window configuration--so that even if you turn saving back
_on_, the current window configuration remains unchanged when you next
exit Edebug (by continuing the program).  However, the automatic
redisplay of `*edebug*' and `*edebug-trace*' may conflict with the
buffers you wish to see unless you have enough windows open.


File: elisp,  Node: Edebug Eval,  Next: Eval List,  Prev: Edebug Views,  Up: Edebug

Evaluation
----------

   While within Edebug, you can evaluate expressions "as if" Edebug
were not running.  Edebug tries to be invisible to the expression's
evaluation and printing.  Evaluation of expressions that cause side
effects will work as expected, except for changes to data that Edebug
explicitly saves and restores.  *Note The Outside Context::, for details
on this process.

`e EXP <RET>'
     Evaluate expression EXP in the context outside of Edebug
     (`edebug-eval-expression').  That is, Edebug tries to minimize its
     interference with the evaluation.

`M-: EXP <RET>'
     Evaluate expression EXP in the context of Edebug itself.

`C-x C-e'
     Evaluate the expression before point, in the context outside of
     Edebug (`edebug-eval-last-sexp').

   Edebug supports evaluation of expressions containing references to
lexically bound symbols created by the following constructs in `cl.el'
(version 2.03 or later): `lexical-let', `macrolet', and
`symbol-macrolet'.


File: elisp,  Node: Eval List,  Next: Printing in Edebug,  Prev: Edebug Eval,  Up: Edebug

Evaluation List Buffer
----------------------

   You can use the "evaluation list buffer", called `*edebug*', to
evaluate expressions interactively.  You can also set up the
"evaluation list" of expressions to be evaluated automatically each
time Edebug updates the display.

`E'
     Switch to the evaluation list buffer `*edebug*'
     (`edebug-visit-eval-list').

   In the `*edebug*' buffer you can use the commands of Lisp
Interaction mode (*note Lisp Interaction: (emacs)Lisp Interaction.) as
well as these special commands:

`C-j'
     Evaluate the expression before point, in the outside context, and
     insert the value in the buffer (`edebug-eval-print-last-sexp').

`C-x C-e'
     Evaluate the expression before point, in the context outside of
     Edebug (`edebug-eval-last-sexp').

`C-c C-u'
     Build a new evaluation list from the contents of the buffer
     (`edebug-update-eval-list').

`C-c C-d'
     Delete the evaluation list group that point is in
     (`edebug-delete-eval-item').

`C-c C-w'
     Switch back to the source code buffer at the current stop point
     (`edebug-where').

   You can evaluate expressions in the evaluation list window with
`C-j' or `C-x C-e', just as you would in `*scratch*'; but they are
evaluated in the context outside of Edebug.

   The expressions you enter interactively (and their results) are lost
when you continue execution; but you can set up an "evaluation list"
consisting of expressions to be evaluated each time execution stops.

   To do this, write one or more "evaluation list groups" in the
evaluation list buffer.  An evaluation list group consists of one or
more Lisp expressions.  Groups are separated by comment lines.

   The command `C-c C-u' (`edebug-update-eval-list') rebuilds the
evaluation list, scanning the buffer and using the first expression of
each group.  (The idea is that the second expression of the group is the
value previously computed and displayed.)

   Each entry to Edebug redisplays the evaluation list by inserting each
expression in the buffer, followed by its current value.  It also
inserts comment lines so that each expression becomes its own group.
Thus, if you type `C-c C-u' again without changing the buffer text, the
evaluation list is effectively unchanged.

   If an error occurs during an evaluation from the evaluation list, the
error message is displayed in a string as if it were the result.
Therefore, expressions that use variables not currently valid do not
interrupt your debugging.

   Here is an example of what the evaluation list window looks like
after several expressions have been added to it:

     (current-buffer)
     #<buffer *scratch*>
     ;---------------------------------------------------------------
     (selected-window)
     #<window 16 on *scratch*>
     ;---------------------------------------------------------------
     (point)
     196
     ;---------------------------------------------------------------
     bad-var
     "Symbol's value as variable is void: bad-var"
     ;---------------------------------------------------------------
     (recursion-depth)
     0
     ;---------------------------------------------------------------
     this-command
     eval-last-sexp
     ;---------------------------------------------------------------

   To delete a group, move point into it and type `C-c C-d', or simply
delete the text for the group and update the evaluation list with `C-c
C-u'.  To add a new expression to the evaluation list, insert the
expression at a suitable place, insert a new comment line, then type
`C-c C-u'.  You need not insert dashes in the comment line--its
contents don't matter.

   After selecting `*edebug*', you can return to the source code buffer
with `C-c C-w'.  The `*edebug*' buffer is killed when you continue
execution, and recreated next time it is needed.


File: elisp,  Node: Printing in Edebug,  Next: Trace Buffer,  Prev: Eval List,  Up: Edebug

Printing in Edebug
------------------

   If an expression in your program produces a value containing circular
list structure, you may get an error when Edebug attempts to print it.

   One way to cope with circular structure is to set `print-length' or
`print-level' to truncate the printing.  Edebug does this for you; it
binds `print-length' and `print-level' to 50 if they were `nil'.
(Actually, the variables `edebug-print-length' and `edebug-print-level'
specify the values to use within Edebug.)  *Note Output Variables::.

 - User Option: edebug-print-length
     If non-`nil', Edebug binds `print-length' to this value while
     printing results.  The default value is `50'.

 - User Option: edebug-print-level
     If non-`nil', Edebug binds `print-level' to this value while
     printing results.  The default value is `50'.

   You can also print circular structures and structures that share
elements more informatively by binding `print-circle' to a non-`nil'
value.

   Here is an example of code that creates a circular structure:

     (setq a '(x y))
     (setcar a a)

Custom printing prints this as `Result: #1=(#1# y)'.  The `#1='
notation labels the structure that follows it with the label `1', and
the `#1#' notation references the previously labeled structure.  This
notation is used for any shared elements of lists or vectors.

 - User Option: edebug-print-circle
     If non-`nil', Edebug binds `print-circle' to this value while
     printing results.  The default value is `nil'.

   Other programs can also use custom printing; see `cust-print.el' for
details.


File: elisp,  Node: Trace Buffer,  Next: Coverage Testing,  Prev: Printing in Edebug,  Up: Edebug

Trace Buffer
------------

   Edebug can record an execution trace, storing it in a buffer named
`*edebug-trace*'.  This is a log of function calls and returns, showing
the function names and their arguments and values.  To enable trace
recording, set `edebug-trace' to a non-`nil' value.

   Making a trace buffer is not the same thing as using trace execution
mode (*note Edebug Execution Modes::).

   When trace recording is enabled, each function entry and exit adds
lines to the trace buffer.  A function entry record consists of
`::::{', followed by the function name and argument values.  A function
exit record consists of `::::}', followed by the function name and
result of the function.

   The number of `:'s in an entry shows its recursion depth.  You can
use the braces in the trace buffer to find the matching beginning or
end of function calls.

   You can customize trace recording for function entry and exit by
redefining the functions `edebug-print-trace-before' and
`edebug-print-trace-after'.

 - Macro: edebug-tracing string body...
     This macro requests additional trace information around the
     execution of the BODY forms.  The argument STRING specifies text
     to put in the trace buffer.  All the arguments are evaluated, and
     `edebug-tracing' returns the value of the last form in BODY.

 - Function: edebug-trace format-string &rest format-args
     This function inserts text in the trace buffer.  It computes the
     text with `(apply 'format FORMAT-STRING FORMAT-ARGS)'.  It also
     appends a newline to separate entries.

   `edebug-tracing' and `edebug-trace' insert lines in the trace buffer
whenever they are called, even if Edebug is not active.  Adding text to
the trace buffer also scrolls its window to show the last lines
inserted.


File: elisp,  Node: Coverage Testing,  Next: The Outside Context,  Prev: Trace Buffer,  Up: Edebug

Coverage Testing
----------------

   Edebug provides rudimentary coverage testing and display of execution
frequency.

   Coverage testing works by comparing the result of each expression
with the previous result; each form in the program is considered
"covered" if it has returned two different values since you began
testing coverage in the current Emacs session.  Thus, to do coverage
testing on your program, execute it under various conditions and note
whether it behaves correctly; Edebug will tell you when you have tried
enough different conditions that each form has returned two different
values.

   Coverage testing makes execution slower, so it is only done if
`edebug-test-coverage' is non-`nil'.  Frequency counting is performed
for all execution of an instrumented function, even if the execution
mode is Go-nonstop, and regardless of whether coverage testing is
enabled.

   Use `M-x edebug-display-freq-count' to display both the coverage
information and the frequency counts for a definition.

 - Command: edebug-display-freq-count
     This command displays the frequency count data for each line of the
     current definition.

     The frequency counts appear as comment lines after each line of
     code, and you can undo all insertions with one `undo' command.  The
     counts appear under the `(' before an expression or the `)' after
     an expression, or on the last character of a variable.  To
     simplify the display, a count is not shown if it is equal to the
     count of an earlier expression on the same line.

     The character `=' following the count for an expression says that
     the expression has returned the same value each time it was
     evaluated.  In other words, it is not yet "covered" for coverage
     testing purposes.

     To clear the frequency count and coverage data for a definition,
     simply reinstrument it with `eval-defun'.

   For example, after evaluating `(fac 5)' with a source breakpoint,
and setting `edebug-test-coverage' to `t', when the breakpoint is
reached, the frequency data looks like this:

     (defun fac (n)
       (if (= n 0) (edebug))
     ;#6           1      0 =5
       (if (< 0 n)
     ;#5         =
           (* n (fac (1- n)))
     ;#    5               0
         1))
     ;#   0

   The comment lines show that `fac' was called 6 times.  The first
`if' statement returned 5 times with the same result each time; the
same is true of the condition on the second `if'.  The recursive call
of `fac' did not return at all.


File: elisp,  Node: The Outside Context,  Next: Instrumenting Macro Calls,  Prev: Coverage Testing,  Up: Edebug

The Outside Context
-------------------

   Edebug tries to be transparent to the program you are debugging, but
it does not succeed completely.  Edebug also tries to be transparent
when you evaluate expressions with `e' or with the evaluation list
buffer, by temporarily restoring the outside context.  This section
explains precisely what context Edebug restores, and how Edebug fails to
be completely transparent.

* Menu:

* Checking Whether to Stop::	When Edebug decides what to do.
* Edebug Display Update::	When Edebug updates the display.
* Edebug Recursive Edit::	When Edebug stops execution.


File: elisp,  Node: Checking Whether to Stop,  Next: Edebug Display Update,  Up: The Outside Context

Checking Whether to Stop
........................

   Whenever Edebug is entered, it needs to save and restore certain data
before even deciding whether to make trace information or stop the
program.

   * `max-lisp-eval-depth' and `max-specpdl-size' are both incremented
     once to reduce Edebug's impact on the stack.  You could, however,
     still run out of stack space when using Edebug.

   * The state of keyboard macro execution is saved and restored.  While
     Edebug is active, `executing-macro' is bound to
     `edebug-continue-kbd-macro'.



File: elisp,  Node: Edebug Display Update,  Next: Edebug Recursive Edit,  Prev: Checking Whether to Stop,  Up: The Outside Context

Edebug Display Update
.....................

   When Edebug needs to display something (e.g., in trace mode), it
saves the current window configuration from "outside" Edebug (*note
Window Configurations::).  When you exit Edebug (by continuing the
program), it restores the previous window configuration.

   Emacs redisplays only when it pauses.  Usually, when you continue
execution, the program re-enters Edebug at a breakpoint or after
stepping, without pausing or reading input in between.  In such cases,
Emacs never gets a chance to redisplay the "outside" configuration.
Consequently, what you see is the same window configuration as the last
time Edebug was active, with no interruption.

   Entry to Edebug for displaying something also saves and restores the
following data (though some of them are deliberately not restored if an
error or quit signal occurs).

   * Which buffer is current, and the positions of point and the mark
     in the current buffer, are saved and restored.

   * The outside window configuration is saved and restored if
     `edebug-save-windows' is non-`nil' (*note Edebug Display Update::).

     The window configuration is not restored on error or quit, but the
     outside selected window _is_ reselected even on error or quit in
     case a `save-excursion' is active.  If the value of
     `edebug-save-windows' is a list, only the listed windows are saved
     and restored.

     The window start and horizontal scrolling of the source code
     buffer are not restored, however, so that the display remains
     coherent within Edebug.

   * The value of point in each displayed buffer is saved and restored
     if `edebug-save-displayed-buffer-points' is non-`nil'.

   * The variables `overlay-arrow-position' and `overlay-arrow-string'
     are saved and restored.  So you can safely invoke Edebug from the
     recursive edit elsewhere in the same buffer.

   * `cursor-in-echo-area' is locally bound to `nil' so that the cursor
     shows up in the window.


File: elisp,  Node: Edebug Recursive Edit,  Prev: Edebug Display Update,  Up: The Outside Context

Edebug Recursive Edit
.....................

   When Edebug is entered and actually reads commands from the user, it
saves (and later restores) these additional data:

   * The current match data.  *Note Match Data::.

   * `last-command', `this-command', `last-command-char',
     `last-input-char', `last-input-event', `last-command-event',
     `last-event-frame', `last-nonmenu-event', and `track-mouse'.
     Commands used within Edebug do not affect these variables outside
     of Edebug.

     The key sequence returned by `this-command-keys' is changed by
     executing commands within Edebug and there is no way to reset the
     key sequence from Lisp.

     Edebug cannot save and restore the value of
     `unread-command-events'.  Entering Edebug while this variable has a
     nontrivial value can interfere with execution of the program you
     are debugging.

   * Complex commands executed while in Edebug are added to the variable
     `command-history'.  In rare cases this can alter execution.

   * Within Edebug, the recursion depth appears one deeper than the
     recursion depth outside Edebug.  This is not true of the
     automatically updated evaluation list window.

   * `standard-output' and `standard-input' are bound to `nil' by the
     `recursive-edit', but Edebug temporarily restores them during
     evaluations.

   * The state of keyboard macro definition is saved and restored.
     While Edebug is active, `defining-kbd-macro' is bound to
     `edebug-continue-kbd-macro'.


File: elisp,  Node: Instrumenting Macro Calls,  Next: Edebug Options,  Prev: The Outside Context,  Up: Edebug

Instrumenting Macro Calls
-------------------------

   When Edebug instruments an expression that calls a Lisp macro, it
needs additional information about the macro to do the job properly.
This is because there is no a-priori way to tell which subexpressions
of the macro call are forms to be evaluated.  (Evaluation may occur
explicitly in the macro body, or when the resulting expansion is
evaluated, or any time later.)

   Therefore, you must define an Edebug specification for each macro
that Edebug will encounter, to explain the format of calls to that
macro.  To do this, use `def-edebug-spec'.

 - Macro: def-edebug-spec macro specification
     Specify which expressions of a call to macro MACRO are forms to be
     evaluated.  For simple macros, the SPECIFICATION often looks very
     similar to the formal argument list of the macro definition, but
     specifications are much more general than macro arguments.

     The MACRO argument can actually be any symbol, not just a macro
     name.

   Here is a simple example that defines the specification for the
`for' example macro (*note Argument Evaluation::), followed by an
alternative, equivalent specification.

     (def-edebug-spec for
       (symbolp "from" form "to" form "do" &rest form))
     
     (def-edebug-spec for
       (symbolp ['from form] ['to form] ['do body]))

   Here is a table of the possibilities for SPECIFICATION and how each
directs processing of arguments.

`t'
     All arguments are instrumented for evaluation.

`0'
     None of the arguments is instrumented.

a symbol
     The symbol must have an Edebug specification which is used instead.
     This indirection is repeated until another kind of specification is
     found.  This allows you to inherit the specification from another
     macro.

a list
     The elements of the list describe the types of the arguments of a
     calling form.  The possible elements of a specification list are
     described in the following sections.

* Menu:

* Specification List::		How to specify complex patterns of evaluation.
* Backtracking::		What Edebug does when matching fails.
* Specification Examples::	To help understand specifications.

