This is emacs-lisp-intro.info, produced by makeinfo version 4.0b from
emacs-lisp-intro.texi.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs Lisp Intro: (eintr).
  			A simple introduction to Emacs Lisp programming.
END-INFO-DIR-ENTRY

   This is an introduction to `Programming in Emacs Lisp', for people
who are not programmers.

   Edition 2.04, 2001 Dec 17

   Copyright (C) 1990, '91, '92, '93, '94, '95, '97, 2001 Free Software
Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Section being the Preface, with the Front-Cover Texts being
no Front-Cover Texts, and with the Back-Cover Texts being no Back-Cover
Texts.  A copy of the license is included in the section entitled "GNU
Free Documentation License".


File: emacs-lisp-intro.info,  Node: Top,  Next: Preface,  Prev: (dir),  Up: (dir)

An Introduction to Programming in Emacs Lisp
********************************************

   This is an introduction to `Programming in Emacs Lisp', for people
who are not programmers.

   This master menu first lists each chapter and index; then it lists
every node in every chapter.

* Menu:

* Preface::                     What to look for.
* List Processing::             What is Lisp?
* Practicing Evaluation::       Running several programs.
* Writing Defuns::              How to write function definitions.
* Buffer Walk Through::         Exploring a few buffer-related functions.
* More Complex::                A few, even more complex functions.
* Narrowing & Widening::        Restricting your and Emacs attention to
                                    a region.
* car cdr & cons::              Fundamental functions in Lisp.
* Cutting & Storing Text::      Removing text and saving it.
* List Implementation::         How lists are implemented in the computer.
* Yanking::                     Pasting stored text.
* Loops & Recursion::           How to repeat a process.
* Regexp Search::               Regular expression searches.
* Counting Words::              A review of repetition and regexps.
* Words in a defun::            Counting words in a `defun'.
* Readying a Graph::            A prototype graph printing function.
* Emacs Initialization::        How to write a `.emacs' file.
* Debugging::                   How to run the Emacs Lisp debuggers.
* Conclusion::                  Now you have the basics.
* the-the::                     An appendix: how to find reduplicated words.
* Kill Ring::                   An appendix: how the kill ring works.
* Full Graph::                  How to create a graph with labelled axes.
* GNU Free Documentation License::
* Index::
* About the Author::

 --- The Detailed Node Listing ---

Preface

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::

List Processing

* Lisp Lists::                  What are lists?
* Run a Program::               Any list in Lisp is a program ready to run.
* Making Errors::               Generating an error message.
* Names & Definitions::         Names of symbols and function definitions.
* Lisp Interpreter::            What the Lisp interpreter does.
* Evaluation::                  Running a program.
* Variables::                   Returning a value from a variable.
* Arguments::                   Passing information to a function.
* set & setq::                  Setting the value of a variable.
* Summary::                     The major points.
* Error Message Exercises::

Lisp Lists

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formating lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.

The Lisp Interpreter

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.

Evaluation

* Evaluating Inner Lists::      Lists within lists...

Variables

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.

Arguments

* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* Variable Number of Arguments::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.

Setting the Value of a Variable

* Using set::                   Setting values.
* Using setq::                  Setting a quoted value.
* Counting::                    Using `setq' to count.

Practicing Evaluation

* How to Evaluate::             Typing editing commands or C-x C-e
                                  causes evaluation.
* Buffer Names::                Buffers and files are different.
* Getting Buffers::             Getting a buffer itself, not merely its name.
* Switching Buffers::           How to change to another buffer.
* Buffer Size & Locations::     Where point is located and the size of
                                the buffer.
* Evaluation Exercise::

How To Write Function Definitions

* Primitive Functions::
* defun::                       The `defun' special form.
* Install::                     Install a function definition.
* Interactive::                 Making a function interactive.
* Interactive Options::         Different options for `interactive'.
* Permanent Installation::      Installing code permanently.
* let::                         Creating and initializing local variables.
* if::                          What if?
* else::                        If--then--else expressions.
* Truth & Falsehood::           What Lisp considers false and true.
* save-excursion::              Keeping track of point, mark, and buffer.
* Review::
* defun Exercises::

Install a Function Definition

* Effect of installation::
* Change a defun::              How to change a function definition.

Make a Function Interactive

* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::  The interactive version.

`let'

* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::

The `if' Special Form

* if in more detail::
* type-of-animal in detail::    An example of an `if' expression.

Truth and Falsehood in Emacs Lisp

* nil explained::               `nil' has two meanings.

`save-excursion'

* Point and mark::              A review of various locations.
* Template for save-excursion::

A Few Buffer--Related Functions

* Finding More::                How to find more information.
* simplified-beginning-of-buffer::  Shows `goto-char',
                                `point-min', and `push-mark'.
* mark-whole-buffer::           Almost the same as `beginning-of-buffer'.
* append-to-buffer::            Uses `save-excursion' and
                                `insert-buffer-substring'.
* Buffer Related Review::       Review.
* Buffer Exercises::

The Definition of `mark-whole-buffer'

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.

The Definition of `append-to-buffer'

* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a `let' expression.
* append save-excursion::       How the `save-excursion' works.

A Few More Complex Functions

* copy-to-buffer::              With `set-buffer', `get-buffer-create'.
* insert-buffer::               Read-only, and with `or'.
* beginning-of-buffer::         Shows `goto-char',
                                `point-min', and `push-mark'.
* Second Buffer Related Review::
* optional Exercise::

The Definition of `insert-buffer'

* insert-buffer code::
* insert-buffer interactive::   When you can read, but not write.
* insert-buffer body::          The body has an `or' and a `let'.
* if & or::                     Using an `if' instead of an `or'.
* Insert or::                   How the `or' expression works.
* Insert let::                  Two `save-excursion' expressions.

The Interactive Expression in `insert-buffer'

* Read-only buffer::            When a buffer cannot be modified.
* b for interactive::           An existing buffer or else its name.

Complete Definition of `beginning-of-buffer'

* Optional Arguments::
* beginning-of-buffer opt arg::  Example with optional argument.
* beginning-of-buffer complete::

`beginning-of-buffer' with an Argument

* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::

Narrowing and Widening

* Narrowing advantages::        The advantages of narrowing
* save-restriction::            The `save-restriction' special form.
* what-line::                   The number of the line that point is on.
* narrow Exercise::

`car', `cdr', `cons': Fundamental Functions

* Strange Names::               An historical aside: why the strange names?
* car & cdr::                   Functions for extracting part of a list.
* cons::                        Constructing a list.
* nthcdr::                      Calling `cdr' repeatedly.
* nth::
* setcar::                      Changing the first element of a list.
* setcdr::                      Changing the rest of a list.
* cons Exercise::

`cons'

* Build a list::
* length::                      How to find the length of a list.

Cutting and Storing Text

* Storing Text::                Text is stored in a list.
* zap-to-char::                 Cutting out text up to a character.
* kill-region::                 Cutting text out of a region.
* Digression into C::           Minor note on C programming language macros.
* defvar::                      How to give a variable an initial value.
* copy-region-as-kill::         A definition for copying text.
* cons & search-fwd Review::
* search Exercises::

`zap-to-char'

* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     A three part interactive expression.
* zap-to-char body::            A short overview.
* search-forward::              How to search for a string.
* progn::                       The `progn' special form.
* Summing up zap-to-char::      Using `point' and `search-forward'.

`kill-region'

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* delete-and-extract-region::   Doing the work.

Initializing a Variable with `defvar'

* See variable current value::
* defvar and asterisk::         An old-time convention.

`copy-region-as-kill'

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::    The body of `copy-region-as-kill'.

The Body of `copy-region-as-kill'

* last-command & this-command::
* kill-append function::
* kill-new function::

How Lists are Implemented

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::

Yanking Text Back

* Kill Ring Overview::          The kill ring is a list.
* kill-ring-yank-pointer::      The `kill-ring-yank-pointer' variable.
* yank nthcdr Exercises::

Loops and Recursion

* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::

`while'

* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A `while' loop that uses a list.
* print-elements-of-list::      Uses `while', `car', `cdr'.
* Incrementing Loop::           A loop with an incrementing counter.
* Decrementing Loop::           A loop with a decrementing counter.

A Loop with an Incrementing Counter

* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.

Loop with a Decrementing Counter

* Decrementing Example::        More pebbles on the beach.
* Dec Example parts::           The parts of the function definition.
* Dec Example altogether::      Putting the function definition together.

Save your time: `dolist' and `dotimes'

* dolist::
* dotimes::

Recursion

* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         Using a list as the test whether to recurse.
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::

Recursion in Place of a Counter

* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::

Recursive Patterns

* Every::
* Accumulate::
* Keep::

Regular Expression Searches

* sentence-end::                The regular expression for `sentence-end'.
* re-search-forward::           Very similar to `search-forward'.
* forward-sentence::            A straightforward example of regexp search.
* forward-paragraph::           A somewhat complex example.
* etags::                       How to create your own `TAGS' table.
* Regexp Review::
* re-search Exercises::

`forward-sentence'

* Complete forward-sentence::
* fwd-sentence while loops::    Two `while' loops.
* fwd-sentence re-search::      A regular expression search.

`forward-paragraph': a Goldmine of Functions

* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The `let*' expression.
* fwd-para while::              The forward motion `while' loop.
* fwd-para between paragraphs::  Movement between paragraphs.
* fwd-para within paragraph::   Movement within paragraphs.
* fwd-para no fill prefix::     When there is no fill prefix.
* fwd-para with fill prefix::   When there is a fill prefix.
* fwd-para summary::            Summary of `forward-paragraph' code.

Counting: Repetition and Regexps

* Why Count Words::
* count-words-region::          Use a regexp, but find a problem.
* recursive-count-words::       Start with case of no words in region.
* Counting Exercise::

The `count-words-region' Function

* Design count-words-region::   The definition using a `while' loop.
* Whitespace Bug::              The Whitespace Bug in `count-words-region'.

Counting Words in a `defun'

* Divide and Conquer::
* Words and Symbols::           What to count?
* Syntax::                      What constitutes a word or symbol?
* count-words-in-defun::        Very like `count-words'.
* Several defuns::              Counting several defuns in a file.
* Find a File::                 Do you want to look at a file?
* lengths-list-file::           A list of the lengths of many definitions.
* Several files::               Counting in definitions in different files.
* Several files recursively::   Recursively counting in different files.
* Prepare the data::            Prepare the data for display in a graph.

Count Words in `defuns' in Different Files

* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      Attach one list to another.

Prepare the Data for Display in a Graph

* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::

Readying a Graph

* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::

Your `.emacs' File

* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning a .emacs File::     How to write a `.emacs file'.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don't use tabs with TeX
* Keybindings::                 Create some personal keybindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in version 19 in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.

Debugging

* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with C-g.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::

Handling the Kill Ring

* rotate-yank-pointer::         Move a pointer along a list and around.
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert first element pointed to.

The `rotate-yank-pointer' Function

* Understanding rotate-yk-ptr::
* rotate-yk-ptr body::          The body of `rotate-yank-pointer'.

The Body of `rotate-yank-pointer'

* Digression concerning error::  How to mislead humans, but not computers.
* rotate-yk-ptr else-part::     The else-part of the `if' expression.
* Remainder Function::          The remainder, `%', function.
* rotate-yk-ptr remainder::     Using `%' in `rotate-yank-pointer'.
* kill-rng-yk-ptr last elt::    Pointing to the last element.

`yank'

* rotate-yk-ptr arg::           Pass the argument to `rotate-yank-pointer'.
* rotate-yk-ptr negative arg::  Pass a negative argument.

A Graph with Labelled Axes

* Labelled Example::
* print-graph Varlist::         `let' expression in `print-graph'.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.

The `print-Y-axis' Function

* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.

The `print-X-axis' Function

* Similarities differences::    Much like `print-Y-axis', but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.

Printing the Whole Graph

* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug ... most insidious.
* Final printed graph::         The graph itself!


File: emacs-lisp-intro.info,  Node: Preface,  Next: List Processing,  Prev: Top,  Up: Top

Preface
*******

   Most of the GNU Emacs integrated environment is written in the
programming language called Emacs Lisp.  The code written in this
programming language is the software--the sets of instructions--that
tell the computer what to do when you give it commands.  Emacs is
designed so that you can write new code in Emacs Lisp and easily
install it as an extension to the editor.

   (GNU Emacs is sometimes called an "extensible editor", but it does
much more than provide editing capabilities.  It is better to refer to
Emacs as an "extensible computing environment".  However, that phrase
is quite a mouthful.  It is easier to refer to Emacs simply as an
editor.  Moreover, everything you do in Emacs--find the Mayan date and
phases of the moon, simplify polynomials, debug code, manage files,
read letters, write books--all these activities are kinds of editing in
the most general sense of the word.)

* Menu:

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::


File: emacs-lisp-intro.info,  Node: Why,  Next: On Reading this Text,  Prev: Preface,  Up: Preface

Why Study Emacs Lisp?
=====================

   Although Emacs Lisp is usually thought of in association only with
Emacs, it is a full computer programming language.  You can use Emacs
Lisp as you would any other programming language.

   Perhaps you want to understand programming; perhaps you want to
extend Emacs; or perhaps you want to become a programmer.  This
introduction to Emacs Lisp is designed to get you started: to guide you
in learning the fundamentals of programming, and more importantly, to
show you how you can teach yourself to go further.


File: emacs-lisp-intro.info,  Node: On Reading this Text,  Next: Who You Are,  Prev: Why,  Up: Preface

On Reading this Text
====================

   All through this document, you will see little sample programs you
can run inside of Emacs.  If you read this document in Info inside of
GNU Emacs, you can run the programs as they appear.  (This is easy to
do and is explained when the examples are presented.)  Alternatively,
you can read this introduction as a printed book while sitting beside a
computer running Emacs.  (This is what I like to do; I like printed
books.)  If you don't have a running Emacs beside you, you can still
read this book, but in this case, it is best to treat it as a novel or
as a travel guide to a country not yet visited: interesting, but not
the same as being there.

   Much of this introduction is dedicated to walk-throughs or guided
tours of code used in GNU Emacs.  These tours are designed for two
purposes: first, to give you familiarity with real, working code (code
you use every day); and, second, to give you familiarity with the way
Emacs works.  It is interesting to see how a working environment is
implemented.  Also, I hope that you will pick up the habit of browsing
through source code.  You can learn from it and mine it for ideas.
Having GNU Emacs is like having a dragon's cave of treasures.

   In addition to learning about Emacs as an editor and Emacs Lisp as a
programming language, the examples and guided tours will give you an
opportunity to get acquainted with Emacs as a Lisp programming
environment.  GNU Emacs supports programming and provides tools that
you will want to become comfortable using, such as `M-.' (the key which
invokes the `find-tag' command).  You will also learn about buffers and
other objects that are part of the environment.  Learning about these
features of Emacs is like learning new routes around your home town.

   Finally, I hope to convey some of the skills for using Emacs to
learn aspects of programming that you don't know.  You can often use
Emacs to help you understand what puzzles you or to find out how to do
something new.  This self-reliance is not only a pleasure, but an
advantage.


File: emacs-lisp-intro.info,  Node: Who You Are,  Next: Lisp History,  Prev: On Reading this Text,  Up: Preface

For Whom This is Written
========================

   This text is written as an elementary introduction for people who are
not programmers.  If you are a programmer, you may not be satisfied with
this primer.  The reason is that you may have become expert at reading
reference manuals and be put off by the way this text is organized.

   An expert programmer who reviewed this text said to me:

     I prefer to learn from reference manuals.  I "dive into" each
     paragraph, and "come up for air" between paragraphs.

     When I get to the end of a paragraph, I assume that that subject is
     done, finished, that I know everything I need (with the possible
     exception of the case when the next paragraph starts talking about
     it in more detail).  I expect that a well written reference manual
     will not have a lot of redundancy, and that it will have excellent
     pointers to the (one) place where the information I want is.

   This introduction is not written for this person!

   Firstly, I try to say everything at least three times: first, to
introduce it; second, to show it in context; and third, to show it in a
different context, or to review it.

   Secondly, I hardly ever put all the information about a subject in
one place, much less in one paragraph.  To my way of thinking, that
imposes too heavy a burden on the reader.  Instead I try to explain
only what you need to know at the time.  (Sometimes I include a little
extra information so you won't be surprised later when the additional
information is formally introduced.)

   When you read this text, you are not expected to learn everything the
first time.  Frequently, you need only make, as it were, a `nodding
acquaintance' with some of the items mentioned.  My hope is that I have
structured the text and given you enough hints that you will be alert to
what is important, and concentrate on it.

   You will need to "dive into" some paragraphs; there is no other way
to read them.  But I have tried to keep down the number of such
paragraphs.  This book is intended as an approachable hill, rather than
as a daunting mountain.

   This introduction to `Programming in Emacs Lisp' has a companion
document, *Note The GNU Emacs Lisp Reference Manual: (elisp)Top.  The
reference manual has more detail than this introduction.  In the
reference manual, all the information about one topic is concentrated
in one place.  You should turn to it if you are like the programmer
quoted above.  And, of course, after you have read this `Introduction',
you will find the `Reference Manual' useful when you are writing your
own programs.


File: emacs-lisp-intro.info,  Node: Lisp History,  Next: Note for Novices,  Prev: Who You Are,  Up: Preface

Lisp History
============

   Lisp was first developed in the late 1950s at the Massachusetts
Institute of Technology for research in artificial intelligence.  The
great power of the Lisp language makes it superior for other purposes as
well, such as writing editor commands and integrated environments.

   GNU Emacs Lisp is largely inspired by Maclisp, which was written at
MIT in the 1960s.  It is somewhat inspired by Common Lisp, which became
a standard in the 1980s.  However, Emacs Lisp is much simpler than
Common Lisp.  (The standard Emacs distribution contains an optional
extensions file, `cl.el', that adds many Common Lisp features to Emacs
Lisp.)


File: emacs-lisp-intro.info,  Node: Note for Novices,  Next: Thank You,  Prev: Lisp History,  Up: Preface

A Note for Novices
==================

   If you don't know GNU Emacs, you can still read this document
profitably.  However, I recommend you learn Emacs, if only to learn to
move around your computer screen.  You can teach yourself how to use
Emacs with the on-line tutorial.  To use it, type `C-h t'.  (This means
you press and release the <CTRL> key and the `h' at the same time, and
then press and release `t'.)

   Also, I often refer to one of Emacs' standard commands by listing the
keys which you press to invoke the command and then giving the name of
the command in parentheses, like this: `M-C-\' (`indent-region').  What
this means is that the `indent-region' command is customarily invoked
by typing `M-C-\'.  (You can, if you wish, change the keys that are
typed to invoke the command; this is called "rebinding".  *Note
Keymaps: Keymaps.)  The abbreviation `M-C-\' means that you type your
<META> key, <CTRL> key and <\> key all at the same time.  (On many
modern keyboards the <META> key is labelled <ALT>.)  Sometimes a
combination like this is called a keychord, since it is similar to the
way you play a chord on a piano.  If your keyboard does not have a
<META> key, the <ESC> key prefix is used in place of it.  In this case,
`M-C-\' means that you press and release your <ESC> key and then type
the <CTRL> key and the <\> key at the same time.  But usually `M-C-\'
means press the <CTRL> key along with the key that is labelled <ALT>
and, at the same time, press the <\> key.

   In addition to typing a lone keychord, you can prefix what you type
with `C-u', which is called the `universal argument'.  The `C-u'
keychord passes an argument to the subsequent command.  Thus, to indent
a region of plain text by 6 spaces, mark the region, and then type
`C-u 6 M-C-\'.  (If you do not specify a number, Emacs either passes
the number 4 to the command or otherwise runs the command differently
than it would otherwise.)  *Note Numeric Arguments: (emacs)Arguments.

   If you are reading this in Info using GNU Emacs, you can read through
this whole document just by pressing the space bar, <SPC>.  (To learn
about Info, type `C-h i' and then select Info.)

   A note on terminology:  when I use the word Lisp alone, I often am
referring to the various dialects of Lisp in general, but when I speak
of Emacs Lisp, I am referring to GNU Emacs Lisp in particular.


File: emacs-lisp-intro.info,  Node: Thank You,  Prev: Note for Novices,  Up: Preface

Thank You
=========

   My thanks to all who helped me with this book.  My especial thanks to
Jim Blandy, Noah Friedman, Jim Kingdon, Roland McGrath, Frank Ritter,
Randy Smith, Richard M. Stallman, and Melissa Weisshaus.  My thanks
also go to both Philip Johnson and David Stampe for their patient
encouragement.  My mistakes are my own.

                                                     Robert J. Chassell


File: emacs-lisp-intro.info,  Node: List Processing,  Next: Practicing Evaluation,  Prev: Preface,  Up: Top

List Processing
***************

   To the untutored eye, Lisp is a strange programming language.  In
Lisp code there are parentheses everywhere.  Some people even claim
that the name stands for `Lots of Isolated Silly Parentheses'.  But the
claim is unwarranted.  Lisp stands for LISt Processing, and the
programming language handles _lists_ (and lists of lists) by putting
them between parentheses.  The parentheses mark the boundaries of the
list.  Sometimes a list is preceded by a single apostrophe or quotation
mark, `''.  Lists are the basis of Lisp.

* Menu:

* Lisp Lists::                  What are lists?
* Run a Program::               Any list in Lisp is a program ready to run.
* Making Errors::               Generating an error message.
* Names & Definitions::         Names of symbols and function definitions.
* Lisp Interpreter::            What the Lisp interpreter does.
* Evaluation::                  Running a program.
* Variables::                   Returning a value from a variable.
* Arguments::                   Passing information to a function.
* set & setq::                  Setting the value of a variable.
* Summary::                     The major points.
* Error Message Exercises::


File: emacs-lisp-intro.info,  Node: Lisp Lists,  Next: Run a Program,  Prev: List Processing,  Up: List Processing

Lisp Lists
==========

   In Lisp, a list looks like this: `'(rose violet daisy buttercup)'.
This list is preceded by a single apostrophe.  It could just as well be
written as follows, which looks more like the kind of list you are
likely to be familiar with:

     '(rose
       violet
       daisy
       buttercup)

The elements of this list are the names of the four different flowers,
separated from each other by whitespace and surrounded by parentheses,
like flowers in a field with a stone wall around them.

* Menu:

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formating lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.


File: emacs-lisp-intro.info,  Node: Numbers Lists,  Next: Lisp Atoms,  Prev: Lisp Lists,  Up: Lisp Lists

Numbers, Lists inside of Lists
------------------------------

   Lists can also have numbers in them, as in this list: `(+ 2 2)'.
This list has a plus-sign, `+', followed by two `2's, each separated by
whitespace.

   In Lisp, both data and programs are represented the same way; that
is, they are both lists of words, numbers, or other lists, separated by
whitespace and surrounded by parentheses.  (Since a program looks like
data, one program may easily serve as data for another; this is a very
powerful feature of Lisp.)  (Incidentally, these two parenthetical
remarks are _not_ Lisp lists, because they contain `;' and `.' as
punctuation marks.)

   Here is another list, this time with a list inside of it:

     '(this list has (a list inside of it))

   The components of this list are the words `this', `list', `has', and
the list `(a list inside of it)'.  The interior list is made up of the
words `a', `list', `inside', `of', `it'.


File: emacs-lisp-intro.info,  Node: Lisp Atoms,  Next: Whitespace in Lists,  Prev: Numbers Lists,  Up: Lisp Lists

Lisp Atoms
----------

   In Lisp, what we have been calling words are called "atoms".  This
term comes from the historical meaning of the word atom, which means
`indivisible'.  As far as Lisp is concerned, the words we have been
using in the lists cannot be divided into any smaller parts and still
mean the same thing as part of a program; likewise with numbers and
single character symbols like `+'.  On the other hand, unlike an atom,
a list can be split into parts.  (*Note `car' `cdr' & `cons'
Fundamental Functions: car cdr & cons.)

   In a list, atoms are separated from each other by whitespace.  They
can be right next to a parenthesis.

   Technically speaking, a list in Lisp consists of parentheses
surrounding atoms separated by whitespace or surrounding other lists or
surrounding both atoms and other lists.  A list can have just one atom
in it or have nothing in it at all.  A list with nothing in it looks
like this: `()', and is called the "empty list".  Unlike anything else,
an empty list is considered both an atom and a list at the same time.

   The printed representation of both atoms and lists are called
"symbolic expressions" or, more concisely, "s-expressions".  The word
"expression" by itself can refer to either the printed representation,
or to the atom or list as it is held internally in the computer.
Often, people use the term "expression" indiscriminately.  (Also, in
many texts, the word "form" is used as a synonym for expression.)

   Incidentally, the atoms that make up our universe were named such
when they were thought to be indivisible; but it has been found that
physical atoms are not indivisible.  Parts can split off an atom or it
can fission into two parts of roughly equal size.  Physical atoms were
named prematurely, before their truer nature was found.  In Lisp,
certain kinds of atom, such as an array, can be separated into parts;
but the mechanism for doing this is different from the mechanism for
splitting a list.  As far as list operations are concerned, the atoms
of a list are unsplittable.

   As in English, the meanings of the component letters of a Lisp atom
are different from the meaning the letters make as a word.  For
example, the word for the South American sloth, the `ai', is completely
different from the two words, `a', and `i'.

   There are many kinds of atom in nature but only a few in Lisp: for
example, "numbers", such as 37, 511, or 1729, and "symbols", such as
`+', `foo', or `forward-line'.  The words we have listed in the
examples above are all symbols.  In everyday Lisp conversation, the
word "atom" is not often used, because programmers usually try to be
more specific about what kind of atom they are dealing with.  Lisp
programming is mostly about symbols (and sometimes numbers) within
lists.  (Incidentally, the preceding three word parenthetical remark is
a proper list in Lisp, since it consists of atoms, which in this case
are symbols, separated by whitespace and enclosed by parentheses,
without any non-Lisp punctuation.)

   In addition, text between double quotation marks--even sentences or
paragraphs--is an atom.  Here is an example:

     '(this list includes "text between quotation marks.")

In Lisp, all of the quoted text including the punctuation mark and the
blank spaces is a single atom.  This kind of atom is called a "string"
(for `string of characters') and is the sort of thing that is used for
messages that a computer can print for a human to read.  Strings are a
different kind of atom than numbers or symbols and are used differently.


File: emacs-lisp-intro.info,  Node: Whitespace in Lists,  Next: Typing Lists,  Prev: Lisp Atoms,  Up: Lisp Lists

Whitespace in Lists
-------------------

   The amount of whitespace in a list does not matter.  From the point
of view of the Lisp language,

     '(this list
        looks like this)

is exactly the same as this:

     '(this list looks like this)

   Both examples show what to Lisp is the same list, the list made up of
the symbols `this', `list', `looks', `like', and `this' in that order.

   Extra whitespace and newlines are designed to make a list more
readable by humans.  When Lisp reads the expression, it gets rid of all
the extra whitespace (but it needs to have at least one space between
atoms in order to tell them apart.)

   Odd as it seems, the examples we have seen cover almost all of what
Lisp lists look like!  Every other list in Lisp looks more or less like
one of these examples, except that the list may be longer and more
complex.  In brief, a list is between parentheses, a string is between
quotation marks, a symbol looks like a word, and a number looks like a
number.  (For certain situations, square brackets, dots and a few other
special characters may be used; however, we will go quite far without
them.)


File: emacs-lisp-intro.info,  Node: Typing Lists,  Prev: Whitespace in Lists,  Up: Lisp Lists

GNU Emacs Helps You Type Lists
------------------------------

   When you type a Lisp expression in GNU Emacs using either Lisp
Interaction mode or Emacs Lisp mode, you have available to you several
commands to format the Lisp expression so it is easy to read.  For
example, pressing the <TAB> key automatically indents the line the
cursor is on by the right amount.  A command to properly indent the
code in a region is customarily bound to `M-C-\'.  Indentation is
designed so that you can see which elements of a list belongs to which
list--elements of a sub-list are indented more than the elements of the
enclosing list.

   In addition, when you type a closing parenthesis, Emacs momentarily
jumps the cursor back to the matching opening parenthesis, so you can
see which one it is.  This is very useful, since every list you type in
Lisp must have its closing parenthesis match its opening parenthesis.
(*Note Major Modes: (emacs)Major Modes, for more information about
Emacs' modes.)


File: emacs-lisp-intro.info,  Node: Run a Program,  Next: Making Errors,  Prev: Lisp Lists,  Up: List Processing

Run a Program
=============

   A list in Lisp--any list--is a program ready to run.  If you run it
(for which the Lisp jargon is "evaluate"), the computer will do one of
three things: do nothing except return to you the list itself; send you
an error message; or, treat the first symbol in the list as a command
to do something.  (Usually, of course, it is the last of these three
things that you really want!)

   The single apostrophe, `'', that I put in front of some of the
example lists in preceding sections is called a "quote"; when it
precedes a list, it tells Lisp to do nothing with the list, other than
take it as it is written.  But if there is no quote preceding a list,
the first item of the list is special: it is a command for the computer
to obey.  (In Lisp, these commands are called _functions_.)  The list
`(+ 2 2)' shown above did not have a quote in front of it, so Lisp
understands that the `+' is an instruction to do something with the
rest of the list: add the numbers that follow.

   If you are reading this inside of GNU Emacs in Info, here is how you
can evaluate such a list:  place your cursor immediately after the right
hand parenthesis of the following list and then type `C-x C-e':

     (+ 2 2)

You will see the number `4' appear in the echo area.  (In the jargon,
what you have just done is "evaluate the list."  The echo area is the
line at the bottom of the screen that displays or "echoes" text.)  Now
try the same thing with a quoted list:  place the cursor right after
the following list and type `C-x C-e':

     '(this is a quoted list)

You will see `(this is a quoted list)' appear in the echo area.

   In both cases, what you are doing is giving a command to the program
inside of GNU Emacs called the "Lisp interpreter"--giving the
interpreter a command to evaluate the expression.  The name of the Lisp
interpreter comes from the word for the task done by a human who comes
up with the meaning of an expression--who "interprets" it.

   You can also evaluate an atom that is not part of a list--one that is
not surrounded by parentheses; again, the Lisp interpreter translates
from the humanly readable expression to the language of the computer.
But before discussing this (*note Variables::), we will discuss what the
Lisp interpreter does when you make an error.


File: emacs-lisp-intro.info,  Node: Making Errors,  Next: Names & Definitions,  Prev: Run a Program,  Up: List Processing

Generate an Error Message
=========================

   Partly so you won't worry if you do it accidentally, we will now give
a command to the Lisp interpreter that generates an error message.
This is a harmless activity; and indeed, we will often try to generate
error messages intentionally.  Once you understand the jargon, error
messages can be informative.  Instead of being called "error" messages,
they should be called "help" messages.  They are like signposts to a
traveller in a strange country; deciphering them can be hard, but once
understood, they can point the way.

   The error message is generated by a built-in GNU Emacs debugger.  We
will `enter the debugger'.  You get out of the debugger by typing `q'.

   What we will do is evaluate a list that is not quoted and does not
have a meaningful command as its first element.  Here is a list almost
exactly the same as the one we just used, but without the single-quote
in front of it.  Position the cursor right after it and type `C-x C-e':

     (this is an unquoted list)

What you see depends on which version of Emacs you are running.  GNU
Emacs version 21 provides more information than version 20 and before.
First, the more recent result of generating an error; then the earlier,
version 20 result.

In GNU Emacs version 21, a `*Backtrace*' window will open up and you
will see the following in it:

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function this)
       (this is an unquoted list)
       eval((this is an unquoted list))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

Your cursor will be in this window (you may have to wait a few seconds
before it becomes visible).  To quit the debugger and make the debugger
window go away, type:

     q

Please type `q' right now, so you become confident that you can get out
of the debugger.  Then, type `C-x C-e' again to re-enter it.

   Based on what we already know, we can almost read this error message.

   You read the `*Backtrace*' buffer from the bottom up; it tells you
what Emacs did.  When you typed `C-x C-e', you made an interactive call
to the command `eval-last-sexp'.  `eval' is an abbreviation for
`evaluate' and `sexp' is an abbreviation for `symbolic expression'.
The command means `evaluate last symbolic expression', which is the
expression just before your cursor.

   Each line above tells you what the Lisp interpreter evaluated next.
The most recent action is at the top.  The buffer is called the
`*Backtrace*' buffer because it enables you to track Emacs backwards.

   At the top of the `*Backtrace*' buffer, you see the line:

     Debugger entered--Lisp error: (void-function this)

The Lisp interpreter tried to evaluate the first atom of the list, the
word `this'.  It is this action that generated the error message
`void-function this'.

   The message contains the words `void-function' and `this'.

   The word `function' was mentioned once before.  It is a very
important word.  For our purposes, we can define it by saying that a
"function" is a set of instructions to the computer that tell the
computer to do something.

   Now we can begin to understand the error message: `void-function
this'.  The function (that is, the word `this') does not have a
definition of any set of instructions for the computer to carry out.

   The slightly odd word, `void-function', is designed to cover the way
Emacs Lisp is implemented, which is that when a symbol does not have a
function definition attached to it, the place that should contain the
instructions is `void'.

   On the other hand, since we were able to add 2 plus 2 successfully,
by evaluating `(+ 2 2)', we can infer that the symbol `+' must have a
set of instructions for the computer to obey and those instructions
must be to add the numbers that follow the `+'.

   In GNU Emacs version 20, and in earlier versions, you will see only
one line of error message; it will appear in the echo area and look
like this:

     Symbol's function definition is void: this

(Also, your terminal may beep at you--some do, some don't; and others
blink.  This is just a device to get your attention.)  The message goes
away as soon as you type another key, even just to move the cursor.

   We know the meaning of the word `Symbol'.  It refers to the first
atom of the list, the word `this'.  The word `function' refers to the
instructions that tell the computer what to do.  (Technically, the
symbol tells the computer where to find the instructions, but this is a
complication we can ignore for the moment.)

   The error message can be understood: `Symbol's function definition
is void: this'.  The symbol (that is, the word `this') lacks
instructions for the computer to carry out.


File: emacs-lisp-intro.info,  Node: Names & Definitions,  Next: Lisp Interpreter,  Prev: Making Errors,  Up: List Processing

Symbol Names and Function Definitions
=====================================

   We can articulate another characteristic of Lisp based on what we
have discussed so far--an important characteristic: a symbol, like `+',
is not itself the set of instructions for the computer to carry out.
Instead, the symbol is used, perhaps temporarily, as a way of locating
the definition or set of instructions.  What we see is the name through
which the instructions can be found.  Names of people work the same
way.  I can be referred to as `Bob'; however, I am not the letters `B',
`o', `b' but am the consciousness consistently associated with a
particular life-form.  The name is not me, but it can be used to refer
to me.

   In Lisp, one set of instructions can be attached to several names.
For example, the computer instructions for adding numbers can be linked
to the symbol `plus' as well as to the symbol `+' (and are in some
dialects of Lisp).  Among humans, I can be referred to as `Robert' as
well as `Bob' and by other words as well.

   On the other hand, a symbol can have only one function definition
attached to it at a time.  Otherwise, the computer would be confused as
to which definition to use.  If this were the case among people, only
one person in the world could be named `Bob'.  However, the function
definition to which the name refers can be changed readily.  (*Note
Install a Function Definition: Install.)

   Since Emacs Lisp is large, it is customary to name symbols in a way
that identifies the part of Emacs to which the function belongs.  Thus,
all the names for functions that deal with Texinfo start with
`texinfo-' and those for functions that deal with reading mail start
with `rmail-'.


File: emacs-lisp-intro.info,  Node: Lisp Interpreter,  Next: Evaluation,  Prev: Names & Definitions,  Up: List Processing

The Lisp Interpreter
====================

   Based on what we have seen, we can now start to figure out what the
Lisp interpreter does when we command it to evaluate a list.  First, it
looks to see whether there is a quote before the list; if there is, the
interpreter just gives us the list.  On the other hand, if there is no
quote, the interpreter looks at the first element in the list and sees
whether it has a function definition.  If it does, the interpreter
carries out the instructions in the function definition.  Otherwise,
the interpreter prints an error message.

   This is how Lisp works.  Simple.  There are added complications
which we will get to in a minute, but these are the fundamentals.  Of
course, to write Lisp programs, you need to know how to write function
definitions and attach them to names, and how to do this without
confusing either yourself or the computer.

* Menu:

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.

