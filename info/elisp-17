This is elisp, produced by makeinfo version 4.0f from ./elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This Info file contains edition 2.8 of the GNU Emacs Lisp Reference
Manual, corresponding to Emacs version 21.2.

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
2000, 2001, 2002 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Copying", with the Front-Cover texts being "A
GNU Manual", and with the Back-Cover Texts as in (a) below.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: elisp,  Node: Reading a Password,  Next: Minibuffer Misc,  Prev: Multiple Queries,  Up: Minibuffers

Reading a Password
==================

   To read a password to pass to another program, you can use the
function `read-passwd'.

 - Function: read-passwd prompt &optional confirm default
     This function reads a password, prompting with PROMPT.  It does
     not echo the password as the user types it; instead, it echoes `.'
     for each character in the password.

     The optional argument CONFIRM, if non-`nil', says to read the
     password twice and insist it must be the same both times.  If it
     isn't the same, the user has to type it over and over until the
     last two times match.

     The optional argument DEFAULT specifies the default password to
     return if the user enters empty input.  If DEFAULT is `nil', then
     `read-passwd' returns the null string in that case.


File: elisp,  Node: Minibuffer Misc,  Prev: Reading a Password,  Up: Minibuffers

Minibuffer Miscellany
=====================

   This section describes some basic functions and variables related to
minibuffers.

 - Command: exit-minibuffer
     This command exits the active minibuffer.  It is normally bound to
     keys in minibuffer local keymaps.

 - Command: self-insert-and-exit
     This command exits the active minibuffer after inserting the last
     character typed on the keyboard (found in `last-command-char';
     *note Command Loop Info::).

 - Command: previous-history-element n
     This command replaces the minibuffer contents with the value of the
     Nth previous (older) history element.

 - Command: next-history-element n
     This command replaces the minibuffer contents with the value of the
     Nth more recent history element.

 - Command: previous-matching-history-element pattern n
     This command replaces the minibuffer contents with the value of the
     Nth previous (older) history element that matches PATTERN (a
     regular expression).

 - Command: next-matching-history-element pattern n
     This command replaces the minibuffer contents with the value of the
     Nth next (newer) history element that matches PATTERN (a regular
     expression).

 - Function: minibuffer-prompt
     This function returns the prompt string of the currently active
     minibuffer.  If no minibuffer is active, it returns `nil'.

 - Function: minibuffer-prompt-end
     This function, available starting in Emacs 21, returns the current
     position of the end of the minibuffer prompt, if a minibuffer is
     current.  Otherwise, it returns the minimum valid buffer position.

 - Function: minibuffer-contents
     This function, available starting in Emacs 21, returns the editable
     contents of the minibuffer (that is, everything except the prompt)
     as a string, if a minibuffer is current.  Otherwise, it returns the
     entire contents of the current buffer.

 - Function: minibuffer-contents-no-properties
     This is like `minibuffer-contents', except that it does not copy
     text properties, just the characters themselves.  *Note Text
     Properties::.

 - Function: delete-minibuffer-contents
     This function, available starting in Emacs 21, erases the editable
     contents of the minibuffer (that is, everything except the
     prompt), if a minibuffer is current.  Otherwise, it erases the
     entire buffer.

 - Function: minubuffer-prompt-width
     This function returns the current display-width of the minibuffer
     prompt, if a minibuffer is current.  Otherwise, it returns zero.

 - Variable: minibuffer-setup-hook
     This is a normal hook that is run whenever the minibuffer is
     entered.  *Note Hooks::.

 - Variable: minibuffer-exit-hook
     This is a normal hook that is run whenever the minibuffer is
     exited.  *Note Hooks::.

 - Variable: minibuffer-help-form
     The current value of this variable is used to rebind `help-form'
     locally inside the minibuffer (*note Help Functions::).

 - Function: active-minibuffer-window
     This function returns the currently active minibuffer window, or
     `nil' if none is currently active.

 - Function: minibuffer-window &optional frame
     This function returns the minibuffer window used for frame FRAME.
     If FRAME is `nil', that stands for the current frame.  Note that
     the minibuffer window used by a frame need not be part of that
     frame--a frame that has no minibuffer of its own necessarily uses
     some other frame's minibuffer window.

 - Function: window-minibuffer-p window
     This function returns non-`nil' if WINDOW is a minibuffer window.

   It is not correct to determine whether a given window is a
minibuffer by comparing it with the result of `(minibuffer-window)',
because there can be more than one minibuffer window if there is more
than one frame.

 - Function: minibuffer-window-active-p window
     This function returns non-`nil' if WINDOW, assumed to be a
     minibuffer window, is currently active.

 - Variable: minibuffer-scroll-window
     If the value of this variable is non-`nil', it should be a window
     object.  When the function `scroll-other-window' is called in the
     minibuffer, it scrolls this window.

   Finally, some functions and variables deal with recursive minibuffers
(*note Recursive Editing::):

 - Function: minibuffer-depth
     This function returns the current depth of activations of the
     minibuffer, a nonnegative integer.  If no minibuffers are active,
     it returns zero.

 - User Option: enable-recursive-minibuffers
     If this variable is non-`nil', you can invoke commands (such as
     `find-file') that use minibuffers even while the minibuffer window
     is active.  Such invocation produces a recursive editing level for
     a new minibuffer.  The outer-level minibuffer is invisible while
     you are editing the inner one.

     If this variable is `nil', you cannot invoke minibuffer commands
     when the minibuffer window is active, not even if you switch to
     another window to do it.

   If a command name has a property `enable-recursive-minibuffers' that
is non-`nil', then the command can use the minibuffer to read arguments
even if it is invoked from the minibuffer.  The minibuffer command
`next-matching-history-element' (normally `M-s' in the minibuffer) uses
this feature.


File: elisp,  Node: Command Loop,  Next: Keymaps,  Prev: Minibuffers,  Up: Top

Command Loop
************

   When you run Emacs, it enters the "editor command loop" almost
immediately.  This loop reads key sequences, executes their definitions,
and displays the results.  In this chapter, we describe how these things
are done, and the subroutines that allow Lisp programs to do them.

* Menu:

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Adjusting Point::     Adjustment of point after a command.
* Input Events::	What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Special Events::      Events processed immediately and individually.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How C-g works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn't.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.


File: elisp,  Node: Command Overview,  Next: Defining Commands,  Up: Command Loop

Command Loop Overview
=====================

   The first thing the command loop must do is read a key sequence,
which is a sequence of events that translates into a command.  It does
this by calling the function `read-key-sequence'.  Your Lisp code can
also call this function (*note Key Sequence Input::).  Lisp programs
can also do input at a lower level with `read-event' (*note Reading One
Event::) or discard pending input with `discard-input' (*note Event
Input Misc::).

   The key sequence is translated into a command through the currently
active keymaps.  *Note Key Lookup::, for information on how this is
done.  The result should be a keyboard macro or an interactively
callable function.  If the key is `M-x', then it reads the name of
another command, which it then calls.  This is done by the command
`execute-extended-command' (*note Interactive Call::).

   To execute a command requires first reading the arguments for it.
This is done by calling `command-execute' (*note Interactive Call::).
For commands written in Lisp, the `interactive' specification says how
to read the arguments.  This may use the prefix argument (*note Prefix
Command Arguments::) or may read with prompting in the minibuffer
(*note Minibuffers::).  For example, the command `find-file' has an
`interactive' specification which says to read a file name using the
minibuffer.  The command's function body does not use the minibuffer;
if you call this command from Lisp code as a function, you must supply
the file name string as an ordinary Lisp function argument.

   If the command is a string or vector (i.e., a keyboard macro) then
`execute-kbd-macro' is used to execute it.  You can call this function
yourself (*note Keyboard Macros::).

   To terminate the execution of a running command, type `C-g'.  This
character causes "quitting" (*note Quitting::).

 - Variable: pre-command-hook
     The editor command loop runs this normal hook before each command.
     At that time, `this-command' contains the command that is about to
     run, and `last-command' describes the previous command.  *Note
     Hooks::.

 - Variable: post-command-hook
     The editor command loop runs this normal hook after each command
     (including commands terminated prematurely by quitting or by
     errors), and also when the command loop is first entered.  At that
     time, `this-command' describes the command that just ran, and
     `last-command' describes the command before that.  *Note Hooks::.

   Quitting is suppressed while running `pre-command-hook' and
`post-command-hook'.  If an error happens while executing one of these
hooks, it terminates execution of the hook, and clears the hook
variable to `nil' so as to prevent an infinite loop of errors.


File: elisp,  Node: Defining Commands,  Next: Interactive Call,  Prev: Command Overview,  Up: Command Loop

Defining Commands
=================

   A Lisp function becomes a command when its body contains, at top
level, a form that calls the special form `interactive'.  This form
does nothing when actually executed, but its presence serves as a flag
to indicate that interactive calling is permitted.  Its argument
controls the reading of arguments for an interactive call.

* Menu:

* Using Interactive::     General rules for `interactive'.
* Interactive Codes::     The standard letter-codes for reading arguments
                             in various ways.
* Interactive Examples::  Examples of how to read interactive arguments.


File: elisp,  Node: Using Interactive,  Next: Interactive Codes,  Up: Defining Commands

Using `interactive'
-------------------

   This section describes how to write the `interactive' form that
makes a Lisp function an interactively-callable command, and how to
examine a commands's `interactive' form.

 - Special Form: interactive arg-descriptor
     This special form declares that the function in which it appears
     is a command, and that it may therefore be called interactively
     (via `M-x' or by entering a key sequence bound to it).  The
     argument ARG-DESCRIPTOR declares how to compute the arguments to
     the command when the command is called interactively.

     A command may be called from Lisp programs like any other
     function, but then the caller supplies the arguments and
     ARG-DESCRIPTOR has no effect.

     The `interactive' form has its effect because the command loop
     (actually, its subroutine `call-interactively') scans through the
     function definition looking for it, before calling the function.
     Once the function is called, all its body forms including the
     `interactive' form are executed, but at this time `interactive'
     simply returns `nil' without even evaluating its argument.

   There are three possibilities for the argument ARG-DESCRIPTOR:

   * It may be omitted or `nil'; then the command is called with no
     arguments.  This leads quickly to an error if the command requires
     one or more arguments.

   * It may be a Lisp expression that is not a string; then it should
     be a form that is evaluated to get a list of arguments to pass to
     the command.

     If this expression reads keyboard input (this includes using the
     minibuffer), keep in mind that the integer value of point or the
     mark before reading input may be incorrect after reading input.
     This is because the current buffer may be receiving subprocess
     output; if subprocess output arrives while the command is waiting
     for input, it could relocate point and the mark.

     Here's an example of what _not_ to do:

          (interactive
           (list (region-beginning) (region-end)
                 (read-string "Foo: " nil 'my-history)))

     Here's how to avoid the problem, by examining point and the mark
     only after reading the keyboard input:

          (interactive
           (let ((string (read-string "Foo: " nil 'my-history)))
             (list (region-beginning) (region-end) string)))

   * It may be a string; then its contents should consist of a code
     character followed by a prompt (which some code characters use and
     some ignore).  The prompt ends either with the end of the string
     or with a newline.  Here is a simple example:

          (interactive "bFrobnicate buffer: ")

     The code letter `b' says to read the name of an existing buffer,
     with completion.  The buffer name is the sole argument passed to
     the command.  The rest of the string is a prompt.

     If there is a newline character in the string, it terminates the
     prompt.  If the string does not end there, then the rest of the
     string should contain another code character and prompt,
     specifying another argument.  You can specify any number of
     arguments in this way.

     The prompt string can use `%' to include previous argument values
     (starting with the first argument) in the prompt.  This is done
     using `format' (*note Formatting Strings::).  For example, here is
     how you could read the name of an existing buffer followed by a
     new name to give to that buffer:

          (interactive "bBuffer to rename: \nsRename buffer %s to: ")

     If the first character in the string is `*', then an error is
     signaled if the buffer is read-only.

     If the first character in the string is `@', and if the key
     sequence used to invoke the command includes any mouse events, then
     the window associated with the first of those events is selected
     before the command is run.

     You can use `*' and `@' together; the order does not matter.
     Actual reading of arguments is controlled by the rest of the prompt
     string (starting with the first character that is not `*' or `@').

 - Function: interactive-form function
     This function returns the `interactive' form of FUNCTION.  If
     FUNCTION is a command (*note Interactive Call::), the value is a
     list of the form `(interactive SPEC)', where SPEC is the
     descriptor specification used by the command's `interactive' form
     to compute the function's arguments (*note Using Interactive::).
     If FUNCTION is not a command, `interactive-form' returns `nil'.


File: elisp,  Node: Interactive Codes,  Next: Interactive Examples,  Prev: Using Interactive,  Up: Defining Commands

Code Characters for `interactive'
---------------------------------

   The code character descriptions below contain a number of key words,
defined here as follows:

Completion
     Provide completion.  <TAB>, <SPC>, and <RET> perform name
     completion because the argument is read using `completing-read'
     (*note Completion::).  `?' displays a list of possible completions.

Existing
     Require the name of an existing object.  An invalid name is not
     accepted; the commands to exit the minibuffer do not exit if the
     current input is not valid.

Default
     A default value of some sort is used if the user enters no text in
     the minibuffer.  The default depends on the code character.

No I/O
     This code letter computes an argument without reading any input.
     Therefore, it does not use a prompt string, and any prompt string
     you supply is ignored.

     Even though the code letter doesn't use a prompt string, you must
     follow it with a newline if it is not the last code character in
     the string.

Prompt
     A prompt immediately follows the code character.  The prompt ends
     either with the end of the string or with a newline.

Special
     This code character is meaningful only at the beginning of the
     interactive string, and it does not look for a prompt or a newline.
     It is a single, isolated character.

   Here are the code character descriptions for use with `interactive':

`*'
     Signal an error if the current buffer is read-only.  Special.

`@'
     Select the window mentioned in the first mouse event in the key
     sequence that invoked this command.  Special.

`a'
     A function name (i.e., a symbol satisfying `fboundp').  Existing,
     Completion, Prompt.

`b'
     The name of an existing buffer.  By default, uses the name of the
     current buffer (*note Buffers::).  Existing, Completion, Default,
     Prompt.

`B'
     A buffer name.  The buffer need not exist.  By default, uses the
     name of a recently used buffer other than the current buffer.
     Completion, Default, Prompt.

`c'
     A character.  The cursor does not move into the echo area.  Prompt.

`C'
     A command name (i.e., a symbol satisfying `commandp').  Existing,
     Completion, Prompt.

`d'
     The position of point, as an integer (*note Point::).  No I/O.

`D'
     A directory name.  The default is the current default directory of
     the current buffer, `default-directory' (*note System
     Environment::).  Existing, Completion, Default, Prompt.

`e'
     The first or next mouse event in the key sequence that invoked the
     command.  More precisely, `e' gets events that are lists, so you
     can look at the data in the lists.  *Note Input Events::.  No I/O.

     You can use `e' more than once in a single command's interactive
     specification.  If the key sequence that invoked the command has N
     events that are lists, the Nth `e' provides the Nth such event.
     Events that are not lists, such as function keys and ASCII
     characters, do not count where `e' is concerned.

`f'
     A file name of an existing file (*note File Names::).  The default
     directory is `default-directory'.  Existing, Completion, Default,
     Prompt.

`F'
     A file name.  The file need not exist.  Completion, Default,
     Prompt.

`i'
     An irrelevant argument.  This code always supplies `nil' as the
     argument's value.  No I/O.

`k'
     A key sequence (*note Keymap Terminology::).  This keeps reading
     events until a command (or undefined command) is found in the
     current key maps.  The key sequence argument is represented as a
     string or vector.  The cursor does not move into the echo area.
     Prompt.

     This kind of input is used by commands such as `describe-key' and
     `global-set-key'.

`K'
     A key sequence, whose definition you intend to change.  This works
     like `k', except that it suppresses, for the last input event in
     the key sequence, the conversions that are normally used (when
     necessary) to convert an undefined key into a defined one.

`m'
     The position of the mark, as an integer.  No I/O.

`M'
     Arbitrary text, read in the minibuffer using the current buffer's
     input method, and returned as a string (*note Input Methods:
     (emacs)Input Methods.).  Prompt.

`n'
     A number read with the minibuffer.  If the input is not a number,
     the user is asked to try again.  The prefix argument, if any, is
     not used.  Prompt.

`N'
     The numeric prefix argument; but if there is no prefix argument,
     read a number as with `n'.  Requires a number.  *Note Prefix
     Command Arguments::.  Prompt.

`p'
     The numeric prefix argument.  (Note that this `p' is lower case.)
     No I/O.

`P'
     The raw prefix argument.  (Note that this `P' is upper case.)  No
     I/O.

`r'
     Point and the mark, as two numeric arguments, smallest first.
     This is the only code letter that specifies two successive
     arguments rather than one.  No I/O.

`s'
     Arbitrary text, read in the minibuffer and returned as a string
     (*note Text from Minibuffer::).  Terminate the input with either
     `C-j' or <RET>.  (`C-q' may be used to include either of these
     characters in the input.)  Prompt.

`S'
     An interned symbol whose name is read in the minibuffer.  Any
     whitespace character terminates the input.  (Use `C-q' to include
     whitespace in the string.)  Other characters that normally
     terminate a symbol (e.g., parentheses and brackets) do not do so
     here.  Prompt.

`v'
     A variable declared to be a user option (i.e., satisfying the
     predicate `user-variable-p').  *Note High-Level Completion::.
     Existing, Completion, Prompt.

`x'
     A Lisp object, specified with its read syntax, terminated with a
     `C-j' or <RET>.  The object is not evaluated.  *Note Object from
     Minibuffer::.  Prompt.

`X'
     A Lisp form is read as with `x', but then evaluated so that its
     value becomes the argument for the command.  Prompt.

`z'
     A coding system name (a symbol).  If the user enters null input,
     the argument value is `nil'.  *Note Coding Systems::.  Completion,
     Existing, Prompt.

`Z'
     A coding system name (a symbol)--but only if this command has a
     prefix argument.  With no prefix argument, `Z' provides `nil' as
     the argument value.  Completion, Existing, Prompt.


File: elisp,  Node: Interactive Examples,  Prev: Interactive Codes,  Up: Defining Commands

Examples of Using `interactive'
-------------------------------

   Here are some examples of `interactive':

     (defun foo1 ()              ; `foo1' takes no arguments,
         (interactive)           ;   just moves forward two words.
         (forward-word 2))
          => foo1
     
     (defun foo2 (n)             ; `foo2' takes one argument,
         (interactive "p")       ;   which is the numeric prefix.
         (forward-word (* 2 n)))
          => foo2
     
     (defun foo3 (n)             ; `foo3' takes one argument,
         (interactive "nCount:") ;   which is read with the Minibuffer.
         (forward-word (* 2 n)))
          => foo3
     
     (defun three-b (b1 b2 b3)
       "Select three existing buffers.
     Put them into three windows, selecting the last one."
         (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
         (delete-other-windows)
         (split-window (selected-window) 8)
         (switch-to-buffer b1)
         (other-window 1)
         (split-window (selected-window) 8)
         (switch-to-buffer b2)
         (other-window 1)
         (switch-to-buffer b3))
          => three-b
     (three-b "*scratch*" "declarations.texi" "*mail*")
          => nil


File: elisp,  Node: Interactive Call,  Next: Command Loop Info,  Prev: Defining Commands,  Up: Command Loop

Interactive Call
================

   After the command loop has translated a key sequence into a command
it invokes that command using the function `command-execute'.  If the
command is a function, `command-execute' calls `call-interactively',
which reads the arguments and calls the command.  You can also call
these functions yourself.

 - Function: commandp object
     Returns `t' if OBJECT is suitable for calling interactively; that
     is, if OBJECT is a command.  Otherwise, returns `nil'.

     The interactively callable objects include strings and vectors
     (treated as keyboard macros), lambda expressions that contain a
     top-level call to `interactive', byte-code function objects made
     from such lambda expressions, autoload objects that are declared
     as interactive (non-`nil' fourth argument to `autoload'), and some
     of the primitive functions.

     A symbol satisfies `commandp' if its function definition satisfies
     `commandp'.

     Keys and keymaps are not commands.  Rather, they are used to look
     up commands (*note Keymaps::).

     See `documentation' in *Note Accessing Documentation::, for a
     realistic example of using `commandp'.

 - Function: call-interactively command &optional record-flag keys
     This function calls the interactively callable function COMMAND,
     reading arguments according to its interactive calling
     specifications.  An error is signaled if COMMAND is not a function
     or if it cannot be called interactively (i.e., is not a command).
     Note that keyboard macros (strings and vectors) are not accepted,
     even though they are considered commands, because they are not
     functions.

     If RECORD-FLAG is non-`nil', then this command and its arguments
     are unconditionally added to the list `command-history'.
     Otherwise, the command is added only if it uses the minibuffer to
     read an argument.  *Note Command History::.

     The argument KEYS, if given, specifies the sequence of events to
     supply if the command inquires which events were used to invoke it.

 - Function: command-execute command &optional record-flag keys special
     This function executes COMMAND.  The argument COMMAND must satisfy
     the `commandp' predicate; i.e., it must be an interactively
     callable function or a keyboard macro.

     A string or vector as COMMAND is executed with
     `execute-kbd-macro'.  A function is passed to
     `call-interactively', along with the optional RECORD-FLAG.

     A symbol is handled by using its function definition in its place.
     A symbol with an `autoload' definition counts as a command if it
     was declared to stand for an interactively callable function.
     Such a definition is handled by loading the specified library and
     then rechecking the definition of the symbol.

     The argument KEYS, if given, specifies the sequence of events to
     supply if the command inquires which events were used to invoke it.

     The argument SPECIAL, if given, means to ignore the prefix
     argument and not clear it.  This is used for executing special
     events (*note Special Events::).

 - Command: execute-extended-command prefix-argument
     This function reads a command name from the minibuffer using
     `completing-read' (*note Completion::).  Then it uses
     `command-execute' to call the specified command.  Whatever that
     command returns becomes the value of `execute-extended-command'.

     If the command asks for a prefix argument, it receives the value
     PREFIX-ARGUMENT.  If `execute-extended-command' is called
     interactively, the current raw prefix argument is used for
     PREFIX-ARGUMENT, and thus passed on to whatever command is run.

     `execute-extended-command' is the normal definition of `M-x', so
     it uses the string `M-x ' as a prompt.  (It would be better to
     take the prompt from the events used to invoke
     `execute-extended-command', but that is painful to implement.)  A
     description of the value of the prefix argument, if any, also
     becomes part of the prompt.

          (execute-extended-command 1)
          ---------- Buffer: Minibuffer ----------
          1 M-x forward-word RET
          ---------- Buffer: Minibuffer ----------
               => t

 - Function: interactive-p
     This function returns `t' if the containing function (the one whose
     code includes the call to `interactive-p') was called
     interactively, with the function `call-interactively'.  (It makes
     no difference whether `call-interactively' was called from Lisp or
     directly from the editor command loop.)  If the containing
     function was called by Lisp evaluation (or with `apply' or
     `funcall'), then it was not called interactively.

   The most common use of `interactive-p' is for deciding whether to
print an informative message.  As a special exception, `interactive-p'
returns `nil' whenever a keyboard macro is being run.  This is to
suppress the informative messages and speed execution of the macro.

   For example:

     (defun foo ()
       (interactive)
       (when (interactive-p)
         (message "foo")))
          => foo
     
     (defun bar ()
       (interactive)
       (setq foobar (list (foo) (interactive-p))))
          => bar
     
     ;; Type `M-x foo'.
          -| foo
     
     ;; Type `M-x bar'.
     ;; This does not print anything.
     
     foobar
          => (nil t)

   The other way to do this sort of job is to make the command take an
argument `print-message' which should be non-`nil' in an interactive
call, and use the `interactive' spec to make sure it is non-`nil'.
Here's how:

     (defun foo (&optional print-message)
       (interactive "p")
       (when print-message
         (message "foo")))

   The numeric prefix argument, provided by `p', is never `nil'.


File: elisp,  Node: Command Loop Info,  Next: Adjusting Point,  Prev: Interactive Call,  Up: Command Loop

Information from the Command Loop
=================================

   The editor command loop sets several Lisp variables to keep status
records for itself and for commands that are run.

 - Variable: last-command
     This variable records the name of the previous command executed by
     the command loop (the one before the current command).  Normally
     the value is a symbol with a function definition, but this is not
     guaranteed.

     The value is copied from `this-command' when a command returns to
     the command loop, except when the command has specified a prefix
     argument for the following command.

     This variable is always local to the current terminal and cannot be
     buffer-local.  *Note Multiple Displays::.

 - Variable: real-last-command
     This variable is set up by Emacs just like `last-command', but
     never altered by Lisp programs.

 - Variable: this-command
     This variable records the name of the command now being executed by
     the editor command loop.  Like `last-command', it is normally a
     symbol with a function definition.

     The command loop sets this variable just before running a command,
     and copies its value into `last-command' when the command finishes
     (unless the command specified a prefix argument for the following
     command).

     Some commands set this variable during their execution, as a flag
     for whatever command runs next.  In particular, the functions for
     killing text set `this-command' to `kill-region' so that any kill
     commands immediately following will know to append the killed text
     to the previous kill.

   If you do not want a particular command to be recognized as the
previous command in the case where it got an error, you must code that
command to prevent this.  One way is to set `this-command' to `t' at the
beginning of the command, and set `this-command' back to its proper
value at the end, like this:

     (defun foo (args...)
       (interactive ...)
       (let ((old-this-command this-command))
         (setq this-command t)
         ...do the work...
         (setq this-command old-this-command)))

We do not bind `this-command' with `let' because that would restore the
old value in case of error--a feature of `let' which in this case does
precisely what we want to avoid.

 - Function: this-command-keys
     This function returns a string or vector containing the key
     sequence that invoked the present command, plus any previous
     commands that generated the prefix argument for this command.  The
     value is a string if all those events were characters.  *Note
     Input Events::.

          (this-command-keys)
          ;; Now use `C-u C-x C-e' to evaluate that.
               => "^U^X^E"

 - Function: this-command-keys-vector
     Like `this-command-keys', except that it always returns the events
     in a vector, so you don't need to deal with the complexities of
     storing input events in a string (*note Strings of Events::).

 - Function: clear-this-command-keys
     This function empties out the table of events for
     `this-command-keys' to return, and also empties the records that
     the function `recent-keys' (*note Recording Input::) will
     subsequently return.  This is useful after reading a password, to
     prevent the password from echoing inadvertently as part of the next
     command in certain cases.

 - Variable: last-nonmenu-event
     This variable holds the last input event read as part of a key
     sequence, not counting events resulting from mouse menus.

     One use of this variable is for telling `x-popup-menu' where to pop
     up a menu.  It is also used internally by `y-or-n-p' (*note
     Yes-or-No Queries::).

 - Variable: last-command-event
 - Variable: last-command-char
     This variable is set to the last input event that was read by the
     command loop as part of a command.  The principal use of this
     variable is in `self-insert-command', which uses it to decide which
     character to insert.

          last-command-event
          ;; Now use `C-u C-x C-e' to evaluate that.
               => 5

     The value is 5 because that is the ASCII code for `C-e'.

     The alias `last-command-char' exists for compatibility with Emacs
     version 18.

 - Variable: last-event-frame
     This variable records which frame the last input event was
     directed to.  Usually this is the frame that was selected when the
     event was generated, but if that frame has redirected input focus
     to another frame, the value is the frame to which the event was
     redirected.  *Note Input Focus::.


File: elisp,  Node: Adjusting Point,  Next: Input Events,  Prev: Command Loop Info,  Up: Command Loop

Adjusting Point After Commands
==============================

   It is not easy to display a value of point in the middle of a
sequence of text that has the `display' or `composition' property.  So
after a command finishes and returns to the command loop, if point is
within such a sequence, the command loop normally moves point to the
edge of the sequence.

   A command can inhibit this feature by setting the variable
`disable-point-adjustment':

 - Variable: disable-point-adjustment
     If this variable is non-`nil' when a command returns to the command
     loop, then the command loop does not check for text properties
     such as `display' and `composition', and does not move point out of
     sequences that have these properties.

     The command loop sets this variable to `nil' before each command,
     so if a command sets it, the effect applies only to that command.

 - Variable: global-disable-point-adjustment
     If you set this variable to a non-`nil' value, the feature of
     moving point out of these sequences is completely turned off.


File: elisp,  Node: Input Events,  Next: Reading Input,  Prev: Adjusting Point,  Up: Command Loop

Input Events
============

   The Emacs command loop reads a sequence of "input events" that
represent keyboard or mouse activity.  The events for keyboard activity
are characters or symbols; mouse events are always lists.  This section
describes the representation and meaning of input events in detail.

 - Function: eventp object
     This function returns non-`nil' if OBJECT is an input event or
     event type.

     Note that any symbol might be used as an event or an event type.
     `eventp' cannot distinguish whether a symbol is intended by Lisp
     code to be used as an event.  Instead, it distinguishes whether the
     symbol has actually been used in an event that has been read as
     input in the current Emacs session.  If a symbol has not yet been
     so used, `eventp' returns `nil'.

* Menu:

* Keyboard Events::		Ordinary characters--keys with symbols on them.
* Function Keys::		Function keys--keys with names, not symbols.
* Mouse Events::                Overview of mouse events.
* Click Events::		Pushing and releasing a mouse button.
* Drag Events::			Moving the mouse before releasing the button.
* Button-Down Events::		A button was pushed and not yet released.
* Repeat Events::               Double and triple click (or drag, or down).
* Motion Events::		Just moving the mouse, not pushing a button.
* Focus Events::		Moving the mouse between frames.
* Misc Events::                 Other events window systems can generate.
* Event Examples::		Examples of the lists for mouse events.
* Classifying Events::		Finding the modifier keys in an event symbol.
				Event types.
* Accessing Events::		Functions to extract info from events.
* Strings of Events::           Special considerations for putting
				  keyboard character events in a string.


File: elisp,  Node: Keyboard Events,  Next: Function Keys,  Up: Input Events

Keyboard Events
---------------

   There are two kinds of input you can get from the keyboard: ordinary
keys, and function keys.  Ordinary keys correspond to characters; the
events they generate are represented in Lisp as characters.  The event
type of a character event is the character itself (an integer); see
*Note Classifying Events::.

   An input character event consists of a "basic code" between 0 and
524287, plus any or all of these "modifier bits":

meta
     The 2**27 bit in the character code indicates a character typed
     with the meta key held down.

control
     The 2**26 bit in the character code indicates a non-ASCII control
     character.

     ASCII control characters such as `C-a' have special basic codes of
     their own, so Emacs needs no special bit to indicate them.  Thus,
     the code for `C-a' is just 1.

     But if you type a control combination not in ASCII, such as `%'
     with the control key, the numeric value you get is the code for
     `%' plus 2**26 (assuming the terminal supports non-ASCII control
     characters).

shift
     The 2**25 bit in the character code indicates an ASCII control
     character typed with the shift key held down.

     For letters, the basic code itself indicates upper versus lower
     case; for digits and punctuation, the shift key selects an
     entirely different character with a different basic code.  In
     order to keep within the ASCII character set whenever possible,
     Emacs avoids using the 2**25 bit for those characters.

     However, ASCII provides no way to distinguish `C-A' from `C-a', so
     Emacs uses the 2**25 bit in `C-A' and not in `C-a'.

hyper
     The 2**24 bit in the character code indicates a character typed
     with the hyper key held down.

super
     The 2**23 bit in the character code indicates a character typed
     with the super key held down.

alt
     The 2**22 bit in the character code indicates a character typed
     with the alt key held down.  (On some terminals, the key labeled
     <ALT> is actually the meta key.)

   It is best to avoid mentioning specific bit numbers in your program.
To test the modifier bits of a character, use the function
`event-modifiers' (*note Classifying Events::).  When making key
bindings, you can use the read syntax for characters with modifier bits
(`\C-', `\M-', and so on).  For making key bindings with `define-key',
you can use lists such as `(control hyper ?x)' to specify the
characters (*note Changing Key Bindings::).  The function
`event-convert-list' converts such a list into an event type (*note
Classifying Events::).


File: elisp,  Node: Function Keys,  Next: Mouse Events,  Prev: Keyboard Events,  Up: Input Events

Function Keys
-------------

   Most keyboards also have "function keys"--keys that have names or
symbols that are not characters.  Function keys are represented in Emacs
Lisp as symbols; the symbol's name is the function key's label, in lower
case.  For example, pressing a key labeled <F1> places the symbol `f1'
in the input stream.

   The event type of a function key event is the event symbol itself.
*Note Classifying Events::.

   Here are a few special cases in the symbol-naming convention for
function keys:

`backspace', `tab', `newline', `return', `delete'
     These keys correspond to common ASCII control characters that have
     special keys on most keyboards.

     In ASCII, `C-i' and <TAB> are the same character.  If the terminal
     can distinguish between them, Emacs conveys the distinction to
     Lisp programs by representing the former as the integer 9, and the
     latter as the symbol `tab'.

     Most of the time, it's not useful to distinguish the two.  So
     normally `function-key-map' (*note Translating Input::) is set up
     to map `tab' into 9.  Thus, a key binding for character code 9 (the
     character `C-i') also applies to `tab'.  Likewise for the other
     symbols in this group.  The function `read-char' likewise converts
     these events into characters.

     In ASCII, <BS> is really `C-h'.  But `backspace' converts into the
     character code 127 (<DEL>), not into code 8 (<BS>).  This is what
     most users prefer.

`left', `up', `right', `down'
     Cursor arrow keys

`kp-add', `kp-decimal', `kp-divide', ...
     Keypad keys (to the right of the regular keyboard).

`kp-0', `kp-1', ...
     Keypad keys with digits.

`kp-f1', `kp-f2', `kp-f3', `kp-f4'
     Keypad PF keys.

`kp-home', `kp-left', `kp-up', `kp-right', `kp-down'
     Keypad arrow keys.  Emacs normally translates these into the
     corresponding non-keypad keys `home', `left', ...

`kp-prior', `kp-next', `kp-end', `kp-begin', `kp-insert', `kp-delete'
     Additional keypad duplicates of keys ordinarily found elsewhere.
     Emacs normally translates these into the like-named non-keypad
     keys.

   You can use the modifier keys <ALT>, <CTRL>, <HYPER>, <META>,
<SHIFT>, and <SUPER> with function keys.  The way to represent them is
with prefixes in the symbol name:

`A-'
     The alt modifier.

`C-'
     The control modifier.

`H-'
     The hyper modifier.

`M-'
     The meta modifier.

`S-'
     The shift modifier.

`s-'
     The super modifier.

   Thus, the symbol for the key <F3> with <META> held down is `M-f3'.
When you use more than one prefix, we recommend you write them in
alphabetical order; but the order does not matter in arguments to the
key-binding lookup and modification functions.


File: elisp,  Node: Mouse Events,  Next: Click Events,  Prev: Function Keys,  Up: Input Events

Mouse Events
------------

   Emacs supports four kinds of mouse events: click events, drag events,
button-down events, and motion events.  All mouse events are represented
as lists.  The CAR of the list is the event type; this says which mouse
button was involved, and which modifier keys were used with it.  The
event type can also distinguish double or triple button presses (*note
Repeat Events::).  The rest of the list elements give position and time
information.

   For key lookup, only the event type matters: two events of the same
type necessarily run the same command.  The command can access the full
values of these events using the `e' interactive code.  *Note
Interactive Codes::.

   A key sequence that starts with a mouse event is read using the
keymaps of the buffer in the window that the mouse was in, not the
current buffer.  This does not imply that clicking in a window selects
that window or its buffer--that is entirely under the control of the
command binding of the key sequence.


File: elisp,  Node: Click Events,  Next: Drag Events,  Prev: Mouse Events,  Up: Input Events

Click Events
------------

   When the user presses a mouse button and releases it at the same
location, that generates a "click" event.  Mouse click events have this
form:

     (EVENT-TYPE
      (WINDOW BUFFER-POS (X . Y) TIMESTAMP)
      CLICK-COUNT)

   Here is what the elements normally mean:

EVENT-TYPE
     This is a symbol that indicates which mouse button was used.  It is
     one of the symbols `mouse-1', `mouse-2', ..., where the buttons
     are numbered left to right.

     You can also use prefixes `A-', `C-', `H-', `M-', `S-' and `s-'
     for modifiers alt, control, hyper, meta, shift and super, just as
     you would with function keys.

     This symbol also serves as the event type of the event.  Key
     bindings describe events by their types; thus, if there is a key
     binding for `mouse-1', that binding would apply to all events whose
     EVENT-TYPE is `mouse-1'.

WINDOW
     This is the window in which the click occurred.

X, Y
     These are the pixel-denominated coordinates of the click, relative
     to the top left corner of WINDOW, which is `(0 . 0)'.

BUFFER-POS
     This is the buffer position of the character clicked on.

TIMESTAMP
     This is the time at which the event occurred, in milliseconds.
     (Since this value wraps around the entire range of Emacs Lisp
     integers in about five hours, it is useful only for relating the
     times of nearby events.)

CLICK-COUNT
     This is the number of rapid repeated presses so far of the same
     mouse button.  *Note Repeat Events::.

   The meanings of BUFFER-POS, X and Y are somewhat different when the
event location is in a special part of the screen, such as the mode
line or a scroll bar.

   If the location is in a scroll bar, then BUFFER-POS is the symbol
`vertical-scroll-bar' or `horizontal-scroll-bar', and the pair `(X .
Y)' is replaced with a pair `(PORTION . WHOLE)', where PORTION is the
distance of the click from the top or left end of the scroll bar, and
WHOLE is the length of the entire scroll bar.

   If the position is on a mode line or the vertical line separating
WINDOW from its neighbor to the right, then BUFFER-POS is the symbol
`mode-line', `header-line', or `vertical-line'.  For the mode line, Y
does not have meaningful data.  For the vertical line, X does not have
meaningful data.

   In one special case, BUFFER-POS is a list containing a symbol (one
of the symbols listed above) instead of just the symbol.  This happens
after the imaginary prefix keys for the event are inserted into the
input stream.  *Note Key Sequence Input::.


File: elisp,  Node: Drag Events,  Next: Button-Down Events,  Prev: Click Events,  Up: Input Events

Drag Events
-----------

   With Emacs, you can have a drag event without even changing your
clothes.  A "drag event" happens every time the user presses a mouse
button and then moves the mouse to a different character position before
releasing the button.  Like all mouse events, drag events are
represented in Lisp as lists.  The lists record both the starting mouse
position and the final position, like this:

     (EVENT-TYPE
      (WINDOW1 BUFFER-POS1 (X1 . Y1) TIMESTAMP1)
      (WINDOW2 BUFFER-POS2 (X2 . Y2) TIMESTAMP2)
      CLICK-COUNT)

   For a drag event, the name of the symbol EVENT-TYPE contains the
prefix `drag-'.  For example, dragging the mouse with button 2 held
down generates a `drag-mouse-2' event.  The second and third elements
of the event give the starting and ending position of the drag.  Aside
from that, the data have the same meanings as in a click event (*note
Click Events::).  You can access the second element of any mouse event
in the same way, with no need to distinguish drag events from others.

   The `drag-' prefix follows the modifier key prefixes such as `C-'
and `M-'.

   If `read-key-sequence' receives a drag event that has no key
binding, and the corresponding click event does have a binding, it
changes the drag event into a click event at the drag's starting
position.  This means that you don't have to distinguish between click
and drag events unless you want to.


File: elisp,  Node: Button-Down Events,  Next: Repeat Events,  Prev: Drag Events,  Up: Input Events

Button-Down Events
------------------

   Click and drag events happen when the user releases a mouse button.
They cannot happen earlier, because there is no way to distinguish a
click from a drag until the button is released.

   If you want to take action as soon as a button is pressed, you need
to handle "button-down" events.(1)  These occur as soon as a button is
pressed.  They are represented by lists that look exactly like click
events (*note Click Events::), except that the EVENT-TYPE symbol name
contains the prefix `down-'.  The `down-' prefix follows modifier key
prefixes such as `C-' and `M-'.

   The function `read-key-sequence' ignores any button-down events that
don't have command bindings; therefore, the Emacs command loop ignores
them too.  This means that you need not worry about defining
button-down events unless you want them to do something.  The usual
reason to define a button-down event is so that you can track mouse
motion (by reading motion events) until the button is released.  *Note
Motion Events::.

   ---------- Footnotes ----------

   (1) Button-down is the conservative antithesis of drag.

