
INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* SLIB: (slib).         Scheme Library
END-INFO-DIR-ENTRY



  This file documents SLIB, the portable Scheme library.

Copyright (C) 1993 Todd R. Eigenschink
Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Aubrey Jaffer

  Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

  Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

  Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the author.



File: slib.info, Node: Top, Next: The Library System, Prev: (dir), Up: (dir)


"SLIB" is a portable library for the programming language "Scheme".
It provides a platform independent framework for using "packages" of
Scheme procedures and syntax.  As distributed, SLIB contains useful
packages for all Scheme implementations.  Its catalog can be
transparently extended to accomodate packages specific to a site,
implementation, user, or directory.

* Menu:

* The Library System::          How to use and customize.
* Universal SLIB Procedures::   Provided for all implementations.
* Scheme Syntax Extension Packages::  
* Textual Conversion Packages::  
* Mathematical Packages::       
* Database Packages::           
* Other Packages::              
* About SLIB::                  Install, etc.
* Index::                       



File: slib.info, Node: The Library System, Next: Universal SLIB Procedures, Prev: Top, Up: Top

The Library System
******************

* Menu:

* Feature::                     SLIB names.
* Require::                     
* Library Catalogs::            
* Catalog Creation::            
* Catalog Vicinities::          
* Compiling Scheme::            




File: slib.info, Node: Feature, Next: Require, Prev: The Library System, Up: The Library System

Feature
=======

  SLIB denotes "features" by symbols.  SLIB maintains a list of features
supported by a Scheme "session".  The set of features provided by a
session may change during that session.  Some features are properties
of the Scheme implementation being used.  The following "intrinsic
feature"s detail what sort of numbers are available from an
implementation:

   * 'inexact
   * 'rational
   * 'real
   * 'complex
   * 'bignum

SLIB initialization (in `require.scm') tests and "provide"s any of
these numeric features which are appropriate.

Other features correspond to the presence of packages of Scheme
procedures or syntax (macros).

 -- Function: provided? FEATURE
     Returns `#t' if FEATURE is present in the current Scheme session;
     otherwise `#f'.  More specifically, `provided?'  returns `#t' if
     the symbol FEATURE is the `software-type' or if FEATURE has been
     provided by a module already loaded; and `#f' otherwise.

     In some implementations `provided?' tests whether a module has
     been `require'd by any module or in any thread; other
     implementations will have `provided?' reflect only the modules
     `require'd by that particular session or thread.

     To work portably in both scenarios, use `provided?' only to test
     whether intrinsic properties (like those above) are present.

     The FEATURE argument can also be an expression calling `and',
     `or', and `not' of features.  The boolean result of the logical
     question asked by FEATURE is returned.

The generalization of `provided?' for arbitrary features and catalog
is `feature-eval':

 -- Function: feature-eval EXPRESSION PROVIDED?
     Evaluates `and', `or', and `not' forms in EXPRESSION, using the
     values returned by calling PROVIDED?  on the leaf symbols.
     `feature-eval' returns the boolean result of the logical
     combinations.

 -- Procedure: provide FEATURE
     Informs SLIB that FEATURE is supported in this session.

     (provided? 'foo)    => #f
     (provide 'foo)
     (provided? 'foo)    => #t





File: slib.info, Node: Require, Next: Library Catalogs, Prev: Feature, Up: The Library System

Require
=======

SLIB creates and maintains a "catalog" mapping features to locations
of files introducing procedures and syntax denoted by those features.

 -- Variable: *catalog*
     Is an association list of features (symbols) and pathnames which
     will supply those features.  The pathname can be either a string
     or a pair.  If pathname is a pair then the first element should
     be a macro feature symbol, `source', `compiled', or one of the
     other cases described in *Note Library Catalogs::.  The cdr of
     the pathname should be either a string or a list.

  At the beginning of each section of this manual, there is a line like
`(require 'FEATURE)'.  The Scheme files comprising SLIB are cataloged
so that these feature names map to the corresponding files.

SLIB provides a form, `require', which loads the files providing the
requested feature.

 -- Procedure: require FEATURE
        * If `(provided? FEATURE)' is true, then `require' just
          returns.
        * Otherwise, if FEATURE is found in the catalog, then the
          corresponding files will be loaded and `(provided?
          FEATURE)' will henceforth return `#t'.  That FEATURE is
          thereafter `provided'.
        * Otherwise (FEATURE not found in the catalog), an error is
          signaled.

There is a related form `require-if', used primarily for enabling
compilers to statically include modules which would be dynamically
loaded by interpreters.

 -- Procedure: require-if CONDITION FEATURE

     Requires FEATURE if CONDITION is true.

The `random' module uses `require-if' to flag `object->string' as a
(dynamic) required module.

     (require 'byte)
     (require 'logical)
     (require-if 'compiling 'object->string)

The `batch' module uses `require-if' to flag `posix-time' as a module
to load if the implementation supports large precision exact integers.

     (require-if '(and bignum compiling) 'posix-time)

The `commutative-ring' module uses `require-if' to ensure that it has
an exponentiation routine, regardless of whether the implementation
supports inexact numbers:

     (require-if '(not inexact) 'logical)    ;for integer-expt
     (define number^ (if (provided? 'inexact) expt integer-expt))

The catalog can also be queried using `slib:in-catalog?'.

 -- Function: slib:in-catalog? FEATURE
     Returns a `CDR' of the catalog entry if one was found for the
     symbol FEATURE in the alist `*catalog*' (and transitively through
     any symbol aliases encountered).  Otherwise, returns `#f'.  The
     format of catalog entries is explained in *Note Library
     Catalogs::.




File: slib.info, Node: Library Catalogs, Next: Catalog Creation, Prev: Require, Up: The Library System

Library Catalogs
================

  Catalog files consist of one or more "association list"s.
In the circumstance where a feature symbol appears in more than one
list, the latter list's association is retrieved.  Here are the
supported formats for elements of catalog lists:

`(FEATURE . <symbol>)'
     Redirects to the feature named <symbol>.
`(FEATURE . "<path>")'
     Loads file <path>.
`(FEATURE source "<path>")'
     `slib:load's the Scheme source file <path>.
`(FEATURE compiled "<path>" ...)'
     `slib:load-compiled's the files <path> ....
`(FEATURE aggregate <symbol> ...)'
     `slib:require's the features <symbol> ....

The various macro styles first `require' the named macro package, then
just load <path> or load-and-macro-expand <path> as appropriate for
the implementation.

`(FEATURE defmacro "<path>")'
     `defmacro:load's the Scheme source file <path>.
`(FEATURE macro-by-example "<path>")'
     `defmacro:load's the Scheme source file <path>.

`(FEATURE macro "<path>")'
     `macro:load's the Scheme source file <path>.
`(FEATURE macros-that-work "<path>")'
     `macro:load's the Scheme source file <path>.
`(FEATURE syntax-case "<path>")'
     `macro:load's the Scheme source file <path>.
`(FEATURE syntactic-closures "<path>")'
     `macro:load's the Scheme source file <path>.




File: slib.info, Node: Catalog Creation, Next: Catalog Vicinities, Prev: Library Catalogs, Up: The Library System

Catalog Creation
================

At the start of an interactive session no catalog is present, but is
created with the first catalog inquiry (such as `(require 'random)').
Several sources of catalog information are combined to produce the
catalog:

   * standard SLIB packages.
   * additional packages of interest to this site.
   * packages specifically for the variety of Scheme which this
     session is running.
   * packages this user wants to always have available.  This catalog
     is the file `homecat' in the user's "HOME" directory.
   * packages germane to working in this (current working) directory.
     This catalog is the file `usercat' in the directory to which it
     applies.  One would typically `cd' to this directory before
     starting the Scheme session.
   * packages which are part of an application program.

SLIB combines the catalog information which doesn't vary per user into
the file `slibcat' in the implementation-vicinity.  Therefore
`slibcat' needs change only when new software is installed or
compiled.  Because the actual pathnames of files can differ from
installation to installation, SLIB builds a separate catalog for each
implementation it is used with.

The definition of `*SLIB-VERSION*' in SLIB file `require.scm' is
checked against the catalog association of `*SLIB-VERSION*' to
ascertain when versions have changed.  It is a reasonable practice to
change the definition of `*SLIB-VERSION*' whenever the library is
changed.  If multiple implementations of Scheme use SLIB, remember
that recompiling one `slibcat' will update only that implementation's
catalog.

The compilation scripts of Scheme implementations which work with SLIB
can automatically trigger catalog compilation by deleting `slibcat' or
by invoking `require' of a special feature:

 -- Procedure: require 'NEW-CATALOG
     This will load `mklibcat', which compiles and writes a new
     `slibcat'.

Another special feature of `require' erases SLIB's catalog, forcing it
to be reloaded the next time the catalog is queried.

 -- Procedure: require #F
     Removes SLIB's catalog information.  This should be done before
     saving an executable image so that, when restored, its catalog
     will be loaded afresh.




File: slib.info, Node: Catalog Vicinities, Next: Compiling Scheme, Prev: Catalog Creation, Up: The Library System

Catalog Vicinities
==================

Each file in the table below is descibed in terms of its file-system
independent "vicinity" (*Note Vicinity::).  The entries of a catalog
in the table override those of catalogs above it in the table.


`implementation-vicinity' `slibcat'
     This file contains the associations for the packages comprising
     SLIB, the `implcat' and the `sitecat's.  The associations in the
     other catalogs override those of the standard catalog.

`library-vicinity' `mklibcat.scm'
     creates `slibcat'.

`library-vicinity' `sitecat'
     This file contains the associations specific to an SLIB
     installation.

`implementation-vicinity' `implcat'
     This file contains the associations specific to an implementation
     of Scheme.  Different implementations of Scheme should have
     different `implementation-vicinity'.

`implementation-vicinity' `mkimpcat.scm'
     if present, creates `implcat'.

`implementation-vicinity' `sitecat'
     This file contains the associations specific to a Scheme
     implementation installation.

`home-vicinity' `homecat'
     This file contains the associations specific to an SLIB user.

`user-vicinity' `usercat'
     This file contains associations affecting only those sessions
     whose "working directory" is `user-vicinity'.


Here is an example of a `usercat' catalog.  A program in this
directory can invoke the `run' feature with `(require 'run)'.

     ;;; "usercat": SLIB catalog additions for SIMSYNCH.     -*-scheme-*-
     (
      (simsynch      . "../synch/simsynch.scm")
      (run           . "../synch/run.scm")
      (schlep        . "schlep.scm")
     )

Copying `usercat' to many directories is inconvenient.  Application
programs which aren't always run in specially prepared directories can
nonetheless register their features during initialization.

 -- Procedure: catalog:read VICINITY CATALOG
     Reads file named by string CATALOG in VICINITY, resolving all
     paths relative to VICINITY, and adds those feature associations
     to *CATALOG*.

     `catalog:read' would typically be used by an application program
     having dynamically loadable modules.  For instance, to register
     factoring and other modules in *CATALOG*, JACAL does:

          (catalog:read (program-vicinity) "jacalcat")


For an application program there are three appropriate venues for
registering its catalog associations:

   * in a `usercat' file in the directory where the program runs; or
   * in an `implcat' file in the `implementation-vicinity'; or
   * in an application program directory; loaded by calling
     `catalog:read'.




File: slib.info, Node: Compiling Scheme, Prev: Catalog Vicinities, Up: The Library System

Compiling Scheme
================

  To use Scheme compilers effectively with SLIB the compiler needs to
know which SLIB modules are to be compiled and which symbols are
exported from those modules.

  The procedures in this section automate the extraction of this
information from SLIB modules.  They are guaranteed to work on SLIB
modules; to use them on other sources, those sources should follow
SLIB conventions.

* Menu:

* Module Conventions::          
* Module Manifests::            
* Module Semantics::            
* Top-level Variable References::  
* Module Analysis::             



File: slib.info, Node: Module Conventions, Next: Module Manifests, Prev: Compiling Scheme, Up: Compiling Scheme

Module Conventions
------------------

   * All the top-level `require' commands have one quoted argument and
     are positioned before other Scheme definitions and expressions in
     the file.
   * Any conditionally `require'd SLIB modules (1) (*Note Module
     Conventions-Footnotes::) also appear at the beginning of their
     files conditioned on the feature `compiling' using `require-if'
     (*Note require-if: Require.).

          (require 'logical)
          (require 'multiarg/and-)
          (require-if 'compiling 'sort)
          (require-if 'compiling 'ciexyz)

   * Schmooz-style comments preceding a definition, identify that
     definition as an exported identifier (*Note Schmooz::).  For
     non-schmooz files, putting `;@' at the beginning of the line
     immediately preceding the definition (`define', `define-syntax',
     or `defmacro') suffices.

          ;@
          (define (make-vicinity <pathname>) <pathname>)

   * Syntax (macro) definitions are grouped at the end of a module
     file.

   * Modules defining macros do not invoke those macros.  SLIB macro
     implementations are exempt from this rule.

     An example of how to expand macro invocations is:

          (require 'macros-that-work)
          (require 'yasos)
          (require 'pprint-file)
          (pprint-filter-file "collect.scm" macwork:expand)




File: slib.info  Node: Module Conventions-Footnotes, Up: Module Conventions

(1) There are some functions with internal `require' calls
to delay loading modules until they are needed.  While this
reduces startup latency for interpreters, it can produce
headaches for compilers.



File: slib.info, Node: Module Manifests, Next: Module Semantics, Prev: Module Conventions, Up: Compiling Scheme

Module Manifests
----------------

  `(require 'manifest)'

In some of these examples, SLIB:CATALOG is the SLIB part of the
catalog; it is free of compiled and implementation-specific entries.
It would be defined by:

     (define slib:catalog (cdr (member (assq 'null *catalog*) *catalog*)))


 -- Function: file->requires FILE PROVIDED? CATALOG

     Returns a list of the features `require'd by FILE assuming the
     predicate PROVIDED? and association-list CATALOG.
     (define (provided+? . features)
       (lambda (feature)
         (or (memq feature features) (provided? feature))))

     (file->requires "obj2str.scm" (provided+? 'compiling) '())
             => (string-port generic-write)

     (file->requires "obj2str.scm" provided? '())
             => (string-port)


 -- Function: feature->requires FEATURE PROVIDED? CATALOG

     Returns a list of the features `require'd by FEATURE assuming the
     predicate PROVIDED? and association-list CATALOG.
     (feature->requires 'batch (provided+? 'compiling) *catalog*)
             => (tree line-i/o databases parameters string-port
                        pretty-print common-list-functions posix-time)

     (feature->requires 'batch provided? *catalog*)
             => (tree line-i/o databases parameters string-port
                        pretty-print common-list-functions)

     (feature->requires 'batch provided? '((batch . "batch")))
             => (tree line-i/o databases parameters string-port
                        pretty-print common-list-functions)


 -- Function: file->loads FILE

     Returns a list of strings naming existing files loaded (load
     slib:load slib:load-source macro:load defmacro:load syncase:load
     synclo:load macwork:load) by FILE or any of the files it loads.
     (file->loads (in-vicinity (library-vicinity) "scainit.scm"))
             => ("/usr/local/lib/slib/scaexpp.scm"
                 "/usr/local/lib/slib/scaglob.scm"
                 "/usr/local/lib/slib/scaoutp.scm")


 -- Function: load->path EXP

     Given a `(load '<expr>)', where <expr> is a string or vicinity
     stuff), `(load->path <expr>)' figures a path to the file.
     `load->path' returns that path if it names an existing file;
     otherwise #f.
     (load->path '(in-vicinity (library-vicinity) "mklibcat"))
             => "/usr/local/lib/slib/mklibcat.scm"


 -- Function: file->definitions FILE

     Returns a list of the identifier symbols defined by SLIB (or
     SLIB-style) file FILE.
     (file->definitions "random.scm")
             => (*random-state* make-random-state
                seed->random-state copy-random-state random
                random:chunk)


 -- Function: file->exports FILE

     Returns a list of the identifier symbols exported (advertised) by
     SLIB (or SLIB-style) file FILE.
     (file->exports "random.scm")
             => (make-random-state seed->random-state
                 copy-random-state random)

     (file->exports "randinex.scm")
             => (random:solid-sphere! random:hollow-sphere!
                 random:normal-vector! random:normal
                 random:exp random:uniform)


 -- Function: feature->export-alist FEATURE CATALOG

     Returns a list of lists; each sublist holding the name of the
     file implementing FEATURE, and the identifier symbols exported
     (advertised) by SLIB (or SLIB-style) feature FEATURE, in CATALOG.

 -- Function: feature->exports FEATURE CATALOG

     Returns a list of all exports of FEATURE.  In the case of
`aggregate' features, more than one file may have export lists to
report:

     (feature->export-alist 'r5rs slib:catalog))
             => (("/usr/local/lib/slib/values.scm"
                  call-with-values values)
                 ("/usr/local/lib/slib/mbe.scm"
                  define-syntax macro:expand
                  macro:load macro:eval)
                 ("/usr/local/lib/slib/eval.scm"
                  eval scheme-report-environment
                  null-environment interaction-environment))

     (feature->export-alist 'stdio *catalog*)
             => (("/usr/local/lib/slib/scanf.scm"
                  fscanf sscanf scanf scanf-read-list)
                 ("/usr/local/lib/slib/printf.scm"
                  sprintf printf fprintf)
                 ("/usr/local/lib/slib/stdio.scm"
                  stderr stdout stdin))

     (feature->exports 'stdio slib:catalog)
             => (fscanf sscanf scanf scanf-read-list
                  sprintf printf fprintf stderr stdout stdin)




File: slib.info, Node: Module Semantics, Next: Top-level Variable References, Prev: Module Manifests, Up: Compiling Scheme

Module Semantics
----------------

  For the purpose of compiling Scheme code, each top-level `require'
makes the identifiers exported by its feature's module `defined' (or
defmacroed or defined-syntaxed) within the file (being compiled)
headed with those requires.

  Top-level occurrences of `require-if' make defined the exports from
the module named by the second argument *if* the FEATURE-EXPRESSION
first argument is true in the target environment.  The target feature
`compiling' should be provided during this phase of compilation.

  Non-top-level SLIB occurences of `require' and `require-if' of
quoted features can be ignored by compilers.  The SLIB modules will
all have top-level constructs for those features.

  Note that aggregate catalog entries import more than one module.
Implementations of `require' may or may *not* be transitive; code
which uses module exports without requiring the providing module is in
error.

  In the SLIB modules `modular', `batch', `hash', `common-lisp-time',
`commutative-ring', `charplot', `logical', `common-list-functions',
`coerce' and `break' there is code conditional on features being
`provided?'.  Most are testing for the presence of features which are
intrinsic to implementations (inexacts, bignums, ...).

  In all cases these `provided?' tests can be evaluated at
compile-time using `feature-eval' (*Note feature-eval: Feature.).  The
simplest way to compile these constructs may be to treat `provided?'
as a macro.




File: slib.info, Node: Top-level Variable References, Next: Module Analysis, Prev: Module Semantics, Up: Compiling Scheme

Top-level Variable References
-----------------------------

  `(require 'top-refs)'

These procedures complement those in *Note Module Manifests:: by
finding the top-level variable references in Scheme source code.  They
work by traversing expressions and definitions, keeping track of
bindings encountered.  It is certainly possible to foil these
functions, but they return useful information about SLIB source code.


 -- Function: top-refs OBJ

     Returns a list of the top-level variables referenced by the
     Scheme expression OBJ.

 -- Function: top-refs<-file FILENAME

     FILENAME should be a string naming an existing file containing
     Scheme source code.  `top-refs<-file' returns a list of the
     top-level variable references made by expressions in the file
     named by FILENAME.

  Code in modules which FILENAME `require's is not traversed.  Code in
files loaded from top-level *is* traversed if the expression argument
to `load', `slib:load', `slib:load-source', `macro:load',
`defmacro:load', `synclo:load', `syncase:load', or `macwork:load' is a
literal string constant or composed of combinations of vicinity
functions and string literal constants; and the resulting file exists
(possibly with ".scm" appended).  The following function parses an
"Info" Index. (1) (*Note Top-level Variable References-Footnotes::)


 -- Function: exports<-info-index FILE N ...

     N ... must be an increasing series of positive integers.
     `exports<-info-index' returns a list of all the identifiers appearing in the Nth
     ... (info) indexes of FILE.  The identifiers have the case that
     the implementation's `read' uses for symbols.  Identifiers
     containing spaces (eg. `close-base on base-table') are *not*
     included.

     Each info index is headed by a `* Menu:' line.  To list the
     symbols in the first and third info indexes do:

          (exports<-info-index "slib.info" 1 3)




File: slib.info  Node: Top-level Variable References-Footnotes, Up: Top-level Variable References

  (1) Although it will work on large info files, feeding it an excerpt
is much faster; and has less chance of being confused by unusual text
in the info file.  This command excerpts the SLIB index into
`slib-index.info':

     info -f slib2d6.info -n "Index" -o slib-index.info




File: slib.info, Node: Module Analysis, Prev: Top-level Variable References, Up: Compiling Scheme

Module Analysis
---------------

  `(require 'vet)'


 -- Function: vet-slib

     Using the procedures in the `top-refs' and `manifest' modules,
     `vet-slib' analyzes each SLIB module, reporting about any
     procedure or macro defined whether it is:


     orphaned
          defined, not called, not exported;
     missing
          called, not defined, and not exported by its `require'd
          modules;
     undocumented-export
          Exported by module, but no index entry in `slib.info';


     And for the library as a whole:


     documented-unexport
          Index entry in `slib.info', but no module exports it.


     This straightforward analysis caught three full days worth of
     never-executed branches, transitive require assumptions, spelling
     errors, undocumented procedures, missing procedures, and cyclic
     dependencies in SLIB.





File: slib.info, Node: Universal SLIB Procedures, Next: Scheme Syntax Extension Packages, Prev: The Library System, Up: Top

Universal SLIB Procedures
*************************

The procedures described in these sections are supported by all
implementations as part of the `*.init' files or by `require.scm'.

* Menu:

* Vicinity::                    Pathname Management
* Configuration::               Characteristics of Scheme Implementation
* Input/Output::                Things not provided by the Scheme specs.
* System::                      LOADing, EVALing, ERRORing, and EXITing
* Miscellany::                  




File: slib.info, Node: Vicinity, Next: Configuration, Prev: Universal SLIB Procedures, Up: Universal SLIB Procedures

Vicinity
========

A vicinity is a descriptor for a place in the file system.  Vicinities
hide from the programmer the concepts of host, volume, directory, and
version.  Vicinities express only the concept of a file environment
where a file name can be resolved to a file in a system independent
manner.  Vicinities can even be used on "flat" file systems (which
have no directory structure) by having the vicinity express
constraints on the file name.  On most systems a vicinity would be a
string.  All of these procedures are file system dependent.

These procedures are provided by all implementations.

 -- Function: make-vicinity DIRPATH
     Returns DIRPATH as a vicinity for use as first argument to
     `in-vicinity'.

 -- Function: pathname->vicinity PATH
     Returns the vicinity containing PATH.
          (pathname->vicinity "/usr/local/lib/scm/Link.scm")
                              => "/usr/local/lib/scm/"

 -- Function: program-vicinity
     Returns the vicinity of the currently loading Scheme code.  For
     an interpreter this would be the directory containing source
     code.  For a compiled system (with multiple files) this would be
     the directory where the object or executable files are.  If no
     file is currently loading it the result is undefined.  *Warning:*
     `program-vicinity' can return incorrect values if your program
     escapes back into a `load'.

 -- Function: library-vicinity
     Returns the vicinity of the shared Scheme library.

 -- Function: implementation-vicinity
     Returns the vicinity of the underlying Scheme implementation.
     This vicinity will likely contain startup code and messages and a
     compiler.

 -- Function: user-vicinity
     Returns the vicinity of the current directory of the user.  On
     most systems this is `""' (the empty string).

 -- Function: home-vicinity
     Returns the vicinity of the user's "HOME" directory, the
     directory which typically contains files which customize a
     computer environment for a user.  If scheme is running without a
     user (eg. a daemon) or if this concept is meaningless for the
     platform, then `home-vicinity' returns `#f'.


 -- Function: vicinity:suffix? CHR
     Returns the `#t' if CHR is a vicinity suffix character; and `#f'
     otherwise.  Typical vicinity suffixes are `/', `:', and `\',

 -- Function: in-vicinity VICINITY FILENAME
     Returns a filename suitable for use by `slib:load',
     `slib:load-source', `slib:load-compiled', `open-input-file',
     `open-output-file', etc.  The returned filename is FILENAME in
     VICINITY.  `in-vicinity' should allow FILENAME to override
     VICINITY when FILENAME is an absolute pathname and VICINITY is
     equal to the value of `(user-vicinity)'.  The behavior of
     `in-vicinity' when FILENAME is absolute and VICINITY is not equal
     to the value of `(user-vicinity)' is unspecified.  For most
     systems `in-vicinity' can be `string-append'.

 -- Function: sub-vicinity VICINITY NAME
     Returns the vicinity of VICINITY restricted to NAME.  This is
     used for large systems where names of files in subsystems could
     conflict.  On systems with directory structure `sub-vicinity'
     will return a pathname of the subdirectory NAME of VICINITY.





File: slib.info, Node: Configuration, Next: Input/Output, Prev: Vicinity, Up: Universal SLIB Procedures

Configuration
=============

These constants and procedures describe characteristics of the Scheme
and underlying operating system.  They are provided by all
implementations.

 -- Constant: char-code-limit
     An integer 1 larger that the largest value which can be returned
     by `char->integer'.

 -- Constant: most-positive-fixnum
     In implementations which support integers of practically
     unlimited size, MOST-POSITIVE-FIXNUM is a large exact integer
     within the range of exact integers that may result from computing
     the length of a list, vector, or string.

     In implementations which do not support integers of practically
     unlimited size, MOST-POSITIVE-FIXNUM is the largest exact integer
     that may result from computing the length of a list, vector, or
     string.

 -- Constant: slib:tab
     The tab character.

 -- Constant: slib:form-feed
     The form-feed character.

 -- Function: software-type
     Returns a symbol denoting the generic operating system type.  For
     instance, `unix', `vms', `macos', `amiga', or `ms-dos'.

 -- Function: slib:report-version
     Displays the versions of SLIB and the underlying Scheme
     implementation and the name of the operating system.  An
     unspecified value is returned.

          (slib:report-version) => slib "3a1" on scm "5b1" on unix

 -- Function: slib:report

Displays the information of `(slib:report-version)' followed by
almost all the information neccessary for submitting a problem
report.  An unspecified value is returned.
 -- Function: slib:report #T

provides a more verbose listing.
 -- Function: slib:report FILENAME
     Writes the report to file `filename'.

          (slib:report)
          =>
          slib "3a1" on scm "5b1" on unix
          (implementation-vicinity) is "/usr/local/lib/scm/"
          (library-vicinity) is "/usr/local/lib/slib/"
          (scheme-file-suffix) is ".scm"
          loaded *features* :
                  trace alist qp sort
                  common-list-functions macro values getopt
                  compiled
          implementation *features* :
                  bignum complex real rational
                  inexact vicinity ed getenv
                  tmpnam abort transcript with-file
                  ieee-p1178 r4rs rev4-optional-procedures hash
                  object-hash delay eval dynamic-wind
                  multiarg-apply multiarg/and- logical defmacro
                  string-port source current-time record
                  rev3-procedures rev2-procedures sun-dl string-case
                  array dump char-ready? full-continuation
                  system
          implementation *catalog* :
                  (i/o-extensions compiled "/usr/local/lib/scm/ioext.so")
                  ...



File: slib.info, Node: Input/Output, Next: System, Prev: Configuration, Up: Universal SLIB Procedures

Input/Output
============

These procedures are provided by all implementations.

 -- Function: file-exists? FILENAME
     Returns `#t' if the specified file exists.  Otherwise, returns
     `#f'.  If the underlying implementation does not support this
     feature then `#f' is always returned.

 -- Function: delete-file FILENAME
     Deletes the file specified by FILENAME.  If FILENAME can not be
     deleted, `#f' is returned.  Otherwise, `#t' is returned.

 -- Function: open-file FILENAME MODES
     FILENAME should be a string naming a file.  `open-file' returns a
     port depending on the symbol MODES:

     r
          an input port capable of delivering characters from the
          file.
     rb
          a *binary* input port capable of delivering characters from
          the file.
     w
          an output port capable of writing characters to a new file
          by that name.
     wb
          a *binary* output port capable of writing characters to a
          new file by that name.

     If an implementation does not distinguish between binary and
     non-binary files, then it must treat rb as r and wb as w.

     If the file cannot be opened, either #f is returned or an error
     is signalled.  For output, if a file with the given name already
     exists, the effect is unspecified.

 -- Function: port? OBJ
     Returns #t if OBJ is an input or output port, otherwise returns
     #f.

 -- Procedure: close-port PORT
     Closes the file associated with PORT, rendering the PORT
     incapable of delivering or accepting characters.

     `close-file' has no effect if the file has already been closed.
     The value returned is unspecified.

 -- Function: call-with-open-ports PROC PORTS ...
 -- Function: call-with-open-ports PORTS ... PROC
     PROC should be a procedure that accepts as many arguments as
     there are PORTS passed to `call-with-open-ports'.
     `call-with-open-ports' calls PROC with PORTS ....  If PROC
     returns, then the ports are closed automatically and the value
     yielded by the PROC is returned.  If PROC does not return, then
     the ports will not be closed automatically unless it is possible
     to prove that the ports will never again be used for a read or
     write operation.

 -- Function: tmpnam
     Returns a pathname for a file which will likely not be used by
     any other process.  Successive calls to `(tmpnam)' will return
     different pathnames.

 -- Function: current-error-port
     Returns the current port to which diagnostic and error output is
     directed.

 -- Procedure: force-output
 -- Procedure: force-output PORT
     Forces any pending output on PORT to be delivered to the output
     device and returns an unspecified value.  The PORT argument may
     be omitted, in which case it defaults to the value returned by
     `(current-output-port)'.

 -- Function: output-port-width
 -- Function: output-port-width PORT

     Returns the width of PORT, which defaults to
     `(current-output-port)' if absent.  If the width cannot be
     determined 79 is returned.

 -- Function: output-port-height
 -- Function: output-port-height PORT

     Returns the height of PORT, which defaults to
     `(current-output-port)' if absent.  If the height cannot be
     determined 24 is returned.




File: slib.info, Node: System, Next: Miscellany, Prev: Input/Output, Up: Universal SLIB Procedures

System
======

These procedures are provided by all implementations.

 -- Procedure: slib:load-source NAME
     Loads a file of Scheme source code from NAME with the default
     filename extension used in SLIB.  For instance if the filename
     extension used in SLIB is `.scm' then `(slib:load-source "foo")'
     will load from file `foo.scm'.

 -- Procedure: slib:load-compiled NAME
     On implementations which support separtely loadable compiled
     modules, loads a file of compiled code from NAME with the
     implementation's filename extension for compiled code appended.

 -- Procedure: slib:load NAME
     Loads a file of Scheme source or compiled code from NAME with the
     appropriate suffixes appended.  If both source and compiled code
     are present with the appropriate names then the implementation
     will load just one.  It is up to the implementation to choose
     which one will be loaded.

     If an implementation does not support compiled code then
     `slib:load' will be identical to `slib:load-source'.

 -- Procedure: slib:eval OBJ
     `eval' returns the value of OBJ evaluated in the current top
     level environment.  *Note Eval:: provides a more general
     evaluation facility.

 -- Procedure: slib:eval-load FILENAME EVAL
     FILENAME should be a string.  If filename names an existing file,
     the Scheme source code expressions and definitions are read from
     the file and EVAL called with them sequentially.  The
     `slib:eval-load' procedure does not affect the values returned by
     `current-input-port' and `current-output-port'.

 -- Procedure: slib:warn ARG1 ARG2 ...
     Outputs a warning message containing the arguments.

 -- Procedure: slib:error ARG1 ARG2 ...
     Outputs an error message containing the arguments, aborts
     evaluation of the current form and responds in a system dependent
     way to the error.  Typical responses are to abort the program or
     to enter a read-eval-print loop.

 -- Procedure: slib:exit N
 -- Procedure: slib:exit
     Exits from the Scheme session returning status N to the system.
     If N is omitted or `#t', a success status is returned to the
     system (if possible).  If N is `#f' a failure is returned to the
     system (if possible).  If N is an integer, then N is returned to
     the system (if possible).  If the Scheme session cannot exit an
     unspecified value is returned from `slib:exit'.

 -- Function: browse-url URL
     Web browsers have become so ubiquitous that programming
     languagues should support a uniform interface to them.

     If a `netscape' browser is running, `browse-url' causes the
     browser to display the page specified by string URL and returns
     #t.

     If the browser is not running, `browse-url' starts a browser
     displaying the argument URL.  If the browser starts as a
     background job, `browse-url' returns #t immediately; if the
     browser starts as a foreground job, then `browse-url' returns #t
     when the browser exits; otherwise it returns #f.




File: slib.info, Node: Miscellany, Prev: System, Up: Universal SLIB Procedures

Miscellany
==========

  These procedures are provided by all implementations.

 -- Function: identity X
     IDENTITY returns its argument.

     Example:
          (identity 3)
             => 3
          (identity '(foo bar))
             => (foo bar)
          (map identity LST)
             == (copy-list LST)


Mutual Exclusion
----------------

  An "exchanger" is a procedure of one argument regulating mutually
exclusive access to a resource.  When a exchanger is called, its
current content is returned, while being replaced by its argument in
an atomic operation.

 -- Function: make-exchanger OBJ

     Returns a new exchanger with the argument OBJ as its initial
     content.

          (define queue (make-exchanger (list a)))

     A queue implemented as an exchanger holding a list can be
     protected from reentrant execution thus:

          (define (pop queue)
            (let ((lst #f))
              (dynamic-wind
                  (lambda () (set! lst (queue #f)))
                  (lambda () (and lst (not (null? lst))
                                  (let ((ret (car lst)))
                                    (set! lst (cdr lst))
                                    ret)))
                  (lambda () (and lst (queue lst))))))

          (pop queue)         => a

          (pop queue)         => #f



Legacy
------

The following procedures were present in Scheme until R4RS (*Note
Language changes: (r4rs)Notes.).  They are provided by all SLIB
implementations.

 -- Constant: t
     Derfined as `#t'.

 -- Constant: nil
     Defined as `#f'.

 -- Function: last-pair L
     Returns the last pair in the list L.  Example:
          (last-pair (cons 1 2))
             => (1 . 2)
          (last-pair '(1 2))
             => (2)
              == (cons 2 '())




File: slib.info, Node: Scheme Syntax Extension Packages, Next: Textual Conversion Packages, Prev: Universal SLIB Procedures, Up: Top

Scheme Syntax Extension Packages
********************************

* Menu:

* Defmacro::                    Supported by all implementations

* R4RS Macros::                 'macro
* Macro by Example::            'macro-by-example
* Macros That Work::            'macros-that-work
* Syntactic Closures::          'syntactic-closures
* Syntax-Case Macros::          'syntax-case

Syntax extensions (macros) included with SLIB.

* Fluid-Let::                   'fluid-let
* Yasos::                       'yasos, 'oop, 'collect




File: slib.info, Node: Defmacro, Next: R4RS Macros, Prev: Scheme Syntax Extension Packages, Up: Scheme Syntax Extension Packages

Defmacro
========

  Defmacros are supported by all implementations.

 -- Function: gentemp
     Returns a new (interned) symbol each time it is called.  The
     symbol names are implementation-dependent
          (gentemp) => scm:G0
          (gentemp) => scm:G1

 -- Function: defmacro:eval E
     Returns the `slib:eval' of expanding all defmacros in scheme
     expression E.

 -- Function: defmacro:load FILENAME
     FILENAME should be a string.  If filename names an existing file,
     the `defmacro:load' procedure reads Scheme source code
     expressions and definitions from the file and evaluates them
     sequentially.  These source code expressions and definitions may
     contain defmacro definitions.  The `macro:load' procedure does
     not affect the values returned by `current-input-port' and
     `current-output-port'.

 -- Function: defmacro? SYM
     Returns `#t' if SYM has been defined by `defmacro', `#f'
     otherwise.

 -- Function: macroexpand-1 FORM
 -- Function: macroexpand FORM
     If FORM is a macro call, `macroexpand-1' will expand the macro
     call once and return it.  A FORM is considered to be a macro call
     only if it is a cons whose `car' is a symbol for which a
     `defmacro' has been defined.

     `macroexpand' is similar to `macroexpand-1', but repeatedly
     expands FORM until it is no longer a macro call.

 -- Macro: defmacro NAME LAMBDA-LIST FORM ...
     When encountered by `defmacro:eval', `defmacro:macroexpand*', or
     `defmacro:load' defines a new macro which will henceforth be
     expanded when encountered by `defmacro:eval',
     `defmacro:macroexpand*', or `defmacro:load'.


  Defmacroexpand
--------------
`(require 'defmacroexpand)'

 -- Function: defmacro:expand* E
     Returns the result of expanding all defmacros in scheme
     expression E.



File: slib.info, Node: R4RS Macros, Next: Macro by Example, Prev: Defmacro, Up: Scheme Syntax Extension Packages

R4RS Macros
===========

  `(require 'macro)' is the appropriate call if you want R4RS
high-level macros but don't care about the low level implementation.
If an SLIB R4RS macro implementation is already loaded it will be
used.  Otherwise, one of the R4RS macros implemetations is loaded.

  The SLIB R4RS macro implementations support the following uniform
interface:

 -- Function: macro:expand SEXPRESSION
     Takes an R4RS expression, macro-expands it, and returns the
     result of the macro expansion.

 -- Function: macro:eval SEXPRESSION
     Takes an R4RS expression, macro-expands it, evals the result of
     the macro expansion, and returns the result of the evaluation.

 -- Procedure: macro:load FILENAME
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions
     and definitions from the file and evaluates them sequentially.
     These source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port' and
     `current-output-port'.



File: slib.info, Node: Macro by Example, Next: Macros That Work, Prev: R4RS Macros, Up: Scheme Syntax Extension Packages

Macro by Example
================

  `(require 'macro-by-example)'

  A vanilla implementation of `Macro by Example' (Eugene Kohlbecker,
R4RS) by Dorai Sitaram, (dorai @ cs.rice.edu) using `defmacro'.


   * generating hygienic global `define-syntax' Macro-by-Example
     macros *cheaply*.

   * can define macros which use `...'.

   * needn't worry about a lexical variable in a macro definition
     clashing with a variable from the macro use context

   * don't suffer the overhead of redefining the repl if `defmacro'
     natively supported (most implementations)


  Caveat
------
These macros are not referentially transparent (*Note Macros:
(r4rs)Macros.).  Lexically scoped macros (i.e., `let-syntax' and
`letrec-syntax') are not supported.  In any case, the problem of
referential transparency gains poignancy only when `let-syntax' and
`letrec-syntax' are used.  So you will not be courting large-scale
disaster unless you're using system-function names as local variables
with unintuitive bindings that the macro can't use.  However, if you
must have the full `r4rs' macro functionality, look to the more
featureful (but also more expensive) versions of syntax-rules
available in slib *Note Macros That Work::, *Note Syntactic
Closures::, and *Note Syntax-Case Macros::.

 -- Macro: define-syntax KEYWORD TRANSFORMER-SPEC
     The KEYWORD is an identifier, and the TRANSFORMER-SPEC should be
     an instance of `syntax-rules'.

     The top-level syntactic environment is extended by binding the
     KEYWORD to the specified transformer.

          (define-syntax let*
            (syntax-rules ()
              ((let* () body1 body2 ...)
               (let () body1 body2 ...))
              ((let* ((name1 val1) (name2 val2) ...)
                 body1 body2 ...)
               (let ((name1 val1))
                 (let* (( name2 val2) ...)
                   body1 body2 ...)))))

 -- Macro: syntax-rules LITERALS SYNTAX-RULE ...
     LITERALS is a list of identifiers, and each SYNTAX-RULE should be
     of the form

     `(PATTERN TEMPLATE)'

     where the PATTERN and TEMPLATE are as in the grammar above.

     An instance of `syntax-rules' produces a new macro transformer by
     specifying a sequence of hygienic rewrite rules.  A use of a
     macro whose keyword is associated with a transformer specified by
     `syntax-rules' is matched against the patterns contained in the
     SYNTAX-RULEs, beginning with the leftmost SYNTAX-RULE.  When a
     match is found, the macro use is trancribed hygienically
     according to the template.

     Each pattern begins with the keyword for the macro.  This keyword
     is not involved in the matching and is not considered a pattern
     variable or literal identifier.



File: slib.info, Node: Macros That Work, Next: Syntactic Closures, Prev: Macro by Example, Up: Scheme Syntax Extension Packages

Macros That Work
================

  `(require 'macros-that-work)'

  `Macros That Work' differs from the other R4RS macro implementations
in that it does not expand derived expression types to primitive
expression types.

 -- Function: macro:expand EXPRESSION
 -- Function: macwork:expand EXPRESSION
     Takes an R4RS expression, macro-expands it, and returns the
     result of the macro expansion.

 -- Function: macro:eval EXPRESSION
 -- Function: macwork:eval EXPRESSION
     `macro:eval' returns the value of EXPRESSION in the current top
     level environment.  EXPRESSION can contain macro definitions.
     Side effects of EXPRESSION will affect the top level environment.

 -- Procedure: macro:load FILENAME
 -- Procedure: macwork:load FILENAME
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions
     and definitions from the file and evaluates them sequentially.
     These source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port' and
     `current-output-port'.

  References:

  The `Revised^4 Report on the Algorithmic Language Scheme' Clinger
and Rees [editors].  To appear in LISP Pointers.  Also available as a
technical report from the University of Oregon, MIT AI Lab, and
Cornell.

           Macros That Work.  Clinger and Rees.  POPL '91.

  The supported syntax differs from the R4RS in that vectors are
allowed as patterns and as templates and are not allowed as pattern or
template data.

     transformer spec  ==>  (syntax-rules literals rules)

     rules  ==>  ()
              |  (rule . rules)

     rule  ==>  (pattern template)

     pattern  ==>  pattern_var      ; a symbol not in literals
                |  symbol           ; a symbol in literals
                |  ()
                |  (pattern . pattern)
                |  (ellipsis_pattern)
                |  #(pattern*)                     ; extends R4RS
                |  #(pattern* ellipsis_pattern)    ; extends R4RS
                |  pattern_datum

     template  ==>  pattern_var
                 |  symbol
                 |  ()
                 |  (template2 . template2)
                 |  #(template*)                   ; extends R4RS
                 |  pattern_datum

     template2  ==>  template
                  |  ellipsis_template

     pattern_datum  ==>  string                    ; no vector
                      |  character
                      |  boolean
                      |  number

     ellipsis_pattern  ==> pattern ...

     ellipsis_template  ==>  template ...

     pattern_var  ==>  symbol   ; not in literals

     literals  ==>  ()
                 |  (symbol . literals)


Definitions
-----------


Scope of an ellipsis
     Within a pattern or template, the scope of an ellipsis (`...') is
     the pattern or template that appears to its left.

Rank of a pattern variable
     The rank of a pattern variable is the number of ellipses within
     whose scope it appears in the pattern.

Rank of a subtemplate
     The rank of a subtemplate is the number of ellipses within whose
     scope it appears in the template.

Template rank of an occurrence of a pattern variable
     The template rank of an occurrence of a pattern variable within a
     template is the rank of that occurrence, viewed as a subtemplate.

Variables bound by a pattern
     The variables bound by a pattern are the pattern variables that
     appear within it.

Referenced variables of a subtemplate
     The referenced variables of a subtemplate are the pattern
     variables that appear within it.

Variables opened by an ellipsis template
     The variables opened by an ellipsis template are the referenced
     pattern variables whose rank is greater than the rank of the
     ellipsis template.



Restrictions
------------

  No pattern variable appears more than once within a pattern.

  For every occurrence of a pattern variable within a template, the
template rank of the occurrence must be greater than or equal to the
pattern variable's rank.

  Every ellipsis template must open at least one variable.

  For every ellipsis template, the variables opened by an ellipsis
template must all be bound to sequences of the same length.

  The compiled form of a RULE is

     rule  ==>  (pattern template inserted)

     pattern  ==>  pattern_var
                |  symbol
                |  ()
                |  (pattern . pattern)
                |  ellipsis_pattern
                |  #(pattern)
                |  pattern_datum

     template  ==>  pattern_var
                 |  symbol
                 |  ()
                 |  (template2 . template2)
                 |  #(pattern)
                 |  pattern_datum

     template2  ==>  template
                  |  ellipsis_template

     pattern_datum  ==>  string
                      |  character
                      |  boolean
                      |  number

     pattern_var  ==>  #(V symbol rank)

     ellipsis_pattern  ==>  #(E pattern pattern_vars)

     ellipsis_template  ==>  #(E template pattern_vars)

     inserted  ==>  ()
                 |  (symbol . inserted)

     pattern_vars  ==>  ()
                     |  (pattern_var . pattern_vars)

     rank  ==>  exact non-negative integer

  where V and E are unforgeable values.

  The pattern variables associated with an ellipsis pattern are the
variables bound by the pattern, and the pattern variables associated
with an ellipsis template are the variables opened by the ellipsis
template.

  If the template contains a big chunk that contains no pattern
variables or inserted identifiers, then the big chunk will be copied
unnecessarily.  That shouldn't matter very often.







File: slib.info, Node: Syntactic Closures, Next: Syntax-Case Macros, Prev: Macros That Work, Up: Scheme Syntax Extension Packages

Syntactic Closures
==================

  `(require 'syntactic-closures)'

 -- Function: macro:expand EXPRESSION
 -- Function: synclo:expand EXPRESSION
     Returns scheme code with the macros and derived expression types
     of EXPRESSION expanded to primitive expression types.

 -- Function: macro:eval EXPRESSION
 -- Function: synclo:eval EXPRESSION
     `macro:eval' returns the value of EXPRESSION in the current top
     level environment.  EXPRESSION can contain macro definitions.
     Side effects of EXPRESSION will affect the top level environment.

 -- Procedure: macro:load FILENAME
 -- Procedure: synclo:load FILENAME
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions
     and definitions from the file and evaluates them sequentially.
     These source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port' and
     `current-output-port'.


Syntactic Closure Macro Facility
--------------------------------

                 A Syntactic Closures Macro Facility
                           by Chris Hanson
                           9 November 1991

  This document describes "syntactic closures", a low-level macro
facility for the Scheme programming language.  The facility is an
alternative to the low-level macro facility described in the
`Revised^4 Report on Scheme.' This document is an addendum to that
report.

  The syntactic closures facility extends the BNF rule for TRANSFORMER
SPEC to allow a new keyword that introduces a low-level macro
transformer:

     TRANSFORMER SPEC := (transformer EXPRESSION)

  Additionally, the following procedures are added:
     make-syntactic-closure
     capture-syntactic-environment
     identifier?
     identifier=?

  The description of the facility is divided into three parts.  The
first part defines basic terminology.  The second part describes how
macro transformers are defined.  The third part describes the use of
"identifiers", which extend the syntactic closure mechanism to be
compatible with `syntax-rules'.


Terminology
...........

  This section defines the concepts and data types used by the
syntactic closures facility.


   * "Forms" are the syntactic entities out of which programs are
     recursively constructed.  A form is any expression, any
     definition, any syntactic keyword, or any syntactic closure.  The
     variable name that appears in a `set!' special form is also a
     form.  Examples of forms:

          17
          #t
          car
          (+ x 4)
          (lambda (x) x)
          (define pi 3.14159)
          if
          define

   * An "alias" is an alternate name for a given symbol.  It can
     appear anywhere in a form that the symbol could be used, and when
     quoted it is replaced by the symbol; however, it does not satisfy
     the predicate `symbol?'.  Macro transformers rarely distinguish
     symbols from aliases, referring to both as identifiers.

   * A "syntactic" environment maps identifiers to their meanings.
     More precisely, it determines whether an identifier is a
     syntactic keyword or a variable.  If it is a keyword, the meaning
     is an interpretation for the form in which that keyword appears.
     If it is a variable, the meaning identifies which binding of that
     variable is referenced.  In short, syntactic environments contain
     all of the contextual information necessary for interpreting the
     meaning of a particular form.

   * A "syntactic closure" consists of a form, a syntactic
     environment, and a list of identifiers.  All identifiers in the
     form take their meaning from the syntactic environment, except
     those in the given list.  The identifiers in the list are to have
     their meanings determined later.  A syntactic closure may be used
     in any context in which its form could have been used.  Since a
     syntactic closure is also a form, it may not be used in contexts
     where a form would be illegal.  For example, a form may not
     appear as a clause in the cond special form.  A syntactic closure
     appearing in a quoted structure is replaced by its form.



Transformer Definition
......................

  This section describes the `transformer' special form and the
procedures `make-syntactic-closure' and
`capture-syntactic-environment'.

 -- Syntax: transformer EXPRESSION

     Syntax: It is an error if this syntax occurs except as a
     TRANSFORMER SPEC.

     Semantics: The EXPRESSION is evaluated in the standard
     transformer environment to yield a macro transformer as described
     below.  This macro transformer is bound to a macro keyword by the
     special form in which the `transformer' expression appears (for
     example, `let-syntax').

     A "macro transformer" is a procedure that takes two arguments, a
     form and a syntactic environment, and returns a new form.  The
     first argument, the "input form", is the form in which the macro
     keyword occurred.  The second argument, the "usage environment",
     is the syntactic environment in which the input form occurred.
     The result of the transformer, the "output form", is
     automatically closed in the "transformer environment", which is
     the syntactic environment in which the `transformer' expression
     occurred.

     For example, here is a definition of a push macro using
     `syntax-rules':

          (define-syntax  push
            (syntax-rules ()
              ((push item list)
               (set! list (cons item list)))))

     Here is an equivalent definition using `transformer':
          (define-syntax push
            (transformer
             (lambda (exp env)
               (let ((item
                      (make-syntactic-closure env '() (cadr exp)))
                     (list
                      (make-syntactic-closure env '() (caddr exp))))
                 `(set! ,list (cons ,item ,list))))))

     In this example, the identifiers `set!' and `cons' are closed in
     the transformer environment, and thus will not be affected by the
     meanings of those identifiers in the usage environment `env'.

     Some macros may be non-hygienic by design.  For example, the
     following defines a loop macro that implicitly binds `exit' to an
     escape procedure.  The binding of `exit' is intended to capture
     free references to `exit' in the body of the loop, so `exit' must
     be left free when the body is closed:

          (define-syntax loop
            (transformer
             (lambda (exp env)
               (let ((body (cdr exp)))
                 `(call-with-current-continuation
                   (lambda (exit)
                     (let f ()
                       ,@(map (lambda  (exp)
                                 (make-syntactic-closure env '(exit)
                                                         exp))
                               body)
                       (f))))))))

     To assign meanings to the identifiers in a form, use
     `make-syntactic-closure' to close the form in a syntactic
     environment.

 -- Function: make-syntactic-closure ENVIRONMENT FREE-NAMES FORM

     ENVIRONMENT must be a syntactic environment, FREE-NAMES must be a
     list of identifiers, and FORM must be a form.
     `make-syntactic-closure' constructs and returns a syntactic
     closure of FORM in ENVIRONMENT, which can be used anywhere that
     FORM could have been used.  All the identifiers used in FORM,
     except those explicitly excepted by FREE-NAMES, obtain their
     meanings from ENVIRONMENT.

     Here is an example where FREE-NAMES is something other than the
     empty list.  It is instructive to compare the use of FREE-NAMES
     in this example with its use in the `loop' example above: the
     examples are similar except for the source of the identifier
     being left free.
          (define-syntax let1
            (transformer
             (lambda (exp env)
               (let ((id (cadr exp))
                     (init (caddr exp))
                     (exp (cadddr exp)))
                 `((lambda (,id)
                     ,(make-syntactic-closure env (list id) exp))
                   ,(make-syntactic-closure env '() init))))))

     `let1' is a simplified version of `let' that only binds a single
     identifier, and whose body consists of a single expression.  When
     the body expression is syntactically closed in its original
     syntactic environment, the identifier that is to be bound by
     `let1' must be left free, so that it can be properly captured by
     the `lambda' in the output form.

     To obtain a syntactic environment other than the usage
     environment, use `capture-syntactic-environment'.

 -- Function: capture-syntactic-environment PROCEDURE

     `capture-syntactic-environment' returns a form that will, when
     transformed, call PROCEDURE on the current syntactic environment.
     PROCEDURE should compute and return a new form to be transformed,
     in that same syntactic environment, in place of the form.

     An example will make this clear.  Suppose we wanted to define a
     simple `loop-until' keyword equivalent to

          (define-syntax loop-until
            (syntax-rules ()
              ((loop-until id init test return step)
               (letrec ((loop
                         (lambda (id)
                           (if test return (loop step)))))
                 (loop init)))))

     The following attempt at defining `loop-until' has a subtle bug:
          (define-syntax loop-until
            (transformer
             (lambda (exp env)
               (let ((id (cadr exp))
                     (init (caddr exp))
                     (test (cadddr exp))
                     (return (cadddr (cdr exp)))
                     (step (cadddr (cddr exp)))
                     (close
                      (lambda (exp free)
                        (make-syntactic-closure env free exp))))
                 `(letrec ((loop
                            (lambda (,id)
                              (if ,(close test (list id))
                                  ,(close return (list id))
                                  (loop ,(close step (list id)))))))
                    (loop ,(close init '())))))))

     This definition appears to take all of the proper precautions to
     prevent unintended captures.  It carefully closes the
     subexpressions in their original syntactic environment and it
     leaves the `id' identifier free in the `test', `return', and
     `step' expressions, so that it will be captured by the binding
     introduced by the `lambda' expression.  Unfortunately it uses the
     identifiers `if' and `loop' within that `lambda' expression, so
     if the user of `loop-until' just happens to use, say, `if' for
     the identifier, it will be inadvertently captured.

     The syntactic environment that `if' and `loop' want to be exposed
     to is the one just outside the `lambda' expression: before the
     user's identifier is added to the syntactic environment, but
     after the identifier loop has been added.
     `capture-syntactic-environment' captures exactly that environment
     as follows:

          (define-syntax loop-until
            (transformer
             (lambda (exp env)
               (let ((id (cadr exp))
                     (init (caddr exp))
                     (test (cadddr exp))
                     (return (cadddr (cdr exp)))
                     (step (cadddr (cddr exp)))
                     (close
                      (lambda (exp free)
                        (make-syntactic-closure env free exp))))
                 `(letrec ((loop
                            ,(capture-syntactic-environment
                              (lambda (env)
                                `(lambda (,id)
                                   (,(make-syntactic-closure env '() `if)
                                    ,(close test (list id))
                                    ,(close return (list id))
                                    (,(make-syntactic-closure env '()
                                                              `loop)
                                     ,(close step (list id)))))))))
                    (loop ,(close init '())))))))

     In this case, having captured the desired syntactic environment,
     it is convenient to construct syntactic closures of the
     identifiers `if' and the `loop' and use them in the body of the
     `lambda'.

     A common use of `capture-syntactic-environment' is to get the
     transformer environment of a macro transformer:

          (transformer
           (lambda (exp env)
             (capture-syntactic-environment
              (lambda (transformer-env)
                ...))))


Identifiers
...........

  This section describes the procedures that create and manipulate
identifiers.  Previous syntactic closure proposals did not have an
identifier data type -- they just used symbols.  The identifier data
type extends the syntactic closures facility to be compatible with the
high-level `syntax-rules' facility.

  As discussed earlier, an identifier is either a symbol or an
"alias".  An alias is implemented as a syntactic closure whose "form"
is an identifier:

     (make-syntactic-closure env '() 'a)
        => an "alias"

  Aliases are implemented as syntactic closures because they behave
just like syntactic closures most of the time.  The difference is that
an alias may be bound to a new value (for example by `lambda' or
`let-syntax'); other syntactic closures may not be used this way.  If
an alias is bound, then within the scope of that binding it is looked
up in the syntactic environment just like any other identifier.

  Aliases are used in the implementation of the high-level facility
`syntax-rules'.  A macro transformer created by `syntax-rules' uses a
template to generate its output form, substituting subforms of the
input form into the template.  In a syntactic closures implementation,
all of the symbols in the template are replaced by aliases closed in
the transformer environment, while the output form itself is closed in
the usage environment.  This guarantees that the macro transformation
is hygienic, without requiring the transformer to know the syntactic
roles of the substituted input subforms.

 -- Function: identifier? OBJECT
     Returns `#t' if OBJECT is an identifier, otherwise returns `#f'.
     Examples:

          (identifier? 'a)
             => #t
          (identifier? (make-syntactic-closure env '() 'a))
             => #t
          (identifier? "a")
             => #f
          (identifier? #\a)
             => #f
          (identifier? 97)
             => #f
          (identifier? #f)
             => #f
          (identifier? '(a))
             => #f
          (identifier? '#(a))
             => #f

     The predicate `eq?' is used to determine if two identifers are
     "the same".  Thus `eq?' can be used to compare identifiers
     exactly as it would be used to compare symbols.  Often, though,
     it is useful to know whether two identifiers "mean the same
     thing".  For example, the `cond' macro uses the symbol `else' to
     identify the final clause in the conditional.  A macro
     transformer for `cond' cannot just look for the symbol `else',
     because the `cond' form might be the output of another macro
     transformer that replaced the symbol `else' with an alias.
     Instead the transformer must look for an identifier that "means
     the same thing" in the usage environment as the symbol `else'
     means in the transformer environment.

 -- Function: identifier=? ENVIRONMENT1 IDENTIFIER1 ENVIRONMENT2 IDENTIFIER2
     ENVIRONMENT1 and ENVIRONMENT2 must be syntactic environments, and
     IDENTIFIER1 and IDENTIFIER2 must be identifiers.  `identifier=?'
     returns `#t' if the meaning of IDENTIFIER1 in ENVIRONMENT1 is the
     same as that of IDENTIFIER2 in ENVIRONMENT2, otherwise it returns
     `#f'.  Examples:

          (let-syntax
              ((foo
                (transformer
                 (lambda (form env)
                   (capture-syntactic-environment
                    (lambda (transformer-env)
                      (identifier=? transformer-env 'x env 'x)))))))
            (list (foo)
                  (let ((x 3))
                    (foo))))
             => (#t #f)

          (let-syntax ((bar foo))
            (let-syntax
                ((foo
                  (transformer
                   (lambda (form env)
                     (capture-syntactic-environment
                      (lambda (transformer-env)
                        (identifier=? transformer-env 'foo
                                      env (cadr form))))))))
              (list (foo foo)
                    (foobar))))
             => (#f #t)


Acknowledgements
................

  The syntactic closures facility was invented by Alan Bawden and
Jonathan Rees.  The use of aliases to implement `syntax-rules' was
invented by Alan Bawden (who prefers to call them "synthetic names").
Much of this proposal is derived from an earlier proposal by Alan
Bawden.







File: slib.info, Node: Syntax-Case Macros, Next: Fluid-Let, Prev: Syntactic Closures, Up: Scheme Syntax Extension Packages

Syntax-Case Macros
==================

  `(require 'syntax-case)'

 -- Function: macro:expand EXPRESSION
 -- Function: syncase:expand EXPRESSION
     Returns scheme code with the macros and derived expression types
     of EXPRESSION expanded to primitive expression types.

 -- Function: macro:eval EXPRESSION
 -- Function: syncase:eval EXPRESSION
     `macro:eval' returns the value of EXPRESSION in the current top
     level environment.  EXPRESSION can contain macro definitions.
     Side effects of EXPRESSION will affect the top level environment.

 -- Procedure: macro:load FILENAME
 -- Procedure: syncase:load FILENAME
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions
     and definitions from the file and evaluates them sequentially.
     These source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port' and
     `current-output-port'.

  This is version 2.1 of `syntax-case', the low-level macro facility
proposed and implemented by Robert Hieb and R. Kent Dybvig.

  This version is further adapted by Harald Hanche-Olsen <hanche @
imf.unit.no> to make it compatible with, and easily usable with, SLIB.
Mainly, these adaptations consisted of:

   * Removing white space from `expand.pp' to save space in the
     distribution.  This file is not meant for human readers anyway...

   * Removed a couple of Chez scheme dependencies.

   * Renamed global variables used to minimize the possibility of name
     conflicts.

   * Adding an SLIB-specific initialization file.

   * Removing a couple extra files, most notably the documentation
     (but see below).

  If you wish, you can see exactly what changes were done by reading
the shell script in the file `syncase.sh'.

  The two PostScript files were omitted in order to not burden the
SLIB distribution with them.  If you do intend to use `syntax-case',
however, you should get these files and print them out on a PostScript
printer.  They are available with the original `syntax-case'
distribution by anonymous FTP in
`cs.indiana.edu:/pub/scheme/syntax-case'.

  In order to use syntax-case from an interactive top level, execute:
(require 'syntax-case) (require 'repl) (repl:top-level macro:eval) See
the section Repl (*Note Repl::) for more information.

  To check operation of syntax-case get
`cs.indiana.edu:/pub/scheme/syntax-case', and type
     (require 'syntax-case)
     (syncase:sanity-check)

  Beware that `syntax-case' takes a long time to load -- about 20s on
a SPARCstation SLC (with SCM) and about 90s on a Macintosh SE/30 (with
Gambit).


Notes
-----

  All R4RS syntactic forms are defined, including `delay'.  Along with
`delay' are simple definitions for `make-promise' (into which `delay'
expressions expand) and `force'.

  `syntax-rules' and `with-syntax' (described in `TR356') are defined.

  `syntax-case' is actually defined as a macro that expands into calls
to the procedure `syntax-dispatch' and the core form `syntax-lambda';
do not redefine these names.

  Several other top-level bindings not documented in TR356 are
created:
   * the "hooks" in `hooks.ss'
   * the `build-' procedures in `output.ss'
   * `expand-syntax' (the expander)

  The syntax of define has been extended to allow `(define ID)', which
assigns ID to some unspecified value.

  We have attempted to maintain R4RS compatibility where possible.
The incompatibilities should be confined to `hooks.ss'.  Please let us
know if there is some incompatibility that is not flagged as such.

  Send bug reports, comments, suggestions, and questions to Kent
Dybvig (dyb @ iuvax.cs.indiana.edu).


Note from SLIB maintainer
-------------------------

  `(require 'structure)'

  Included with the `syntax-case' files was `structure.scm' which
defines a macro `define-structure'.  I have no documentation for this
macro; it is not used by any other code in SLIB.




File: slib.info, Node: Fluid-Let, Next: Yasos, Prev: Syntax-Case Macros, Up: Scheme Syntax Extension Packages

Fluid-Let
=========

  `(require 'fluid-let)'

 -- Syntax: fluid-let `(BINDINGS ...)' FORMS...
     (fluid-let ((VARIABLE INIT) ...)
        EXPRESSION EXPRESSION ...)

  The INITs are evaluated in the current environment (in some
unspecified order), the current values of the VARIABLEs are saved, the
results are assigned to the VARIABLEs, the EXPRESSIONs are evaluated
sequentially in the current environment, the VARIABLEs are restored to
their original values, and the value of the last EXPRESSION is
returned.

  The syntax of this special form is similar to that of `let', but
`fluid-let' temporarily rebinds existing VARIABLEs.  Unlike `let',
`fluid-let' creates no new bindings; instead it *assigns* the values
of each INIT to the binding (determined by the rules of lexical
scoping) of its corresponding VARIABLE.




File: slib.info, Node: Yasos, Prev: Fluid-Let, Up: Scheme Syntax Extension Packages

Yasos
=====


  `(require 'oop)' or `(require 'yasos)'

  `Yet Another Scheme Object System' is a simple object system for
Scheme based on the paper by Norman Adams and Jonathan Rees: `Object
Oriented Programming in Scheme', Proceedings of the 1988 ACM
Conference on LISP and Functional Programming, July 1988 [ACM
#552880].

  Another reference is:

  Ken Dickey.  <A
HREF="ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/swob.txt">
Scheming with Objects </A> `AI Expert' Volume 7, Number 10 (October
1992), pp. 24-33.

* Menu:

* Yasos terms::                 Definitions and disclaimer.
* Yasos interface::             The Yasos macros and procedures.
* Setters::                     Dylan-like setters in Yasos.
* Yasos examples::              Usage of Yasos and setters.



File: slib.info, Node: Yasos terms, Next: Yasos interface, Prev: Yasos, Up: Yasos

Terms
-----

"Object"
     Any Scheme data object.

"Instance"
     An instance of the OO system; an "object".

"Operation"
     A METHOD.

*Notes:*
     The object system supports multiple inheritance.  An instance can
     inherit from 0 or more ancestors.  In the case of multiple
     inherited operations with the same identity, the operation used
     is that from the first ancestor which contains it (in the
     ancestor `let').  An operation may be applied to any Scheme data
     object--not just instances.  As code which creates instances is
     just code, there are no "classes" and no meta-ANYTHING.  Method
     dispatch is by a procedure call a la CLOS rather than by `send'
     syntax a la Smalltalk.

*Disclaimer:*
     There are a number of optimizations which can be made.  This
     implementation is expository (although performance should be
     quite reasonable).  See the L&FP paper for some suggestions.







File: slib.info, Node: Yasos interface, Next: Setters, Prev: Yasos terms, Up: Yasos

Interface
---------

 -- Syntax: define-operation `('OPNAME SELF ARG ...`)' DEFAULT-BODY
     Defines a default behavior for data objects which don't handle
     the operation OPNAME.  The default behavior (for an empty
     DEFAULT-BODY) is to generate an error.

 -- Syntax: define-predicate OPNAME?
     Defines a predicate OPNAME?, usually used for determining the
     "type" of an object, such that `(OPNAME? OBJECT)' returns `#t' if
     OBJECT has an operation OPNAME? and `#f' otherwise.

 -- Syntax: object `((NAME SELF ARG ...) BODY)' ...
     Returns an object (an instance of the object system) with
     operations.  Invoking `(NAME OBJECT ARG ...' executes the BODY of
     the OBJECT with SELF bound to OBJECT and with argument(s) ARG....

 -- Syntax: object-with-ancestors `(('ANCESTOR1 INIT1`)' ...`)' OPERATION ...
     A `let'-like form of `object' for multiple inheritance.  It
     returns an object inheriting the behaviour of ANCESTOR1 etc.  An
     operation will be invoked in an ancestor if the object itself
     does not provide such a method.  In the case of multiple
     inherited operations with the same identity, the operation used
     is the one found in the first ancestor in the ancestor list.

 -- Syntax: operate-as COMPONENT OPERATION SELF ARG ...
     Used in an operation definition (of SELF) to invoke the OPERATION
     in an ancestor COMPONENT but maintain the object's identity.
     Also known as "send-to-super".

 -- Procedure: print OBJ PORT
     A default `print' operation is provided which is just `(format
     PORT OBJ)' (*Note Format::) for non-instances and prints OBJ
     preceded by `#<INSTANCE>' for instances.

 -- Function: size OBJ
     The default method returns the number of elements in OBJ if it is
     a vector, string or list, `2' for a pair, `1' for a character and
     by default id an error otherwise.  Objects such as collections
     (*Note Collections::) may override the default in an obvious way.







File: slib.info, Node: Setters, Next: Yasos examples, Prev: Yasos interface, Up: Yasos

Setters
-------

  "Setters" implement "generalized locations" for objects associated
with some sort of mutable state.  A "getter" operation retrieves a
value from a generalized location and the corresponding setter
operation stores a value into the location.  Only the getter is named
-- the setter is specified by a procedure call as below.  (Dylan uses
special syntax.)  Typically, but not necessarily, getters are access
operations to extract values from Yasos objects (*Note Yasos::).
Several setters are predefined, corresponding to getters `car', `cdr',
`string-ref' and `vector-ref' e.g., `(setter car)' is equivalent to
`set-car!'.

  This implementation of setters is similar to that in Dylan(TM)
(`Dylan: An object-oriented dynamic language', Apple Computer Eastern
Research and Technology).  Common LISP provides similar facilities
through `setf'.

 -- Function: setter GETTER
     Returns the setter for the procedure GETTER.  E.g., since
     `string-ref' is the getter corresponding to a setter which is
     actually `string-set!':
          (define foo "foo")
          ((setter string-ref) foo 0 #\F) ; set element 0 of foo
          foo => "Foo"

 -- Syntax: set PLACE NEW-VALUE
     If PLACE is a variable name, `set' is equivalent to `set!'.
     Otherwise, PLACE must have the form of a procedure call, where
     the procedure name refers to a getter and the call indicates an
     accessible generalized location, i.e., the call would return a
     value.  The return value of `set' is usually unspecified unless
     used with a setter whose definition guarantees to return a useful
     value.
          (set (string-ref foo 2) #\O)  ; generalized location with getter
          foo => "FoO"
          (set foo "foo")               ; like set!
          foo => "foo"

 -- Procedure: add-setter GETTER SETTER
     Add procedures GETTER and SETTER to the (inaccessible) list of
     valid setter/getter pairs.  SETTER implements the store operation
     corresponding to the GETTER access operation for the relevant
     state.  The return value is unspecified.

 -- Procedure: remove-setter-for GETTER
     Removes the setter corresponding to the specified GETTER from the
     list of valid setters.  The return value is unspecified.

 -- Syntax: define-access-operation GETTER-NAME
     Shorthand for a Yasos `define-operation' defining an operation
     GETTER-NAME that objects may support to return the value of some
     mutable state.  The default operation is to signal an error.  The
     return value is unspecified.







File: slib.info, Node: Yasos examples, Prev: Setters, Up: Yasos

Examples
--------

     ;;; These definitions for PRINT and SIZE are
     ;;; already supplied by
     (require 'yasos)

     (define-operation (print obj port)
       (format port
               (if (instance? obj) "#<instance>" "~s")
               obj))

     (define-operation (size obj)
       (cond
        ((vector? obj) (vector-length obj))
        ((list?   obj) (length obj))
        ((pair?   obj) 2)
        ((string? obj) (string-length obj))
        ((char?   obj) 1)
        (else
         (slib:error "Operation not supported: size" obj))))

     (define-predicate cell?)
     (define-operation (fetch obj))
     (define-operation (store! obj newValue))

     (define (make-cell value)
       (object
        ((cell? self) #t)
        ((fetch self) value)
        ((store! self newValue)
         (set! value newValue)
         newValue)
        ((size self) 1)
        ((print self port)
         (format port "#<Cell: ~s>" (fetch self)))))

     (define-operation (discard obj value)
       (format #t "Discarding ~s~%" value))

     (define (make-filtered-cell value filter)
       (object-with-ancestors
        ((cell (make-cell value)))
        ((store! self newValue)
        (if (filter newValue)
            (store! cell newValue)
            (discard self newValue)))))

     (define-predicate array?)
     (define-operation (array-ref array index))
     (define-operation (array-set! array index value))

     (define (make-array num-slots)
       (let ((anArray (make-vector num-slots)))
         (object
          ((array? self) #t)
          ((size self) num-slots)
          ((array-ref self index)
           (vector-ref  anArray index))
          ((array-set! self index newValue)
           (vector-set! anArray index newValue))
          ((print self port)
           (format port "#<Array ~s>" (size self))))))

     (define-operation (position obj))
     (define-operation (discarded-value obj))

     (define (make-cell-with-history value filter size)
       (let ((pos 0) (most-recent-discard #f))
         (object-with-ancestors
          ((cell (make-filtered-call value filter))
           (sequence (make-array size)))
          ((array? self) #f)
          ((position self) pos)
          ((store! self newValue)
           (operate-as cell store! self newValue)
           (array-set! self pos newValue)
           (set! pos (+ pos 1)))
          ((discard self value)
           (set! most-recent-discard value))
          ((discarded-value self) most-recent-discard)
          ((print self port)
           (format port "#<Cell-with-history ~s>"
                   (fetch self))))))

     (define-access-operation fetch)
     (add-setter fetch store!)
     (define foo (make-cell 1))
     (print foo #f)
     => "#<Cell: 1>"
     (set (fetch foo) 2)
     =>
     (print foo #f)
     => "#<Cell: 2>"
     (fetch foo)
     => 2



File: slib.info, Node: Textual Conversion Packages, Next: Mathematical Packages, Prev: Scheme Syntax Extension Packages, Up: Top

Textual Conversion Packages
***************************

* Menu:

* Precedence Parsing::          
* Format::                      Common-Lisp Format
* Standard Formatted I/O::      Posix printf and scanf
* Programs and Arguments::      
* HTML::                        Generating
* HTML Tables::                 Databases meet HTML
* HTTP and CGI::                Serve WWW sites
* Parsing HTML::                'html-for-each
* URI::                         Uniform Resource Identifier
* Printing Scheme::             Nicely
* Time and Date::               
* NCBI-DNA::                    DNA and protein sequences
* Schmooz::                     Documentation markup for Scheme programs




File: slib.info, Node: Precedence Parsing, Next: Format, Prev: Textual Conversion Packages, Up: Textual Conversion Packages

Precedence Parsing
==================

  `(require 'precedence-parse)' or `(require 'parse)'

This package implements:

   * a Pratt style precedence parser;
   * a "tokenizer" which congeals tokens according to assigned classes
     of constituent characters;
   * procedures giving direct control of parser rulesets;
   * procedures for higher level specification of rulesets.

* Menu:

* Precedence Parsing Overview::  
* Rule Types::                  
* Ruleset Definition and Use::  
* Token definition::            
* Nud and Led Definition::      
* Grammar Rule Definition::     



File: slib.info, Node: Precedence Parsing Overview, Next: Rule Types, Prev: Precedence Parsing, Up: Precedence Parsing

Precedence Parsing Overview
---------------------------

This package offers improvements over previous parsers.

   * Common computer language constructs are concisely specified.
   * Grammars can be changed dynamically.  Operators can be assigned
     different meanings within a lexical context.
   * Rulesets don't need compilation.  Grammars can be changed
     incrementally.
   * Operator precedence is specified by integers.
   * All possibilities of bad input are handled (1) (*Note Precedence
     Parsing Overview-Footnotes::) and return as much structure as was
     parsed when the error occured; The symbol `?' is substituted for
     missing input.

The notion of "binding power" may be unfamiliar to those accustomed to
BNF grammars.

When two consecutive objects are parsed, the first might be the prefix
to the second, or the second might be a suffix of the first.
Comparing the left and right binding powers of the two objects decides
which way to interpret them.

Objects at each level of syntactic grouping have binding powers.

A syntax tree is not built unless the rules explicitly do so.  The
call graph of grammar rules effectively instantiate the sytnax tree.

The JACAL symbolic math system
(`http://swissnet.ai.mit.edu/~jaffer/JACAL.html') uses
precedence-parse.  Its grammar definitions in the file
`jacal/English.scm' can serve as examples of use.



File: slib.info  Node: Precedence Parsing Overview-Footnotes, Up: Precedence Parsing Overview

(1) How do I know this?
I parsed 250kbyte of random input (an e-mail file) with a
non-trivial grammar utilizing all constructs.



File: slib.info, Node: Rule Types, Next: Ruleset Definition and Use, Prev: Precedence Parsing Overview, Up: Precedence Parsing

Rule Types
----------

Here are the higher-level syntax types and an example of each.
Precedence considerations are omitted for clarity.  See *Note Grammar
Rule Definition:: for full details.
 -- Grammar: nofix bye exit
          bye calls the function `exit' with no arguments.
 -- Grammar: prefix - negate
          - 42 Calls the function `negate' with the argument `42'.
 -- Grammar: infix - difference
          x - y Calls the function `difference' with arguments `x' and
     `y'.
 -- Grammar: nary + sum
          x + y + z Calls the function `sum' with arguments `x', `y',
     and `y'.
 -- Grammar: postfix ! factorial
          5 !  Calls the function `factorial' with the argument `5'.
 -- Grammar: prestfix set set!
          set foo bar Calls the function `set!' with the arguments
     `foo' and `bar'.
 -- Grammar: commentfix /* */
          /* almost any text here */ Ignores the comment delimited by
     `/*' and `*/'.
 -- Grammar: matchfix  list 
          {0, 1, 2} Calls the function `list' with the arguments `0',
     `1', and `2'.
 -- Grammar: inmatchfix ( funcall )
          f(x, y) Calls the function `funcall' with the arguments `f',
     `x', and `y'.
 -- Grammar: delim ;
          set foo bar; delimits the extent of the restfix operator
     `set'.




File: slib.info, Node: Ruleset Definition and Use, Next: Token definition, Prev: Rule Types, Up: Precedence Parsing

Ruleset Definition and Use
--------------------------

 -- Variable: *syn-defs*
     A grammar is built by one or more calls to `prec:define-grammar'.
     The rules are appended to *SYN-DEFS*.  The value of *SYN-DEFS* is
     the grammar suitable for passing as an argument to `prec:parse'.

 -- Constant: *syn-ignore-whitespace*
     Is a nearly empty grammar with whitespace characters set to group
     0, which means they will not be made into tokens.  Most rulesets
     will want to start with `*syn-ignore-whitespace*'

In order to start defining a grammar, either

     (set! *syn-defs* '()) or

     (set! *syn-defs* *syn-ignore-whitespace*)

 -- Function: prec:define-grammar RULE1 ...
     Appends RULE1 ... to *SYN-DEFS*.  `prec:define-grammar' is used
     to define both the character classes and rules for tokens.

Once your grammar is defined, save the value of `*syn-defs*' in a
variable (for use when calling `prec:parse').

     (define my-ruleset *syn-defs*)

 -- Function: prec:parse RULESET DELIM
 -- Function: prec:parse RULESET DELIM PORT
     The RULESET argument must be a list of rules as constructed by
     `prec:define-grammar' and extracted from *SYN-DEFS*.

     The token DELIM may be a character, symbol, or string.  A
     character DELIM argument will match only a character token;
     i.e. a character for which no token-group is assigned.  A symbols
     or string will match only a token string; i.e. a token resulting
     from a token group.

     `prec:parse' reads a RULESET grammar expression delimited by
     DELIM from the given input PORT.  `prec:parse' returns the next
     object parsable from the given input PORT, updating PORT to point
     to the first character past the end of the external
     representation of the object.

     If an end of file is encountered in the input before any
     characters are found that can begin an object, then an end of
     file object is returned.  If a delimiter (such as DELIM) is found
     before any characters are found that can begin an object, then
     `#f' is returned.

     The PORT argument may be omitted, in which case it defaults to
     the value returned by `current-input-port'.  It is an error to
     parse from a closed port.



File: slib.info, Node: Token definition, Next: Nud and Led Definition, Prev: Ruleset Definition and Use, Up: Precedence Parsing

Token definition
----------------

 -- Function: tok:char-group GROUP CHARS CHARS-PROC
     The argument CHARS may be a single character, a list of
     characters, or a string.  Each character in CHARS is treated as
     though `tok:char-group' was called with that character alone.

     The argument CHARS-PROC must be a procedure of one argument, a
     list of characters.  After `tokenize' has finished accumulating
     the characters for a token, it calls CHARS-PROC with the list of
     characters.  The value returned is the token which `tokenize'
     returns.

     The argument GROUP may be an exact integer or a procedure of one
     character argument.  The following discussion concerns the
     treatment which the tokenizing routine, `tokenize', will accord
     to characters on the basis of their groups.

     When GROUP is a non-zero integer, characters whose group number
     is equal to or exactly one less than GROUP will continue to
     accumulate.  Any other character causes the accumulation to stop
     (until a new token is to be read).

     The GROUP of zero is special.  These characters are ignored when
     parsed pending a token, and stop the accumulation of token
     characters when the accumulation has already begun.  Whitespace
     characters are usually put in group 0.

     If GROUP is a procedure, then, when triggerd by the occurence of
     an initial (no accumulation) CHARS character, this procedure will
     be repeatedly called with each successive character from the
     input stream until the GROUP procedure returns a non-false value.

The following convenient constants are provided for use with
`tok:char-group'.

 -- Constant: tok:decimal-digits
     Is the string `"0123456789"'.
 -- Constant: tok:upper-case
     Is the string consisting of all upper-case letters
     ("ABCDEFGHIJKLMNOPQRSTUVWXYZ").
 -- Constant: tok:lower-case
     Is the string consisting of all lower-case letters
     ("abcdefghijklmnopqrstuvwxyz").
 -- Constant: tok:whitespaces
     Is the string consisting of all characters between 0 and 255 for
     which `char-whitespace?' returns true.

For the purpose of reporting problems in error messages, this package
keeps track of the "current column".  When the column does not simply
track input characters, `tok:bump-column' can be used to adjust the
current-column.

 -- Function: tok:bump-column POS PORT
     Adds POS to the current-column for input-port PORT.




File: slib.info, Node: Nud and Led Definition, Next: Grammar Rule Definition, Prev: Token definition, Up: Precedence Parsing

Nud and Led Definition
----------------------

  This section describes advanced features.  You can skip this section
on first reading.

  The "Null Denotation" (or "nud") of a token is the procedure and
arguments applying for that token when "Left", an unclaimed parsed
expression is not extant.

  The "Left Denotation" (or "led") of a token is the procedure,
arguments, and lbp applying for that token when there is a "Left", an
unclaimed parsed expression.

In his paper,

     Pratt, V. R.  Top Down Operator Precendence.  `SIGACT/SIGPLAN
     Symposium on Principles of Programming Languages', Boston, 1973,
     pages 41-51

  the "left binding power" (or "lbp") was an independent property of
tokens.  I think this was done in order to allow tokens with NUDs but
not LEDs to also be used as delimiters, which was a problem for
statically defined syntaxes.  It turns out that *dynamically binding*
NUDs and LEDs allows them independence.

For the rule-defining procedures that follow, the variable TK may be a
character, string, or symbol, or a list composed of characters,
strings, and symbols.  Each element of TK is treated as though the
procedure were called for each element.

Character TK arguments will match only character tokens;
i.e. characters for which no token-group is assigned.  Symbols and
strings will both match token strings; i.e. tokens resulting from
token groups.

 -- Function: prec:make-nud TK SOP ARG1 ...
     Returns a rule specifying that SOP be called when TK is parsed.
     If SOP is a procedure, it is called with TK and ARG1 ... as its
     arguments; the resulting value is incorporated into the
     expression being built.  Otherwise, `(list SOP ARG1 ...)' is
     incorporated.

If no NUD has been defined for a token; then if that token is a
string, it is converted to a symbol and returned; if not a string, the
token is returned.

 -- Function: prec:make-led TK SOP ARG1 ...
     Returns a rule specifying that SOP be called when TK is
     parsed and LEFT has an unclaimed parsed expression.  If SOP
     is a procedure, it is called with LEFT, TK, and ARG1
     ... as its arguments; the resulting value is incorporated into the
     expression being built.  Otherwise, LEFT is incorporated.

If no LED has been defined for a token, and LEFT is set, the parser
issues a warning.



File: slib.info, Node: Grammar Rule Definition, Prev: Nud and Led Definition, Up: Precedence Parsing

Grammar Rule Definition
-----------------------

Here are procedures for defining rules for the syntax types introduced
in *Note Precedence Parsing Overview::.

For the rule-defining procedures that follow, the variable TK may be a
character, string, or symbol, or a list composed of characters,
strings, and symbols.  Each element of TK is treated as though the
procedure were called for each element.

For procedures prec:delim, ..., prec:prestfix, if the SOP argument is
`#f', then the token which triggered this rule is converted to a
symbol and returned.  A false SOP argument to the procedures
prec:commentfix, prec:matchfix, or prec:inmatchfix has a different
meaning.

Character TK arguments will match only character tokens;
i.e. characters for which no token-group is assigned.  Symbols and
strings will both match token strings; i.e. tokens resulting from
token groups.

 -- Function: prec:delim TK
     Returns a rule specifying that TK should not be returned from
     parsing; i.e. TK's function is purely syntactic.  The end-of-file
     is always treated as a delimiter.

 -- Function: prec:nofix TK SOP
     Returns a rule specifying the following actions take place when
     TK is parsed:
        * If SOP is a procedure, it is called with no arguments; the
          resulting value is incorporated into the expression being
          built.  Otherwise, the list of SOP is incorporated.

 -- Function: prec:prefix TK SOP BP RULE1 ...
     Returns a rule specifying the following actions take place when
     TK is parsed:
        * The rules RULE1 ... augment and, in case of conflict,
          override rules currently in effect.
        * `prec:parse1' is called with binding-power BP.
        * If SOP is a procedure, it is called with the expression
          returned from `prec:parse1'; the resulting value is
          incorporated into the expression being built.  Otherwise,
          the list of SOP and the expression returned from
          `prec:parse1' is incorporated.
        * The ruleset in effect before TK was parsed is restored;
          RULE1 ... are forgotten.

 -- Function: prec:infix TK SOP LBP BP RULE1 ...
     Returns a rule declaring the left-binding-precedence of the token
     TK is LBP and specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict,
          override rules currently in effect.
        * One expression is parsed with binding-power LBP.  If instead
          a delimiter is encountered, a warning is issued.
        * If SOP is a procedure, it is applied to the list of LEFT and
          the parsed expression; the resulting value is incorporated
          into the expression being built.  Otherwise, the list of
          SOP, the LEFT expression, and the parsed expression is
          incorporated.
        * The ruleset in effect before TK was parsed is restored;
          RULE1 ... are forgotten.

 -- Function: prec:nary TK SOP BP
     Returns a rule declaring the left-binding-precedence of the token
     TK is BP and specifying the following actions take place when TK
     is parsed:
        * Expressions are parsed with binding-power BP as far as they
          are interleaved with the token TK.
        * If SOP is a procedure, it is applied to the list of LEFT and
          the parsed expressions; the resulting value is incorporated
          into the expression being built.  Otherwise, the list of
          SOP, the LEFT expression, and the parsed expressions is
          incorporated.

 -- Function: prec:postfix TK SOP LBP
     Returns a rule declaring the left-binding-precedence of the token
     TK is LBP and specifying the following actions take place when TK
     is parsed:
        * If SOP is a procedure, it is called with the LEFT
          expression; the resulting value is incorporated into the
          expression being built.  Otherwise, the list of SOP and the
          LEFT expression is incorporated.

 -- Function: prec:prestfix TK SOP BP RULE1 ...
     Returns a rule specifying the following actions take place when
     TK is parsed:
        * The rules RULE1 ... augment and, in case of conflict,
          override rules currently in effect.
        * Expressions are parsed with binding-power BP until a
          delimiter is reached.
        * If SOP is a procedure, it is applied to the list of parsed
          expressions; the resulting value is incorporated into the
          expression being built.  Otherwise, the list of SOP and the
          parsed expressions is incorporated.
        * The ruleset in effect before TK was parsed is restored;
          RULE1 ... are forgotten.

 -- Function: prec:commentfix TK STP MATCH RULE1 ...
     Returns rules specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict,
          override rules currently in effect.
        * Characters are read until and end-of-file or a sequence of
          characters is read which matches the *string* MATCH.
        * If STP is a procedure, it is called with the string of all
          that was read between the TK and MATCH (exclusive).
        * The ruleset in effect before TK was parsed is restored;
          RULE1 ... are forgotten.

     Parsing of commentfix syntax differs from the others in several
     ways.  It reads directly from input without tokenizing; It calls
     STP but does not return its value; nay any value.  I added the
     STP argument so that comment text could be echoed.

 -- Function: prec:matchfix TK SOP SEP MATCH RULE1 ...
     Returns a rule specifying the following actions take place when
     TK is parsed:
        * The rules RULE1 ... augment and, in case of conflict,
          override rules currently in effect.
        * A rule declaring the token MATCH a delimiter takes effect.
        * Expressions are parsed with binding-power `0' until the
          token MATCH is reached.  If the token SEP does not appear
          between each pair of expressions parsed, a warning is
          issued.
        * If SOP is a procedure, it is applied to the list of parsed
          expressions; the resulting value is incorporated into the
          expression being built.  Otherwise, the list of SOP and the
          parsed expressions is incorporated.
        * The ruleset in effect before TK was parsed is restored;
          RULE1 ... are forgotten.

 -- Function: prec:inmatchfix TK SOP SEP MATCH LBP RULE1 ...
     Returns a rule declaring the left-binding-precedence of the token
     TK is LBP and specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict,
          override rules currently in effect.
        * A rule declaring the token MATCH a delimiter takes effect.
        * Expressions are parsed with binding-power `0' until the
          token MATCH is reached.  If the token SEP does not appear
          between each pair of expressions parsed, a warning is
          issued.
        * If SOP is a procedure, it is applied to the list of LEFT and
          the parsed expressions; the resulting value is incorporated
          into the expression being built.  Otherwise, the list of
          SOP, the LEFT expression, and the parsed expressions is
          incorporated.
        * The ruleset in effect before TK was parsed is restored;
          RULE1 ... are forgotten.




File: slib.info, Node: Format, Next: Standard Formatted I/O, Prev: Precedence Parsing, Up: Textual Conversion Packages

Format (version 3.0)
====================

  <A NAME="format"></A>

  The `format.scm' package was removed because it was not reentrant.
`http://swissnet.ai.mit.edu/~jaffer/SLIB.FAQ' explains more about
FORMAT's woes.




File: slib.info, Node: Standard Formatted I/O, Next: Programs and Arguments, Prev: Format, Up: Textual Conversion Packages

Standard Formatted I/O
======================

* Menu:

* Standard Formatted Output::   'printf
* Standard Formatted Input::    'scanf


stdio
-----

  `(require 'stdio)'

  `require's `printf' and `scanf' and additionally defines the
symbols:

 -- Variable: stdin
     Defined to be `(current-input-port)'.
 -- Variable: stdout
     Defined to be `(current-output-port)'.
 -- Variable: stderr
     Defined to be `(current-error-port)'.




File: slib.info, Node: Standard Formatted Output, Next: Standard Formatted Input, Prev: Standard Formatted I/O, Up: Standard Formatted I/O

Standard Formatted Output
-------------------------

  <A NAME="printf"></A> `(require 'printf)'

 -- Procedure: printf FORMAT ARG1 ...
 -- Procedure: fprintf PORT FORMAT ARG1 ...
 -- Procedure: sprintf STR FORMAT ARG1 ...
 -- Procedure: sprintf #F FORMAT ARG1 ...
 -- Procedure: sprintf K FORMAT ARG1 ...

     Each function converts, formats, and outputs its ARG1 ...
     arguments according to the control string FORMAT argument and
     returns the number of characters output.

     `printf' sends its output to the port `(current-output-port)'.
     `fprintf' sends its output to the port PORT.  `sprintf'
     `string-set!'s locations of the non-constant string argument STR
     to the output characters.

     Two extensions of `sprintf' return new strings.  If the first
     argument is `#f', then the returned string's length is as many
     characters as specified by the FORMAT and data; if the first
     argument is a non-negative integer K, then the length of the
     returned string is also bounded by K.

     The string FORMAT contains plain characters which are copied to
     the output stream, and conversion specifications, each of which results
     in fetching zero or more of the arguments ARG1 ....  The
     results are undefined if there are an insufficient number of arguments
     for the format.  If FORMAT is exhausted while some of the
     ARG1 ... arguments remain unused, the excess ARG1
     ... arguments are ignored.

     The conversion specifications in a format string have the form:

          % [ FLAGS ] [ WIDTH ] [ . PRECISION ] [ TYPE ] CONVERSION

     An output conversion specifications consist of an initial `%'
     character followed in sequence by:

        * Zero or more "flag characters" that modify the normal
          behavior of the conversion specification.

          `-'
               Left-justify the result in the field.  Normally the
               result is right-justified.

          `+'
               For the signed `%d' and `%i' conversions and all
               inexact conversions, prefix a plus sign if the value is
               positive.

          ` '
               For the signed `%d' and `%i' conversions, if the result
               doesn't start with a plus or minus sign, prefix it with
               a space character instead.  Since the `+' flag ensures
               that the result includes a sign, this flag is ignored
               if both are specified.

          `#'
               For inexact conversions, `#' specifies that the result
               should always include a decimal point, even if no
               digits follow it.  For the `%g' and `%G' conversions,
               this also forces trailing zeros after the decimal point
               to be printed where they would otherwise be elided.

               For the `%o' conversion, force the leading digit to be
               `0', as if by increasing the precision.  For `%x' or
               `%X', prefix a leading `0x' or `0X' (respectively) to
               the result.  This doesn't do anything useful for the
               `%d', `%i', or `%u' conversions.  Using this flag
               produces output which can be parsed by the `scanf'
               functions with the `%i' conversion (*Note Standard
               Formatted Input::).


          `0'
               Pad the field with zeros instead of spaces.  The zeros
               are placed after any indication of sign or base.  This
               flag is ignored if the `-' flag is also specified, or
               if a precision is specified for an exact converson.

        * An optional decimal integer specifying the "minimum field
          width".  If the normal conversion produces fewer characters
          than this, the field is padded (with spaces or zeros per the
          `0' flag) to the specified width.  This is a *minimum*
          width; if the normal conversion produces more characters
          than this, the field is *not* truncated.

          Alternatively, if the field width is `*', the next argument
          in the argument list (before the actual value to be printed)
          is used as the field width.  The width value must be an
          integer.  If the value is negative it is as though the `-'
          flag is set (see above) and the absolute value is used as
          the field width.

        * An optional "precision" to specify the number of digits to
          be written for numeric conversions and the maximum field
          width for string conversions.  The precision is specified by
          a period (`.') followed optionally by a decimal integer
          (which defaults to zero if omitted).

          Alternatively, if the precision is `.*', the next argument
          in the argument list (before the actual value to be printed)
          is used as the precision.  The value must be an integer, and
          is ignored if negative.  If you specify `*' for both the
          field width and precision, the field width argument precedes
          the precision argument.  The `.*' precision is an
          enhancement.  C library versions may not accept this syntax.

          For the `%f', `%e', and `%E' conversions, the precision
          specifies how many digits follow the decimal-point
          character.  The default precision is `6'.  If the precision
          is explicitly `0', the decimal point character is
          suppressed.

          For the `%g' and `%G' conversions, the precision specifies
          how many significant digits to print.  Significant digits
          are the first digit before the decimal point, and all the
          digits after it.  If the precision is `0' or not specified
          for `%g' or `%G', it is treated like a value of `1'.  If the
          value being printed cannot be expressed accurately in the
          specified number of digits, the value is rounded to the
          nearest number that fits.

          For exact conversions, if a precision is supplied it
          specifies the minimum number of digits to appear; leading
          zeros are produced if necessary.  If a precision is not
          supplied, the number is printed with as many digits as
          necessary.  Converting an exact `0' with an explicit
          precision of zero produces no characters.

        * An optional one of `l', `h' or `L', which is ignored for
          numeric conversions.  It is an error to specify these
          modifiers for non-numeric conversions.

        * A character that specifies the conversion to be applied.


     Exact Conversions
     .................

     `b', `B'
          Print an integer as an unsigned binary number.

          *Note:* `%b' and `%B' are SLIB extensions.


     `d', `i'
          Print an integer as a signed decimal number.  `%d' and `%i'
          are synonymous for output, but are different when used with
          `scanf' for input (*Note Standard Formatted Input::).

     `o'
          Print an integer as an unsigned octal number.

     `u'
          Print an integer as an unsigned decimal number.

     `x', `X'
          Print an integer as an unsigned hexadecimal number.  `%x'
          prints using the digits `0123456789abcdef'.  `%X' prints
          using the digits `0123456789ABCDEF'.


     Inexact Conversions
     ...................

     `f'
          Print a floating-point number in fixed-point notation.

     `e', `E'
          Print a floating-point number in exponential notation.  `%e'
          prints `e' between mantissa and exponont.  `%E' prints `E'
          between mantissa and exponont.

     `g', `G'
          Print a floating-point number in either fixed or exponential
          notation, whichever is more appropriate for its magnitude.
          Unless an `#' flag has been supplied, trailing zeros after a
          decimal point will be stripped off.  `%g' prints `e' between
          mantissa and exponont.  `%G' prints `E' between mantissa and
          exponent.

     `k', `K'
          Print a number like `%g', except that an SI prefix is output
          after the number, which is scaled accordingly.  `%K' outputs
          a space between number and prefix, `%k' does not.



     Other Conversions
     .................
     `c'
          Print a single character.  The `-' flag is the only one
          which can be specified.  It is an error to specify a
          precision.

     `s'
          Print a string.  The `-' flag is the only one which can be
          specified.  A precision specifies the maximum number of
          characters to output; otherwise all characters in the string
          are output.

     `a', `A'
          Print a scheme expression.  The `-' flag left-justifies the
          output.  The `#' flag specifies that strings and characters
          should be quoted as by `write' (which can be read using
          `read'); otherwise, output is as `display' prints.  A
          precision specifies the maximum number of characters to
          output; otherwise as many characters as needed are output.

          *Note:* `%a' and `%A' are SLIB extensions.




     `%'
          Print a literal `%' character.  No argument is consumed.  It
          is an error to specify flags, field width, precision, or
          type modifiers with `%%'.




File: slib.info, Node: Standard Formatted Input, Prev: Standard Formatted Output, Up: Standard Formatted I/O

Standard Formatted Input
------------------------

  `(require 'scanf)'

 -- Function: scanf-read-list FORMAT
 -- Function: scanf-read-list FORMAT PORT
 -- Function: scanf-read-list FORMAT STRING

 -- Macro: scanf FORMAT ARG1 ...
 -- Macro: fscanf PORT FORMAT ARG1 ...
 -- Macro: sscanf STR FORMAT ARG1 ...

     Each function reads characters, interpreting them according to
     the control string FORMAT argument.

     `scanf-read-list' returns a list of the items specified as far as
     the input matches FORMAT.  `scanf', `fscanf', and `sscanf' return
     the number of items successfully matched and stored.  `scanf',
     `fscanf', and `sscanf' also set the location corresponding to
     ARG1 ... using the methods:

     symbol
          `set!'
     car expression
          `set-car!'
     cdr expression
          `set-cdr!'
     vector-ref expression
          `vector-set!'
     substring expression
          `substring-move-left!'

     The argument to a `substring' expression in ARG1 ... must be a
     non-constant string.  Characters will be stored starting at the
     position specified by the second argument to `substring'.  The
     number of characters stored will be limited by either the
     position specified by the third argument to `substring' or the
     length of the matched string, whichever is less.

     The control string, FORMAT, contains conversion specifications
     and other characters used to direct interpretation of input
     sequences.  The control string contains:

        * White-space characters (blanks, tabs, newlines, or
          formfeeds) that cause input to be read (and discarded) up to
          the next non-white-space character.

        * An ordinary character (not `%') that must match the next
          character of the input stream.

        * Conversion specifications, consisting of the character `%',
          an optional assignment suppressing character `*', an
          optional numerical maximum-field width, an optional `l', `h'
          or `L' which is ignored, and a conversion code.



     Unless the specification contains the `n' conversion character
     (described below), a conversion specification directs the
     conversion of the next input field.  The result of a conversion
     specification is returned in the position of the corresponding
     argument points, unless `*' indicates assignment suppression.
     Assignment suppression provides a way to describe an input field
     to be skipped.  An input field is defined as a string of
     characters; it extends to the next inappropriate character or
     until the field width, if specified, is exhausted.

          *Note:* This specification of format strings differs from
          the `ANSI C' and `POSIX' specifications.  In SLIB, white
          space before an input field is not skipped unless white
          space appears before the conversion specification in the
          format string.  In order to write format strings which work
          identically with `ANSI C' and SLIB, prepend whitespace to
          all conversion specifications except `[' and `c'.

     The conversion code indicates the interpretation of the input
     field; For a suppressed field, no value is returned.  The
     following conversion codes are legal:


     `%'
          A single % is expected in the input at this point; no value
          is returned.

     `d', `D'
          A decimal integer is expected.

     `u', `U'
          An unsigned decimal integer is expected.

     `o', `O'
          An octal integer is expected.

     `x', `X'
          A hexadecimal integer is expected.

     `i'
          An integer is expected.  Returns the value of the next input
          item, interpreted according to C conventions; a leading `0'
          implies octal, a leading `0x' implies hexadecimal;
          otherwise, decimal is assumed.

     `n'
          Returns the total number of bytes (including white space)
          read by `scanf'.  No input is consumed by `%n'.

     `f', `F', `e', `E', `g', `G'
          A floating-point number is expected.  The input format for
          floating-point numbers is an optionally signed string of
          digits, possibly containing a radix character `.', followed
          by an optional exponent field consisting of an `E' or an
          `e', followed by an optional `+', `-', or space, followed by
          an integer.

     `c', `C'
          WIDTH characters are expected.  The normal
          skip-over-white-space is suppressed in this case; to read
          the next non-space character, use `%1s'.  If a field width
          is given, a string is returned; up to the indicated number
          of characters is read.

     `s', `S'
          A character string is expected The input field is terminated
          by a white-space character.  `scanf' cannot read a null
          string.

     `['
          Indicates string data and the normal
          skip-over-leading-white-space is suppressed.  The left
          bracket is followed by a set of characters, called the
          scanset, and a right bracket; the input field is the maximal
          sequence of input characters consisting entirely of
          characters in the scanset.  `^', when it appears as the
          first character in the scanset, serves as a complement
          operator and redefines the scanset as the set of all
          characters not contained in the remainder of the scanset
          string.  Construction of the scanset follows certain
          conventions.  A range of characters may be represented by
          the construct first-last, enabling `[0123456789]' to be
          expressed `[0-9]'.  Using this convention, first must be
          lexically less than or equal to last; otherwise, the dash
          stands for itself.  The dash also stands for itself when it
          is the first or the last character in the scanset.  To
          include the right square bracket as an element of the
          scanset, it must appear as the first character (possibly
          preceded by a `^') of the scanset, in which case it will not
          be interpreted syntactically as the closing bracket.  At
          least one character must match for this conversion to
          succeed.

     The `scanf' functions terminate their conversions at end-of-file,
     at the end of the control string, or when an input character
     conflicts with the control string.  In the latter case, the
     offending character is left unread in the input stream.




File: slib.info, Node: Programs and Arguments, Next: HTML, Prev: Standard Formatted I/O, Up: Textual Conversion Packages

Program and Arguments
=====================

* Menu:

* Getopt::                      Command Line option parsing
* Command Line::                A command line reader for Scheme shells
* Parameter lists::             'parameters
* Getopt Parameter lists::      'getopt-parameters
* Filenames::                   'glob or 'filename
* Batch::                       'batch



File: slib.info, Node: Getopt, Next: Command Line, Prev: Programs and Arguments, Up: Programs and Arguments

Getopt
------

  `(require 'getopt)'

  This routine implements Posix command line argument parsing.  Notice
that returning values through global variables means that `getopt' is
*not* reentrant.

  Obedience to Posix format for the `getopt' calls sows confusion.
Passing ARGC and ARGV as arguments while referencing OPTIND as a
global variable leads to strange behavior, especially when the calls
to `getopt' are buried in other procedures.

  Even in C, ARGC can be derived from ARGV; what purpose does it serve
beyond providing an opportunity for ARGV/ARGC mismatch?  Just such a
mismatch existed for years in a SLIB `getopt--' example.

  I have removed the ARGC and ARGV arguments to getopt procedures; and
replaced them with a global variable:

 -- Variable: *argv*
     Define *ARGV* with a list of arguments before calling getopt
     procedures.  If you don't want the first (0th) element to be
     ignored, set *OPTIND* to 0 (after requiring getopt).

 -- Variable: *optind*
     Is the index of the current element of the command line.  It is
     initially one.  In order to parse a new command line or reparse
     an old one, *OPTIND* must be reset.

 -- Variable: *optarg*
     Is set by getopt to the (string) option-argument of the current
     option.

 -- Function: getopt OPTSTRING
     Returns the next option letter in *ARGV* (starting from
     `(vector-ref argv *optind*)') that matches a letter in OPTSTRING.
     *ARGV* is a vector or list of strings, the 0th of which getopt
     usually ignores.  OPTSTRING is a string of recognized option
     characters; if a character is followed by a colon, the option
     takes an argument which may be immediately following it in the
     string or in the next element of *ARGV*.

     *OPTIND* is the index of the next element of the *ARGV* vector to
     be processed.  It is initialized to 1 by `getopt.scm', and
     `getopt' updates it when it finishes with each element of *ARGV*.

     `getopt' returns the next option character from *ARGV* that
     matches a character in OPTSTRING, if there is one that matches.
     If the option takes an argument, `getopt' sets the variable
     *OPTARG* to the option-argument as follows:

        * If the option was the last character in the string pointed
          to by an element of *ARGV*, then *OPTARG* contains the next
          element of *ARGV*, and *OPTIND* is incremented by 2.  If the
          resulting value of *OPTIND* is greater than or equal to
          `(length *ARGV*)', this indicates a missing option argument,
          and `getopt' returns an error indication.

        * Otherwise, *OPTARG* is set to the string following the
          option character in that element of *ARGV*, and *OPTIND* is
          incremented by 1.

     If, when `getopt' is called, the string `(vector-ref argv
     *optind*)' either does not begin with the character `#\-' or is
     just `"-"', `getopt' returns `#f' without changing *OPTIND*.  If
     `(vector-ref argv *optind*)' is the string `"--"', `getopt'
     returns `#f' after incrementing *OPTIND*.

     If `getopt' encounters an option character that is not contained
     in OPTSTRING, it returns the question-mark `#\?' character.  If
     it detects a missing option argument, it returns the colon
     character `#\:' if the first character of OPTSTRING was a colon,
     or a question-mark character otherwise.  In either case, `getopt'
     sets the variable GETOPT:OPT to the option character that caused
     the error.

     The special option `"--"' can be used to delimit the end of the
     options; `#f' is returned, and `"--"' is skipped.

     RETURN VALUE

     `getopt' returns the next option character specified on the
     command line.  A colon `#\:' is returned if `getopt' detects a
     missing argument and the first character of OPTSTRING was a colon
     `#\:'.

     A question-mark `#\?' is returned if `getopt' encounters an
     option character not in OPTSTRING or detects a missing argument
     and the first character of OPTSTRING was not a colon `#\:'.

     Otherwise, `getopt' returns `#f' when all command line options
     have been parsed.

     Example:
          #! /usr/local/bin/scm
          ;;;This code is SCM specific.
          (define argv (program-arguments))
          (require 'getopt)

          (define opts ":a:b:cd")
          (let loop ((opt (getopt (length argv) argv opts)))
            (case opt
              ((#\a) (print "option a: " *optarg*))
              ((#\b) (print "option b: " *optarg*))
              ((#\c) (print "option c"))
              ((#\d) (print "option d"))
              ((#\?) (print "error" getopt:opt))
              ((#\:) (print "missing arg" getopt:opt))
              ((#f) (if (< *optind* (length argv))
                        (print "argv[" *optind* "]="
                               (list-ref argv *optind*)))
                    (set! *optind* (+ *optind* 1))))
            (if (< *optind* (length argv))
                (loop (getopt (length argv) argv opts))))

          (slib:exit)


Getopt---
---------

 -- Function: `getopt--' OPTSTRING
     The procedure `getopt--' is an extended version of `getopt'
     which parses "long option names" of the form
     `--hold-the-onions' and `--verbosity-level=extreme'.
     `Getopt--' behaves as `getopt' except for non-empty
     options beginning with `--'.

     Options beginning with `--' are returned as strings rather than
     characters.  If a value is assigned (using `=') to a long option,
     `*optarg*' is set to the value.  The `=' and value are not
     returned as part of the option string.

     No information is passed to `getopt--' concerning which long
     options should be accepted or whether such options can take
     arguments.  If a long option did not have an argument, `*optarg*'
     will be set to `#f'.  The caller is responsible for detecting and
     reporting errors.

          (define opts ":-:b:")
          (define *argv* '("foo" "-b9" "--f1" "--2=" "--g3=35234.342" "--"))
          (define *optind* 1)
          (define *optarg* #f)
          (require 'qp)
          (do ((i 5 (+ -1 i)))
              ((zero? i))
            (let ((opt (getopt-- opts)))
              (print *optind* opt *optarg*)))
          -|
          2 #\b "9"
          3 "f1" #f
          4 "2" ""
          5 "g3" "35234.342"
          5 #f "35234.342"



File: slib.info, Node: Command Line, Next: Parameter lists, Prev: Getopt, Up: Programs and Arguments

Command Line
------------

  `(require 'read-command)'


 -- Function: read-command PORT


 -- Function: read-command
     `read-command' converts a "command line" into a list of strings
     suitable for parsing by `getopt'.  The syntax of command lines
     supported resembles that of popular "shell"s.  `read-command'
     updates PORT to point to the first character past the command
     delimiter.

     If an end of file is encountered in the input before any
     characters are found that can begin an object or comment, then an
     end of file object is returned.

     The PORT argument may be omitted, in which case it defaults to
     the value returned by `current-input-port'.

     The fields into which the command line is split are delimited by
     whitespace as defined by `char-whitespace?'.  The end of a
     command is delimited by end-of-file or unescaped semicolon (;) or
     newline.  Any character can be literally included in a field by
     escaping it with a backslach (\).

     The initial character and types of fields recognized are:
     `\'
          The next character has is taken literally and not
          interpreted as a field delimiter.  If \ is the last
          character before a newline, that newline is just ignored.
          Processing continues from the characters after the newline
          as though the backslash and newline were not there.
     `"'
          The characters up to the next unescaped " are taken
          literally, according to [R4RS] rules for literal strings
          (*Note Strings: (r4rs)Strings.).
     `(', `%''
          One scheme expression is `read' starting with this
          character.  The `read' expression is evaluated, converted to
          a string (using `display'), and replaces the expression in
          the returned field.
     `;'
          Semicolon delimits a command.  Using semicolons more than
          one command can appear on a line.  Escaped semicolons and
          semicolons inside strings do not delimit commands.

     The comment field differs from the previous fields in that it
     must be the first character of a command or appear after
     whitespace in order to be recognized.  # can be part of fields if
     these conditions are not met.  For instance, `ab#c' is just the
     field ab#c.

     `#'
          Introduces a comment.  The comment continues to the end of
          the line on which the semicolon appears.  Comments are
          treated as whitespace by `read-dommand-line' and backslashes
          before newlines in comments are also ignored.

 -- Function: read-options-file FILENAME

     `read-options-file' converts an "options file" into a list of
     strings suitable for parsing by `getopt'.  The syntax of options
     files is the same as the syntax for command lines, except that
     newlines do not terminate reading (only ; or end of file).

     If an end of file is encountered before any characters are found
     that can begin an object or comment, then an end of file object
     is returned.




File: slib.info, Node: Parameter lists, Next: Getopt Parameter lists, Prev: Command Line, Up: Programs and Arguments

Parameter lists
---------------

  `(require 'parameters)'

Arguments to procedures in scheme are distinguished from each other by
their position in the procedure call.  This can be confusing when a
procedure takes many arguments, many of which are not often used.

A "parameter-list" is a way of passing named information to a
procedure.  Procedures are also defined to set unused parameters to
default values, check parameters, and combine parameter lists.

A PARAMETER has the form `(parameter-name value1
...)'.  This format allows for more than one value per
parameter-name.

A PARAMETER-LIST is a list of PARAMETERs, each with a different
PARAMETER-NAME.

 -- Function: make-parameter-list PARAMETER-NAMES
     Returns an empty parameter-list with slots for PARAMETER-NAMES.

 -- Function: parameter-list-ref PARAMETER-LIST PARAMETER-NAME
     PARAMETER-NAME must name a valid slot of PARAMETER-LIST.
     `parameter-list-ref' returns the value of parameter
     PARAMETER-NAME of PARAMETER-LIST.

 -- Function: remove-parameter PARAMETER-NAME PARAMETER-LIST
     Removes the parameter PARAMETER-NAME from PARAMETER-LIST.
     `remove-parameter' does not alter the argument PARAMETER-LIST.

     If there are more than one PARAMETER-NAME parameters, an error is
     signaled.

 -- Procedure: adjoin-parameters! PARAMETER-LIST PARAMETER1 ...
     Returns PARAMETER-LIST with PARAMETER1 ... merged in.

 -- Procedure: parameter-list-expand EXPANDERS PARAMETER-LIST
     EXPANDERS is a list of procedures whose order matches the order
     of the PARAMETER-NAMEs in the call to `make-parameter-list' which
     created PARAMETER-LIST.  For each non-false element of EXPANDERS
     that procedure is mapped over the corresponding parameter value
     and the returned parameter lists are merged into PARAMETER-LIST.

     This process is repeated until PARAMETER-LIST stops growing.  The
     value returned from `parameter-list-expand' is unspecified.

 -- Function: fill-empty-parameters DEFAULTERS PARAMETER-LIST
     DEFAULTERS is a list of procedures whose order matches the order
     of the PARAMETER-NAMEs in the call to `make-parameter-list' which
     created PARAMETER-LIST.  `fill-empty-parameters' returns a new
     parameter-list with each empty parameter replaced with the list
     returned by calling the corresponding DEFAULTER with
     PARAMETER-LIST as its argument.

 -- Function: check-parameters CHECKS PARAMETER-LIST
     CHECKS is a list of procedures whose order matches the order of
     the PARAMETER-NAMEs in the call to `make-parameter-list' which
     created PARAMETER-LIST.

     `check-parameters' returns PARAMETER-LIST if each CHECK of the
     corresponding PARAMETER-LIST returns non-false.  If some CHECK
     returns `#f' a warning is signaled.

In the following procedures ARITIES is a list of symbols.  The
elements of `arities' can be:

`single'
     Requires a single parameter.
`optional'
     A single parameter or no parameter is acceptable.
`boolean'
     A single boolean parameter or zero parameters is acceptable.
`nary'
     Any number of parameters are acceptable.
`nary1'
     One or more of parameters are acceptable.

 -- Function: parameter-list->arglist POSITIONS ARITIES PARAMETER-LIST
     Returns PARAMETER-LIST converted to an argument list.  Parameters
     of ARITY type `single' and `boolean' are converted to the single
     value associated with them.  The other ARITY types are converted
     to lists of the value(s).

     POSITIONS is a list of positive integers whose order matches the
     order of the PARAMETER-NAMEs in the call to `make-parameter-list'
     which created PARAMETER-LIST.  The integers specify in which
     argument position the corresponding parameter should appear.




File: slib.info, Node: Getopt Parameter lists, Next: Filenames, Prev: Parameter lists, Up: Programs and Arguments

Getopt Parameter lists
----------------------

  `(require 'getopt-parameters)'


 -- Function: getopt->parameter-list OPTNAMES ARITIES TYPES ALIASES DESC ...

     Returns *ARGV* converted to a parameter-list.  OPTNAMES are the
     parameter-names.  ARITIES and TYPES are lists of symbols
     corresponding to OPTNAMES.

     ALIASES is a list of lists of strings or integers paired with
     elements of OPTNAMES.  Each one-character string will be treated
     as a single `-' option by `getopt'.  Longer strings will be
     treated as long-named options (*Note getopt--: Getopt.).

     If the ALIASES association list has only strings as its `car's,
     then all the option-arguments after an option (and before the
     next option) are adjoined to that option.

     If the ALIASES association list has integers, then each (string)
     option will take at most one option-argument.  Unoptioned
     arguments are collected in a list.  A `-1' alias will take the
     last argument in this list; `+1' will take the first argument in
     the list.  The aliases -2 then +2; -3 then +3; ... are tried so
     long as a positive or negative consecutive alias is found and
     arguments remain in the list.  Finally a `0' alias, if found,
     absorbs any remaining arguments.

     In all cases, if unclaimed arguments remain after processing, a
     warning is signaled and #f is returned.

 -- Function: getopt->arglist OPTNAMES POSITIONS ARITIES TYPES DEFAULTERS CHECKS ALIASES DESC ...

     Like `getopt->parameter-list', but converts *ARGV* to an
argument-list as specified by OPTNAMES, POSITIONS, ARITIES, TYPES,
DEFAULTERS, CHECKS, and ALIASES.  If the options supplied violate the
ARITIES or CHECKS constraints, then a warning is signaled and #f is
returned.  These `getopt' functions can be used with SLIB relational
databases.  For an example, *Note make-command-server: Using
Databases.

If errors are encountered while processing options, directions for
using the options (and argument strings DESC ...) are printed to
`current-error-port'.

     (begin
       (set! *optind* 1)
       (set! *argv* '("cmd" "-?")
       (getopt->parameter-list
        '(flag number symbols symbols string flag2 flag3 num2 num3)
        '(boolean optional nary1 nary single boolean boolean nary nary)
        '(boolean integer symbol symbol string boolean boolean integer integer)
        '(("flag" flag)
          ("f" flag)
          ("Flag" flag2)
          ("B" flag3)
          ("optional" number)
          ("o" number)
          ("nary1" symbols)
          ("N" symbols)
          ("nary" symbols)
          ("n" symbols)
          ("single" string)
          ("s" string)
          ("a" num2)
          ("Abs" num3))))
     -|
     Usage: cmd [OPTION ARGUMENT ...] ...

       -f, --flag
       -o, --optional=<number>
       -n, --nary=<symbols> ...
       -N, --nary1=<symbols> ...
       -s, --single=<string>
           --Flag
       -B
       -a        <num2> ...
           --Abs=<num3> ...

     ERROR: getopt->parameter-list "unrecognized option" "-?"




File: slib.info, Node: Filenames, Next: Batch, Prev: Getopt Parameter lists, Up: Programs and Arguments

Filenames
---------

  `(require 'filename)' or `(require 'glob)'


 -- Function: filename:match?? PATTERN
 -- Function: filename:match-ci?? PATTERN

     Returns a predicate which returns a non-false value if its string
     argument matches (the string) PATTERN, false otherwise.  Filename
     matching is like "glob" expansion described the bash manpage,
     except that names beginning with `.' are matched and `/'
     characters are not treated specially.

     These functions interpret the following characters specially in
     PATTERN strings:
     `*'
          Matches any string, including the null string.
     `?'
          Matches any single character.
     `[...]'
          Matches any one of the enclosed characters.  A pair of
          characters separated by a minus sign (-) denotes a range;
          any character lexically between those two characters,
          inclusive, is matched.  If the first character following the
          `[' is a `!' or a `^' then any character not enclosed is
          matched.  A `-' or `]' may be matched by including it as the
          first or last character in the set.

 -- Function: filename:substitute?? PATTERN TEMPLATE
 -- Function: filename:substitute-ci?? PATTERN TEMPLATE

     Returns a function transforming a single string argument
     according to glob patterns PATTERN and TEMPLATE.  PATTERN and
     TEMPLATE must have the same number of wildcard specifications,
     which need not be identical.  PATTERN and TEMPLATE may have a
     different number of literal sections. If an argument to the
     function matches PATTERN in the sense of `filename:match??' then
     it returns a copy of TEMPLATE in which each wildcard
     specification is replaced by the part of the argument matched by
     the corresponding wildcard specification in PATTERN.  A `*'
     wildcard matches the longest leftmost string possible.  If the
     argument does not match PATTERN then false is returned.

     TEMPLATE may be a function accepting the same number of string
     arguments as there are wildcard specifications in PATTERN.  In
     the case of a match the result of applying TEMPLATE to a list of
     the substrings matched by wildcard specifications will be
     returned, otherwise TEMPLATE will not be called and `#f' will be
     returned.
     ((filename:substitute?? "scm_[0-9]*.html" "scm5c4_??.htm")
      "scm_10.html")
     => "scm5c4_10.htm"
     ((filename:substitute?? "??" "beg?mid?end") "AZ")
     => "begAmidZend"
     ((filename:substitute?? "*na*" "?NA?") "banana")
     => "banaNA"
     ((filename:substitute?? "?*?" (lambda (s1 s2 s3) (string-append s3 s1)))
      "ABZ")
     => "ZA"


 -- Function: replace-suffix STR OLD NEW

     STR can be a string or a list of strings.  Returns a new string
     (or strings) similar to `str' but with the suffix string OLD
     removed and the suffix string NEW appended.  If the end of STR
     does not match OLD, an error is signaled.
     (replace-suffix "/usr/local/lib/slib/batch.scm" ".scm" ".c")
     => "/usr/local/lib/slib/batch.c"


 -- Function: call-with-tmpnam PROC K


 -- Function: call-with-tmpnam PROC

Calls PROC with K arguments, strings returned by successive calls
to `tmpnam'.  If PROC returns, then any files named by the
arguments to PROC are deleted automatically and the value(s)
yielded by the PROC is(are) returned.  K may be ommited, in which
case it defaults to `1'.

 -- Function: call-with-tmpnam PROC SUFFIX1 ...
     Calls PROC with strings returned by successive calls to `tmpnam',
     each with the corresponding SUFFIX string appended.  If PROC
     returns, then any files named by the arguments to PROC are
     deleted automatically and the value(s) yielded by the PROC
     is(are) returned.




File: slib.info, Node: Batch, Prev: Filenames, Up: Programs and Arguments

Batch
-----

  `(require 'batch)'

The batch procedures provide a way to write and execute portable
scripts for a variety of operating systems.  Each `batch:' procedure
takes as its first argument a parameter-list (*Note Parameter
lists::).  This parameter-list argument PARMS contains named
associations.  Batch currently uses 2 of these:

`batch-port'
     The port on which to write lines of the batch file.
`batch-dialect'
     The syntax of batch file to generate.  Currently supported are:
        * unix
        * dos
        * vms
        * amigaos
        * system
        * *unknown*

`batch.scm' uses 2 enhanced relational tables (*Note Using
Databases::) to store information linking the names of
`operating-system's to `batch-dialect'es.

 -- Function: batch:initialize! DATABASE
     Defines `operating-system' and `batch-dialect' tables and adds
     the domain `operating-system' to the enhanced relational database
     DATABASE.

 -- Variable: *operating-system*
     Is batch's best guess as to which operating-system it is running
     under.  `*operating-system*' is set to `(software-type)' (*Note
     Configuration::) unless `(software-type)' is `unix', in which
     case finer distinctions are made.

 -- Function: batch:call-with-output-script PARMS FILE PROC
     PROC should be a procedure of one argument.  If FILE is an
     output-port, `batch:call-with-output-script' writes an
     appropriate header to FILE and then calls PROC with FILE as the
     only argument.  If FILE is a string,
     `batch:call-with-output-script' opens a output-file of name FILE,
     writes an appropriate header to FILE, and then calls PROC with
     the newly opened port as the only argument.  Otherwise,
     `batch:call-with-output-script' acts as if it was called with the
     result of `(current-output-port)' as its third argument.

The rest of the `batch:' procedures write (or execute if
`batch-dialect' is `system') commands to the batch port which has been
added to PARMS or `(copy-tree PARMS)' by the code:

     (adjoin-parameters! PARMS (list 'batch-port PORT))

 -- Function: batch:command PARMS STRING1 STRING2 ...
     Calls `batch:try-command' (below) with arguments, but signals an
     error if `batch:try-command' returns `#f'.

These functions return a non-false value if the command was
successfully translated into the batch dialect and `#f' if not.  In
the case of the `system' dialect, the value is non-false if the
operation suceeded.

 -- Function: batch:try-command PARMS STRING1 STRING2 ...
     Writes a command to the `batch-port' in PARMS which executes the
     program named STRING1 with arguments STRING2 ....

 -- Function: batch:try-chopped-command PARMS ARG1 ARG2 ... LIST
     breaks the last argument LIST into chunks small enough so that
     the command:

          ARG1 ARG2 ... CHUNK

     fits withing the platform's maximum command-line length.

     `batch:try-chopped-command' calls `batch:try-command' with the
     command and returns non-false only if the commands all fit and
     `batch:try-command' of each command line returned non-false.

 -- Function: batch:run-script PARMS STRING1 STRING2 ...
     Writes a command to the `batch-port' in PARMS which executes
     the batch script named STRING1 with arguments STRING2
     ....

     *Note:* `batch:run-script' and `batch:try-command' are not the
     same for some operating systems (VMS).

 -- Function: batch:comment PARMS LINE1 ...
     Writes comment lines LINE1 ... to the `batch-port' in PARMS.

 -- Function: batch:lines->file PARMS FILE LINE1 ...
     Writes commands to the `batch-port' in PARMS which create a file
     named FILE with contents LINE1 ....

 -- Function: batch:delete-file PARMS FILE
     Writes a command to the `batch-port' in PARMS which deletes the
     file named FILE.

 -- Function: batch:rename-file PARMS OLD-NAME NEW-NAME
     Writes a command to the `batch-port' in PARMS which renames the
     file OLD-NAME to NEW-NAME.

In addition, batch provides some small utilities very useful for
writing scripts:

 -- Function: truncate-up-to PATH CHAR
 -- Function: truncate-up-to PATH STRING
 -- Function: truncate-up-to PATH CHARLIST
     PATH can be a string or a list of strings.  Returns PATH sans any
     prefixes ending with a character of the second argument.  This
     can be used to derive a filename moved locally from elsewhere.

          (truncate-up-to "/usr/local/lib/slib/batch.scm" "/")
          => "batch.scm"

 -- Function: string-join JOINER STRING1 ...
     Returns a new string consisting of all the strings STRING1 ...
     in order appended together with the string JOINER between each
     adjacent pair.

 -- Function: must-be-first LIST1 LIST2
     Returns a new list consisting of the elements of LIST2 ordered so
     that if some elements of LIST1 are `equal?' to elements of LIST2,
     then those elements will appear first and in the order of LIST1.

 -- Function: must-be-last LIST1 LIST2
     Returns a new list consisting of the elements of LIST1 ordered so
     that if some elements of LIST2 are `equal?' to elements of LIST1,
     then those elements will appear last and in the order of LIST2.

 -- Function: os->batch-dialect OSNAME
     Returns its best guess for the `batch-dialect' to be used for the
     operating-system named OSNAME.  `os->batch-dialect' uses the
     tables added to DATABASE by `batch:initialize!'.

Here is an example of the use of most of batch's procedures:

     (require 'databases)
     (require 'parameters)
     (require 'batch)
     (require 'glob)

     (define batch (create-database #f 'alist-table))
     (batch:initialize! batch)

     (define my-parameters
       (list (list 'batch-dialect (os->batch-dialect *operating-system*))
             (list 'operating-system *operating-system*)
             (list 'batch-port (current-output-port)))) ;gets filled in later

     (batch:call-with-output-script
      my-parameters
      "my-batch"
      (lambda (batch-port)
        (adjoin-parameters! my-parameters (list 'batch-port batch-port))
        (and
         (batch:comment my-parameters
                        "================ Write file with C program.")
         (batch:rename-file my-parameters "hello.c" "hello.c~")
         (batch:lines->file my-parameters "hello.c"
                            "#include <stdio.h>"
                            "int main(int argc, char **argv)"
                            "{"
                            "  printf(\"hello world\\n\");"
                            "  return 0;"
                            "}" )
         (batch:command my-parameters "cc" "-c" "hello.c")
         (batch:command my-parameters "cc" "-o" "hello"
                       (replace-suffix "hello.c" ".c" ".o"))
         (batch:command my-parameters "hello")
         (batch:delete-file my-parameters "hello")
         (batch:delete-file my-parameters "hello.c")
         (batch:delete-file my-parameters "hello.o")
         (batch:delete-file my-parameters "my-batch")
         )))

Produces the file `my-batch':

     #! /bin/sh
     # "my-batch" script created by SLIB/batch Sun Oct 31 18:24:10 1999
     # ================ Write file with C program.
     mv -f hello.c hello.c~
     rm -f hello.c
     echo '#include <stdio.h>'>>hello.c
     echo 'int main(int argc, char **argv)'>>hello.c
     echo '{'>>hello.c
     echo '  printf("hello world\n");'>>hello.c
     echo '  return 0;'>>hello.c
     echo '}'>>hello.c
     cc -c hello.c
     cc -o hello hello.o
     hello
     rm -f hello
     rm -f hello.c
     rm -f hello.o
     rm -f my-batch

When run, `my-batch' prints:

     bash$ my-batch
     mv: hello.c: No such file or directory
     hello world




File: slib.info, Node: HTML, Next: HTML Tables, Prev: Programs and Arguments, Up: Textual Conversion Packages

HTML
====

  `(require 'html-form)'


 -- Function: html:atval TXT
     Returns a string with character substitutions appropriate to send
     TXT as an "attribute-value".

 -- Function: html:plain TXT
     Returns a string with character substitutions appropriate to send
     TXT as an "plain-text".

 -- Function: html:meta NAME CONTENT
     Returns a tag of meta-information suitable for passing as the
     third argument to `html:head'.  The tag produced is `<META
     NAME="NAME" CONTENT="CONTENT">'.  The string or symbol NAME can
     be `author', `copyright', `keywords', `description', `date',
     `robots', ....

 -- Function: html:http-equiv NAME CONTENT
     Returns a tag of HTTP information suitable for passing as the
     third argument to `html:head'.  The tag produced is `<META
     HTTP-EQUIV="NAME" CONTENT="CONTENT">'.  The string or symbol NAME
     can be `Expires', `PICS-Label', `Content-Type', `Refresh', ....

 -- Function: html:meta-refresh DELAY URI


 -- Function: html:meta-refresh DELAY

     Returns a tag suitable for passing as the third argument to
     `html:head'.  If URI argument is supplied, then DELAY seconds
     after displaying the page with this tag, Netscape or IE browsers
     will fetch and display URI.  Otherwise, DELAY seconds after
     displaying the page with this tag, Netscape or IE browsers will
     fetch and redisplay this page.

 -- Function: html:head TITLE BACKLINK TAGS ...


 -- Function: html:head TITLE BACKLINK

 -- Function: html:head TITLE

     Returns header string for an HTML page named TITLE.  If BACKLINK
     is a string, it is used verbatim between the `H1' tags; otherwise
     TITLE is used.  If string arguments TAGS ... are supplied, then
     they are included verbatim within the <HEAD> section.

 -- Function: html:body BODY ...
     Returns HTML string to end a page.

 -- Function: html:pre LINE1 LINE ...
     Returns the strings LINE1, LINES as "PRE"formmated plain text
     (rendered in fixed-width font).  Newlines are inserted between
     LINE1, LINES.  HTML tags (`<tag>') within LINES will be visible
     verbatim.

 -- Function: html:comment LINE1 LINE ...
     Returns the strings LINE1 as HTML comments.

HTML Forms
==========


 -- Function: html:form METHOD ACTION BODY ...
     The symbol METHOD is either `get', `head', `post', `put', or
     `delete'.  The strings BODY form the body of the form.
     `html:form' returns the HTML "form".

 -- Function: html:hidden NAME VALUE
     Returns HTML string which will cause NAME=VALUE in form.

 -- Function: html:checkbox PNAME DEFAULT
     Returns HTML string for check box.

 -- Function: html:text PNAME DEFAULT SIZE ...
     Returns HTML string for one-line text box.

 -- Function: html:text-area PNAME DEFAULT-LIST
     Returns HTML string for multi-line text box.

 -- Function: html:select PNAME ARITY DEFAULT-LIST FOREIGN-VALUES
     Returns HTML string for pull-down menu selector.

 -- Function: html:buttons PNAME ARITY DEFAULT-LIST FOREIGN-VALUES
     Returns HTML string for any-of selector.

 -- Function: form:submit SUBMIT-LABEL COMMAND


 -- Function: form:submit SUBMIT-LABEL

     The string or symbol SUBMIT-LABEL appears on the button which
     submits the form.  If the optional second argument COMMAND is
     given, then `*command*=COMMAND' and `*button*=SUBMIT-LABEL' are
     set in the query.  Otherwise, `*command*=SUBMIT-LABEL' is set in
     the query.

 -- Function: form:image SUBMIT-LABEL IMAGE-SRC
     The IMAGE-SRC appears on the button which submits the form.

 -- Function: form:reset
     Returns a string which generates a "reset" button.

 -- Function: form:element PNAME ARITY DEFAULT-LIST FOREIGN-VALUES
     Returns a string which generates an INPUT element for the field
     named PNAME.  The element appears in the created form with its
     representation determined by its ARITY and domain.  For domains
     which are foreign-keys:

     `single'
          select menu
     `optional'
          select menu
     `nary'
          check boxes
     `nary1'
          check boxes

     If the foreign-key table has a field named `visible-name', then
     the contents of that field are the names visible to the user for
     those choices.  Otherwise, the foreign-key itself is visible.

     For other types of domains:

     `single'
          text area
     `optional'
          text area
     `boolean'
          check box
     `nary'
          text area
     `nary1'
          text area

 -- Function: form:delimited PNAME DOC ALIAT ARITY DEFAULT-LIST FOREIGN-VALUES


     Returns a HTML string for a form element embedded in a line of a
     delimited list.  Apply map `form:delimited' to the list returned
     by `command->p-specs'.

 -- Function: html:delimited-list ROW ...
     Wraps its arguments with delimited-list (`DL' command.

 -- Function: get-foreign-choices TAB
     Returns a list of the `visible-name' or first fields of table
     TAB.

 -- Function: command->p-specs RDB COMMAND-TABLE COMMAND


     The symbol COMMAND-TABLE names a command table in the RDB
     relational database.  The symbol COMMAND names a key in
     COMMAND-TABLE.

     `command->p-specs' returns a list of lists of PNAME, DOC, ALIAT,
     ARITY, DEFAULT-LIST, and FOREIGN-VALUES.  The returned list has
     one element for each parameter of command COMMAND.

     This example demonstrates how to create a HTML-form for the
     `build' command.

          (require (in-vicinity (implementation-vicinity) "build.scm"))
          (call-with-output-file "buildscm.html"
            (lambda (port)
              (display
               (string-append
                (html:head 'commands)
                (html:body
                 (sprintf #f "<H2>%s:</H2><BLOCKQUOTE>%s</BLOCKQUOTE>\\n"
                          (html:plain 'build)
                          (html:plain ((comtab 'get 'documentation) 'build)))
                 (html:form
                  'post
                  (or "http://localhost:8081/buildscm" "/cgi-bin/build.cgi")
                  (apply html:delimited-list
                         (apply map form:delimited
                                (command->p-specs build '*commands* 'build)))
                  (form:submit 'build)
                  (form:reset))))
               port)))




File: slib.info, Node: HTML Tables, Next: HTTP and CGI, Prev: HTML, Up: Textual Conversion Packages

HTML Tables
===========

  `(require 'db->html)'


 -- Function: html:table OPTIONS ROW ...


 -- Function: html:caption CAPTION ALIGN


 -- Function: html:caption CAPTION
     ALIGN can be `top' or `bottom'.

 -- Function: html:heading COLUMNS
     Outputs a heading row for the currently-started table.

 -- Function: html:href-heading COLUMNS URIS
     Outputs a heading row with column-names COLUMNS linked to URIs
     URIS.

 -- Function: html:linked-row-converter K FOREIGNS


     The positive integer K is the primary-key-limit (number of
     primary-keys) of the table.  FOREIGNS is a list of the filenames
     of foreign-key field pages and #f for non foreign-key fields.

     `html:linked-row-converter' returns a procedure taking a row for
     its single argument.  This returned procedure returns the html
     string for that table row.

 -- Function: table-name->filename TABLE-NAME

     Returns the symbol TABLE-NAME converted to a filename.

 -- Function: table->linked-html CAPTION DB TABLE-NAME MATCH-KEY1 ...

     Returns HTML string for DB table TABLE-NAME.  Every foreign-key
     value is linked to the page (of the table) defining that key.

     The optional MATCH-KEY1 ... arguments restrict actions to a
     subset of the table.  *Note match-key: Table Operations.

 -- Function: table->linked-page DB TABLE-NAME INDEX-FILENAME ARG ...

     Returns a complete HTML page.  The string INDEX-FILENAME names
     the page which refers to this one.

     The optional ARGS ... arguments restrict actions to a subset of
     the table.  *Note match-key: Table Operations.

 -- Function: catalog->html DB CAPTION ARG ...

     Returns HTML string for the catalog table of DB.

HTML editing tables
-------------------

For any change submitted, these routines check if that row has been
modified during the time the user has been editing the form.  If so,
an error page results.

@noindent The behavior of edited rows is:

   * If no fields are changed, then no change is made to the table.
   * If the primary keys equal null-keys (parameter defaults), and no
     other user has modified that row, then that row is deleted.
   * If only primary keys are changed, there are non-key fields, and
     no row with the new keys is in the table, then the old row is
     deleted and one with the new keys is inserted.
   * If only non-key fields are changed, and that row has not been
     modified by another user, then the row is changed to reflect the
     fields.
   * If both keys and non-key fields are changed, and no row with the
     new keys is in the table, then a row is created with the new keys
     and fields.
   * If fields are changed, all fields are primary keys, and no row
     with the new keys is in the table, then a row is created with the
     new keys.

database is performed.


 -- Function: command:modify-table TABLE-NAME NULL-KEYS UPDATE DELETE RETRIEVE


 -- Function: command:modify-table TABLE-NAME NULL-KEYS UPDATE DELETE

 -- Function: command:modify-table TABLE-NAME NULL-KEYS UPDATE

 -- Function: command:modify-table TABLE-NAME NULL-KEYS

     Returns procedure (of DB) which returns procedure to modify row
     of TABLE-NAME.  NULL-KEYS is the list of "null" keys indicating
     the row is to be deleted when any matches its corresponding
     primary key.  Optional arguments UPDATE, DELETE, and RETRIEVE
     default to the `row:update', `row:delete', and `row:retrieve' of
     TABLE-NAME in DB.

 -- Function: command:make-editable-table RDB TABLE-NAME ARG ...
     Given TABLE-NAME in RDB, creates parameter and `*command*' tables
     for editing one row of TABLE-NAME at a time.
     `command:make-editable-table' returns a procedure taking a row
     argument which returns the HTML string for editing that row.

     Optional ARGS are expressions (lists) added to the call to
     `command:modify-table'.

     The domain name of a column determines the expected arity of the
     data stored in that column.  Domain names ending in:

     `*'
          have arity `nary';
     `+'
          have arity `nary1'.

 -- Function: html:editable-row-converter K NAMES EDIT-POINT EDIT-CONVERTER


     The positive integer K is the primary-key-limit (number of
     primary-keys) of the table.  NAMES is a list of the field-names.
     EDIT-POINT is the list of primary-keys denoting the row to edit
     (or #f).  EDIT-CONVERTER is the procedure called with K, NAMES,
     and the row to edit.

     `html:editable-row-converter' returns a procedure taking a row
     for its single argument.  This returned procedure returns the
     html string for that table row.

     Each HTML table constructed using `html:editable-row-converter'
     has first K fields (typically the primary key fields) of each row
     linked to a text encoding of these fields (the result of calling
     `row->anchor').  The page so referenced typically allows the user
     to edit fields of that row.

HTML databases
--------------


 -- Function: db->html-files DB DIR INDEX-FILENAME CAPTION
     DB must be a relational database.  DIR must be #f or a non-empty
     string naming an existing sub-directory of the current directory.

     `db->html-files' creates an html page for each table in the
     database DB in the sub-directory named DIR, or the current
     directory if DIR is #f.  The top level page with the catalog of
     tables (captioned CAPTION) is written to a file named
     INDEX-FILENAME.

 -- Function: db->html-directory DB DIR INDEX-FILENAME


 -- Function: db->html-directory DB DIR
     DB must be a relational database.  DIR must be a non-empty string
     naming an existing sub-directory of the current directory or one
     to be created.  The optional string INDEX-FILENAME names the
     filename of the top page, which defaults to `index.html'.

     `db->html-directory' creates sub-directory DIR if neccessary, and
     calls `(db->html-files DB DIR INDEX-FILENAME DIR)'.  The `file:'
     URI of INDEX-FILENAME is returned.

 -- Function: db->netscape DB DIR INDEX-FILENAME


 -- Function: db->netscape DB DIR
     `db->netscape' is just like `db->html-directory', but calls
     `browse-url' with the uri for the top page after the pages are
     created.




File: slib.info, Node: HTTP and CGI, Next: Parsing HTML, Prev: HTML Tables, Up: Textual Conversion Packages

HTTP and CGI
============

  `(require 'http)' or `(require 'cgi)'


 -- Function: http:header ALIST
     Returns a string containing lines for each element of ALIST; the
     `car' of which is followed by `: ', then the `cdr'.

 -- Function: http:content ALIST BODY ...
     Returns the concatenation of strings BODY with the `(http:header
     ALIST)' and the `Content-Length' prepended.

 -- Variable: *http:byline*
     String appearing at the bottom of error pages.

 -- Function: http:error-page STATUS-CODE REASON-PHRASE HTML-STRING ...
     STATUS-CODE and REASON-PHRASE should be an integer and string as
     specified in `RFC 2068'.  The returned page (string) will show
     the STATUS-CODE and REASON-PHRASE and any additional HTML-STRINGS
     ...; with *HTTP:BYLINE* or SLIB's default at the bottom.

 -- Function: http:forwarding-page TITLE DELAY URI HTML-STRING ...
     The string or symbol TITLE is the page title.  DELAY is a
     non-negative integer.  The HTML-STRINGS ... are typically used to
     explain to the user why this page is being forwarded.

     `http:forwarding-page' returns an HTML string for a page which automatically forwards to
     URI after DELAY seconds.  The returned page (string) contains any HTML-STRINGS
     ... followed by a manual link to URI, in case the browser does not
     forward automatically.

 -- Function: http:serve-query SERVE-PROC INPUT-PORT OUTPUT-PORT
     reads the "URI" and "query-string" from INPUT-PORT.  If the query
     is a valid `"POST"' or `"GET"' query, then `http:serve-query'
     calls SERVE-PROC with three arguments, the REQUEST-LINE,
     QUERY-STRING, and HEADER-ALIST.  Otherwise, `http:serve-query'
     calls SERVE-PROC with the REQUEST-LINE, #f, and HEADER-ALIST.

     If SERVE-PROC returns a string, it is sent to OUTPUT-PORT.  If
     SERVE-PROC returns a list, then an error page with number 525 and
     strings from the list.  If SERVE-PROC returns #f, then a `Bad
     Request' (400) page is sent to OUTPUT-PORT.

     Otherwise, `http:serve-query' replies (to OUTPUT-PORT) with
     appropriate HTML describing the problem.


  This example services HTTP queries from PORT-NUMBER:

     (define socket (make-stream-socket AF_INET 0))
     (and (socket:bind socket port-number) ; AF_INET INADDR_ANY
          (socket:listen socket 10)        ; Queue up to 10 requests.
          (dynamic-wind
              (lambda () #f)
              (lambda ()
                (do ((port (socket:accept socket) (socket:accept socket)))
                    (#f)
                  (let ((iport (duplicate-port port "r"))
                        (oport (duplicate-port port "w")))
                    (http:serve-query build:serve iport oport)
                    (close-port iport)
                    (close-port oport))
                  (close-port port)))
              (lambda () (close-port socket))))


 -- Function: cgi:serve-query SERVE-PROC
     reads the "URI" and "query-string" from `(current-input-port)'.
     If the query is a valid `"POST"' or `"GET"' query, then
     `cgi:serve-query' calls SERVE-PROC with three arguments, the
     REQUEST-LINE, QUERY-STRING, and HEADER-ALIST.  Otherwise,
     `cgi:serve-query' calls SERVE-PROC with the REQUEST-LINE, #f, and
     HEADER-ALIST.

     If SERVE-PROC returns a string, it is sent to
     `(current-input-port)'.  If SERVE-PROC returns a list, then an
     error page with number 525 and strings from the list.  If
     SERVE-PROC returns #f, then a `Bad Request' (400) page is sent to
     `(current-input-port)'.

     Otherwise, `cgi:serve-query' replies (to `(current-input-port)')
     with appropriate HTML describing the problem.

 -- Function: make-query-alist-command-server RDB COMMAND-TABLE


 -- Function: make-query-alist-command-server RDB COMMAND-TABLE #T

     Returns a procedure of one argument.  When that procedure is
     called with a QUERY-ALIST (as returned by `uri:decode-query', the
     value of the `*command*' association will be the command invoked
     in COMMAND-TABLE.  If `*command*' is not in the QUERY-ALIST then
     the value of `*suggest*' is tried.  If neither name is in the
     QUERY-ALIST, then the literal value `*default*' is tried in
     COMMAND-TABLE.

     If optional third argument is non-false, then the command is
     called with just the parameter-list; otherwise, command is called
     with the arguments described in its table.




File: slib.info, Node: Parsing HTML, Next: URI, Prev: HTTP and CGI, Up: Textual Conversion Packages

Parsing HTML
============

  `(require 'html-for-each)'


 -- Function: html-for-each FILE WORD-PROC MARKUP-PROC WHITE-PROC NEWLINE-PROC

     FILE is an input port or a string naming an existing file
     containing HTML text.  WORD-PROC is a procedure of one argument
     or #f.  MARKUP-PROC is a procedure of one argument or #f.
     WHITE-PROC is a procedure of one argument or #f.  NEWLINE-PROC is
     a procedure of no arguments or #f.

     `html-for-each' opens and reads characters from port FILE or the
     file named by string FILE.  Sequential groups of characters are
     assembled into strings which are either

        * enclosed by `<' and `>' (hypertext markups or comments);
        * end-of-line;
        * whitespace; or
        * none of the above (words).

     Procedures are called according to these distinctions in order of
     the string's occurrence in FILE.

     NEWLINE-PROC is called with no arguments for end-of-line *not
     within a markup or comment*.

     WHITE-PROC is called with strings of non-newline whitespace.

     MARKUP-PROC is called with hypertext markup strings (including
     `<' and `>').

     WORD-PROC is called with the remaining strings.

     `html-for-each' returns an unspecified value.

 -- Function: html:read-title FILE LIMIT


 -- Function: html:read-title FILE
     FILE is an input port or a string naming an existing file
     containing HTML text.  If supplied, LIMIT must be an integer.
     LIMIT defaults to 1000.

     `html:read-title' opens and reads HTML from port FILE or the file
     named by string FILE, until reaching the (mandatory) `TITLE'
     field.  `html:read-title' returns the title string with adjacent
     whitespaces collapsed to one space.  `html:read-title' returns #f
     if the title field is empty, absent, if the first character read
     from FILE is not `#\<', or if the end of title is not found
     within the first (approximately) LIMIT words.

 -- Function: htm-fields HTM

     HTM is a hypertext markup string.

     If HTM is a (hypertext) comment, then `htm-fields' returns #f.
     Otherwise `htm-fields' returns the hypertext element symbol
     (created by `string-ci->symbol') consed onto an association list
     of the attribute name-symbols and values.  Each value is a number
     or string; or #t if the name had no value assigned within the
     markup.




File: slib.info, Node: URI, Next: Printing Scheme, Prev: Parsing HTML, Up: Textual Conversion Packages

URI
===

  `(require 'uri)'

described in RFC 2396.


 -- Function: make-uri


 -- Function: make-uri FRAGMENT

 -- Function: make-uri QUERY FRAGMENT

 -- Function: make-uri PATH QUERY FRAGMENT

 -- Function: make-uri AUTHORITY PATH QUERY FRAGMENT

 -- Function: make-uri SCHEME AUTHORITY PATH QUERY FRAGMENT

     Returns a Uniform Resource Identifier string from component
     arguments.

 -- Function: uri:make-path PATH

     Returns a URI string combining the components of list PATH.

 -- Function: html:anchor NAME
     Returns a string which defines this location in the (HTML) file
     as NAME.  The hypertext `<A HREF="#NAME">' will link to this
     point.

          (html:anchor "(section 7)")
          =>
          "<A NAME=\"(section%207)\"></A>"

 -- Function: html:link URI HIGHLIGHTED
     Returns a string which links the HIGHLIGHTED text to URI.

          (html:link (make-uri "(section 7)") "section 7")
          =>
          "<A HREF=\"#(section%207)\">section 7</A>"

 -- Function: html:base URI
     Returns a string specifying the "base" URI of a document, for
     inclusion in the HEAD of the document (*Note head: HTML.).

 -- Function: html:isindex PROMPT
     Returns a string specifying the search PROMPT of a document, for
     inclusion in the HEAD of the document (*Note head: HTML.).

 -- Function: uri->tree URI-REFERENCE BASE-TREE


 -- Function: uri->tree URI-REFERENCE

     Returns a list of 5 elements corresponding to the parts (SCHEME
     AUTHORITY PATH QUERY FRAGMENT) of string URI-REFERENCE.  Elements
     corresponding to absent parts are #f.

     The PATH is a list of strings.  If the first string is empty,
     then the path is absolute; otherwise relative.  The optional
     BASE-TREE is a tree as returned by `uri->tree'; and is used as
     the base address for relative URIs.

     If the AUTHORITY component is a "Server-based Naming Authority",
     then it is a list of the USERINFO, HOST, and PORT strings (or
     #f).  For other types of AUTHORITY components the AUTHORITY will
     be a string.

          (uri->tree "http://www.ics.uci.edu/pub/ietf/uri/#Related")
          =>
          (http "www.ics.uci.edu" ("" "pub" "ietf" "uri" "") #f "Related")

 -- Function: uri:split-fields TXT CHR

     Returns a list of TXT split at each occurrence of CHR.  CHR does
     not appear in the returned list of strings.

 -- Function: uri:decode-query QUERY-STRING
     Converts a "URI" encoded QUERY-STRING to a query-alist.

URI-components.


 -- Function: uric:encode URI-COMPONENT ALLOWS
     Returns a copy of the string URI-COMPONENT in which all "unsafe"
     octets (as defined in RFC 2396) have been `%' "escaped".
     `uric:decode' decodes strings encoded by `uric:encode'.

 -- Function: uric:decode URI-COMPONENT
     Returns a copy of the string URI-COMPONENT in which each `%'
     escaped characters in URI-COMPONENT is replaced with the
     character it encodes.  This routine is useful for showing URI
     contents on error pages.

 -- Function: uri:path->keys PATH-LIST PTYPES
     PATH-LIST is a path-list as returned by `uri:split-fields'.
     `uri:path->keys' returns a list of items returned by
     `uri:decode-path', coerced to types PTYPES.

File-system Locators and Predicates
-----------------------------------


 -- Function: path->uri PATH
     Returns a URI-string for PATH on the local host.

 -- Function: absolute-uri? STR
     Returns #t if STR is an absolute-URI as indicated by a
     syntactically valid (per RFC 2396) "scheme"; otherwise returns
     #f.

 -- Function: absolute-path? FILE-NAME
     Returns #t if FILE-NAME is a fully specified pathname (does not
     depend on the current working directory); otherwise returns #f.

 -- Function: null-directory? STR
     Returns #t if changing directory to STR would leave the current
     directory unchanged; otherwise returns #f.

  -- Function: glob-pattern? STR Returns #t if the string STR contains
characters used for specifying glob patterns, namely `*', `?', or `['.
Before RFC 2396, the "File Transfer Protocol" (FTP) served a similar
purpose.


 -- Function: parse-ftp-address URI

     Returns a list of the decoded FTP URI; or #f if indecipherable.
     FTP "Uniform Resource Locator", "ange-ftp", and "getit" formats
     are handled.  The returned list has four elements which are
     strings or #f:

       0. username
       1. password
       2. remote-site
       3. remote-directory





File: slib.info, Node: Printing Scheme, Next: Time and Date, Prev: URI, Up: Textual Conversion Packages

Printing Scheme
===============

* Menu:

* Generic-Write::               'generic-write
* Object-To-String::            'object->string
* Pretty-Print::                'pretty-print, 'pprint-file




File: slib.info, Node: Generic-Write, Next: Object-To-String, Prev: Printing Scheme, Up: Printing Scheme

Generic-Write
-------------

  `(require 'generic-write)'

  `generic-write' is a procedure that transforms a Scheme data value
(or Scheme program expression) into its textual representation and
prints it.  The interface to the procedure is sufficiently general to
easily implement other useful formatting procedures such as pretty
printing, output to a string and truncated output.

 -- Procedure: generic-write OBJ DISPLAY? WIDTH OUTPUT
     OBJ
          Scheme data value to transform.
     DISPLAY?
          Boolean, controls whether characters and strings are quoted.
     WIDTH
          Extended boolean, selects format:
          #f
               single line format
          integer > 0
               pretty-print (value = max nb of chars per line)
     OUTPUT
          Procedure of 1 argument of string type, called repeatedly
          with successive substrings of the textual representation.
          This procedure can return `#f' to stop the transformation.

     The value returned by `generic-write' is undefined.

     Examples: (write obj) == (generic-write obj #f #f DISPLAY-STRING)
     (display obj) == (generic-write obj #t #f DISPLAY-STRING) where
          DISPLAY-STRING ==
          (lambda (s) (for-each write-char (string->list s)) #t)





File: slib.info, Node: Object-To-String, Next: Pretty-Print, Prev: Generic-Write, Up: Printing Scheme

Object-To-String
----------------

  `(require 'object->string)'


 -- Function: object->string OBJ
     Returns the textual representation of OBJ as a string.

 -- Function: object->limited-string OBJ LIMIT
     Returns the textual representation of OBJ as a string of length
     at most LIMIT.




File: slib.info, Node: Pretty-Print, Prev: Object-To-String, Up: Printing Scheme

Pretty-Print
------------

  `(require 'pretty-print)'

 -- Procedure: pretty-print OBJ
 -- Procedure: pretty-print OBJ PORT

     `pretty-print's OBJ on PORT.  If PORT is not specified,
     `current-output-port' is used.

     Example:
          (pretty-print '((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15)
                          (16 17 18 19 20) (21 22 23 24 25)))
             -| ((1 2 3 4 5)
             -|  (6 7 8 9 10)
             -|  (11 12 13 14 15)
             -|  (16 17 18 19 20)
             -|  (21 22 23 24 25))

 -- Procedure: pretty-print->string OBJ
 -- Procedure: pretty-print->string OBJ WIDTH

     Returns the string of OBJ `pretty-print'ed in WIDTH columns.  If
     WIDTH is not specified, `(output-port-width)' is used.

     Example:
          (pretty-print->string '((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15)
                                  (16 17 18 19 20) (21 22 23 24 25)))
          =>
          "((1 2 3 4 5)
           (6 7 8 9 10)
           (11 12 13 14 15)
           (16 17 18 19 20)
           (21 22 23 24 25))
          "
          (pretty-print->string '((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15)
                                  (16 17 18 19 20) (21 22 23 24 25))
                                16)
          =>
          "((1 2 3 4 5)
           (6 7 8 9 10)
           (11
            12
            13
            14
            15)
           (16
            17
            18
            19
            20)
           (21
            22
            23
            24
            25))
          "


  `(require 'pprint-file)'

 -- Procedure: pprint-file INFILE
 -- Procedure: pprint-file INFILE OUTFILE
     Pretty-prints all the code in INFILE.  If OUTFILE is specified,
     the output goes to OUTFILE, otherwise it goes to
     `(current-output-port)'.

 -- Function: pprint-filter-file INFILE PROC OUTFILE
 -- Function: pprint-filter-file INFILE PROC
     INFILE is a port or a string naming an existing file.  Scheme
     source code expressions and definitions are read from the port
     (or file) and PROC is applied to them sequentially.

     OUTFILE is a port or a string.  If no OUTFILE is specified then
     `current-output-port' is assumed.  These expanded expressions are
     then `pretty-print'ed to this port.

     Whitepsace and comments (introduced by `;') which are not part of
     scheme expressions are reproduced in the output.  This procedure
     does not affect the values returned by `current-input-port' and
     `current-output-port'.

  `pprint-filter-file' can be used to pre-compile macro-expansion and
thus can reduce loading time.  The following will write into
`exp-code.scm' the result of expanding all defmacros in `code.scm'.
     (require 'pprint-file)
     (require 'defmacroexpand)
     (defmacro:load "my-macros.scm")
     (pprint-filter-file "code.scm" defmacro:expand* "exp-code.scm")



File: slib.info, Node: Time and Date, Next: NCBI-DNA, Prev: Printing Scheme, Up: Textual Conversion Packages

Time and Date
=============

* Menu:

* Time Zone::                   
* Posix Time::                  'posix-time
* Common-Lisp Time::            'common-lisp-time

If `(provided? 'current-time)':

  The procedures `current-time', `difftime', and `offset-time' deal
with a "calendar time" datatype which may or may not be disjoint from
other Scheme datatypes.

 -- Function: current-time
     Returns the time since 00:00:00 GMT, January 1, 1970, measured in
     seconds.  Note that the reference time is different from the
     reference time for `get-universal-time' in *Note Common-Lisp
     Time::.

 -- Function: difftime CALTIME1 CALTIME0
     Returns the difference (number of seconds) between twe calendar
     times: CALTIME1 - CALTIME0.  CALTIME0 may also be a number.

 -- Function: offset-time CALTIME OFFSET
     Returns the calendar time of CALTIME offset by OFFSET number of
     seconds `(+ caltime offset)'.



File: slib.info, Node: Time Zone, Next: Posix Time, Prev: Time and Date, Up: Time and Date

Time Zone
---------

  (require 'time-zone)

 -- Data Format: TZ-string

     POSIX standards specify several formats for encoding time-zone
     rules.

     :<pathname>
          If the first character of <pathname> is `/', then <pathname>
          specifies the absolute pathname of a tzfile(5) format
          time-zone file.  Otherwise, <pathname> is interpreted as a
          pathname within TZFILE:VICINITY (/usr/lib/zoneinfo/) naming
          a tzfile(5) format time-zone file.
     <std><offset>
          The string <std> consists of 3 or more alphabetic
          characters.  <offset> specifies the time difference from
          GMT.  The <offset> is positive if the local time zone is
          west of the Prime Meridian and negative if it is east.
          <offset> can be the number of hours or hours and minutes
          (and optionally seconds) separated by `:'.  For example,
          `-4:30'.
     <std><offset><dst>
          <dst> is the at least 3 alphabetic characters naming the
          local daylight-savings-time.
     <std><offset><dst><doffset>
          <doffset> specifies the offset from the Prime Meridian when
          daylight-savings-time is in effect.

     The non-tzfile formats can optionally be followed by transition
     times specifying the day and time when a zone changes from
     standard to daylight-savings and back again.

     ,<date>/<time>,<date>/<time>
          The <time>s are specified like the <offset>s above, except
          that leading `+' and `-' are not allowed.

          Each <date> has one of the formats:

          J<day>
               specifies the Julian day with <day> between 1 and 365.
               February 29 is never counted and cannot be referenced.
          <day>
               This specifies the Julian day with n between 0 and 365.
               February 29 is counted in leap years and can be
               specified.
          M<month>.<week>.<day>
               This specifies day <day> (0 <= <day> <= 6) of week
               <week> (1 <= <week> <= 5) of month <month> (1 <=
               <month> <= 12).  Week 1 is the first week in which day
               d occurs and week 5 is the last week in which day <day>
               occurs.  Day 0 is a Sunday.


 -- Data Type: time-zone
     is a datatype encoding how many hours from Greenwich Mean Time
     the local time is, and the "Daylight Savings Time" rules for
     changing it.

 -- Function: time-zone TZ-STRING
     Creates and returns a time-zone object specified by the string
     TZ-STRING.  If `time-zone' cannot interpret TZ-STRING, `#f' is
     returned.

 -- Function: tz:params CALTIME TZ
     TZ is a time-zone object.  `tz:params' returns a list of three
     items:
       0. An integer.  0 if standard time is in effect for timezone TZ
          at CALTIME; 1 if daylight savings time is in effect for
          timezone TZ at CALTIME.
       1. The number of seconds west of the Prime Meridian timezone TZ
          is at CALTIME.
       2. The name for timezone TZ at CALTIME.

     `tz:params' is unaffected by the default timezone; inquiries can
     be made of any timezone at any calendar time.


 -- Function: tz:std-offset TZ
     TZ is a time-zone object.  `tz:std-offset' returns the number of
     seconds west of the Prime Meridian timezone TZ is.


The rest of these procedures and variables are provided for POSIX
compatability.  Because of shared state they are not thread-safe.

 -- Function: tzset

Returns the default time-zone.
 -- Function: tzset TZ

Sets (and returns) the default time-zone to TZ.
 -- Function: tzset TZ-STRING
     Sets (and returns) the default time-zone to that specified by
     TZ-STRING.

     `tzset' also sets the variables *TIMEZONE*, DAYLIGHT?, and
     TZNAME.  This function is automatically called by the time
     conversion procedures which depend on the time zone (*Note Time
     and Date::).

 -- Variable: *timezone*
     Contains the difference, in seconds, between Greenwich Mean Time
     and local standard time (for example, in the U.S.  Eastern time
     zone (EST), timezone is 5*60*60).  `*timezone*' is initialized by
     `tzset'.

 -- Variable: daylight?
     is `#t' if the default timezone has rules for "Daylight Savings
     Time".  *Note:* DAYLIGHT? does not tell you when Daylight Savings
     Time is in effect, just that the default zone sometimes has
     Daylight Savings Time.

 -- Variable: tzname
     is a vector of strings.  Index 0 has the abbreviation for the
     standard timezone; If DAYLIGHT?, then index 1 has the
     abbreviation for the Daylight Savings timezone.




File: slib.info, Node: Posix Time, Next: Common-Lisp Time, Prev: Time Zone, Up: Time and Date

Posix Time
----------

     (require 'posix-time)

 -- Data Type: Calendar-Time
     is a datatype encapsulating time.

 -- Data Type: Coordinated Universal Time
     (abbreviated "UTC") is a vector of integers representing time:

       0.  seconds (0 - 61)
       1.  minutes (0 - 59)
       2.  hours since midnight (0 - 23)
       3.  day of month (1 - 31)
       4.  month (0 - 11).  Note difference from
          `decode-universal-time'.
       5.  the number of years since 1900.  Note difference from
          `decode-universal-time'.
       6.  day of week (0 - 6)
       7.  day of year (0 - 365)
       8.  1 for daylight savings, 0 for regular time

 -- Function: gmtime CALTIME

Converts the calendar time CALTIME to UTC and returns it.
 -- Function: localtime CALTIME TZ

Returns CALTIME converted to UTC relative to timezone TZ.
 -- Function: localtime CALTIME
     converts the calendar time CALTIME to a vector of integers
     expressed relative to the user's time zone.  `localtime' sets the
     variable *TIMEZONE* with the difference between Coordinated
     Universal Time (UTC) and local standard time in seconds (*Note
     tzset: Time Zone.).


 -- Function: gmktime UNIVTIME

Converts a vector of integers in GMT Coordinated Universal Time
(UTC) format to a calendar time.
 -- Function: mktime UNIVTIME

Converts a vector of integers in local Coordinated Universal Time
(UTC) format to a calendar time.
 -- Function: mktime UNIVTIME TZ
     Converts a vector of integers in Coordinated Universal Time (UTC)
     format (relative to time-zone TZ) to calendar time.

 -- Function: asctime UNIVTIME
     Converts the vector of integers CALTIME in Coordinated Universal
     Time (UTC) format into a string of the form `"Wed Jun 30 21:49:08
     1993"'.

 -- Function: gtime CALTIME
 -- Function: ctime CALTIME
 -- Function: ctime CALTIME TZ
     Equivalent to `(asctime (gmtime CALTIME))', `(asctime (localtime
     CALTIME))', and `(asctime (localtime CALTIME TZ))', respectively.




File: slib.info, Node: Common-Lisp Time, Prev: Posix Time, Up: Time and Date

Common-Lisp Time
----------------

 -- Function: get-decoded-time
     Equivalent to `(decode-universal-time (get-universal-time))'.

 -- Function: get-universal-time
     Returns the current time as "Universal Time", number of seconds
     since 00:00:00 Jan 1, 1900 GMT.  Note that the reference time is
     different from `current-time'.

 -- Function: decode-universal-time UNIVTIME
     Converts UNIVTIME to "Decoded Time" format.  Nine values are
     returned:
       0.  seconds (0 - 61)
       1.  minutes (0 - 59)
       2.  hours since midnight
       3.  day of month
       4.  month (1 - 12).  Note difference from `gmtime' and
          `localtime'.
       5.  year (A.D.).  Note difference from `gmtime' and
          `localtime'.
       6.  day of week (0 - 6)
       7.  #t for daylight savings, #f otherwise
       8.  hours west of GMT (-24 - +24)

     Notice that the values returned by `decode-universal-time' do not
     match the arguments to `encode-universal-time'.

 -- Function: encode-universal-time SECOND MINUTE HOUR DATE MONTH YEAR
 -- Function: encode-universal-time SECOND MINUTE HOUR DATE MONTH YEAR TIME-ZONE
     Converts the arguments in Decoded Time format to Universal Time
     format.  If TIME-ZONE is not specified, the returned time is
     adjusted for daylight saving time.  Otherwise, no adjustment is
     performed.

     Notice that the values returned by `decode-universal-time' do not
     match the arguments to `encode-universal-time'.




File: slib.info, Node: NCBI-DNA, Next: Schmooz, Prev: Time and Date, Up: Textual Conversion Packages

NCBI-DNA
========


 -- Function: ncbi:read-dna-sequence PORT

     Reads the NCBI-format DNA sequence following the word `ORIGIN'
     from PORT.

 -- Function: ncbi:read-file FILE

     Reads the NCBI-format DNA sequence following the word `ORIGIN'
     from FILE.

 -- Function: mrna<-cdna STR

     Replaces `T' with `U' in STR

 -- Function: codons<-cdna CDNA

     Returns a list of three-letter symbol codons comprising the
     protein sequence encoded by CDNA starting with its first
     occurence of `atg'.

 -- Function: protein<-cdna CDNA

     Returns a list of three-letter symbols for the protein sequence
     encoded by CDNA starting with its first occurence of `atg'.

 -- Function: p<-cdna CDNA

     Returns a string of one-letter amino acid codes for the protein
     sequence encoded by CDNA starting with its first occurence of
     `atg'.

  These cDNA count routines provide a means to check the nucleotide
sequence with the `BASE COUNT' line preceding the sequence from NCBI.


 -- Function: cdna:base-count CDNA

     Returns a list of counts of `a', `c', `g', and `t' occurrencing
     in CDNA.

 -- Function: cdna:report-base-count CDNA

     Prints the counts of `a', `c', `g', and `t' occurrencing in CDNA.




File: slib.info, Node: Schmooz, Prev: NCBI-DNA, Up: Textual Conversion Packages

Schmooz
=======


  "Schmooz" is a simple, lightweight markup language for interspersing
Texinfo documentation with Scheme source code.  Schmooz does not
create the top level Texinfo file; it creates `txi' files which can be
imported into the documentation using the Texinfo command `@include'.

  `(require 'schmooz)' defines the function `schmooz', which is used
to process files.  Files containing schmooz documentation should not
contain `(require 'schmooz)'.

 -- Procedure: schmooz FILENAME.SCM ...

FILENAME.scm should be a string ending with `.scm' naming an
existing file containing Scheme source code.  `schmooz' extracts
top-level comments containing schmooz commands from FILENAME.scm
and writes the converted Texinfo source to a file named
FILENAME.txi.
 -- Procedure: schmooz FILENAME.TEXI ...
 -- Procedure: schmooz FILENAME.TEX ...
 -- Procedure: schmooz FILENAME.TXI ...
     FILENAME should be a string naming an existing file containing
     Texinfo source code.  For every occurrence of the string
     `@include FILENAME.txi' within that file, `schmooz' calls itself
     with the argument `FILENAME.scm'.

  Schmooz comments are distinguished (from non-schmooz comments) by
their first line, which must start with an at-sign (@) preceded by one
or more semicolons (;).  A schmooz comment ends at the first
subsequent line which does *not* start with a semicolon.  Currently
schmooz comments are recognized only at top level.

  Schmooz comments are copied to the Texinfo output file with the
leading contiguous semicolons removed.  Certain character sequences
starting with at-sign are treated specially.  Others are copied
unchanged.

  A schmooz comment starting with `@body' must be followed by a Scheme
definition.  All comments between the `@body' line and the definition
will be included in a Texinfo definition, either a `@defun' or a
`@defvar', depending on whether a procedure or a variable is being
defined.

  Within the text of that schmooz comment, at-sign followed by `0'
will be replaced by `@code{procedure-name}' if the following
definition is of a procedure; or `@var{variable}' if defining a
variable.

  An at-sign followed by a non-zero digit will expand to the variable
citation of that numbered argument: `@var{argument-name}'.

  If more than one definition follows a `@body' comment line without
an intervening blank or comment line, then those definitions will be
included in the same Texinfo definition using `@defvarx' or `@defunx',
depending on whether the first definition is of a variable or of a
procedure.

  Schmooz can figure out whether a definition is of a procedure if it
is of the form:

  `(define (<identifier> <arg> ...) <expression>)'

or if the left hand side of the definition is some form ending in a
lambda expression.  Obviously, it can be fooled.  In order to force
recognition of a procedure definition, start the documentation with
`@args' instead of `@body'.  `@args' should be followed by the
argument list of the function being defined, which may be enclosed in
parentheses and delimited by whitespace, (as in Scheme), enclosed in
braces and separated by commas, (as in Texinfo), or consist of the
remainder of the line, separated by whitespace.

  For example:

     ;;@args arg1 args ...
     ;;@0 takes argument @1 and any number of @2
     (define myfun (some-function-returning-magic))

  Will result in:

     @defun myfun arg1 args @dots{}

     @code{myfun} takes argument @var{arg1} and any number of @var{args}
     @end defun

  `@args' may also be useful for indicating optional arguments by
name.  If `@args' occurs inside a schmooz comment section, rather than
at the beginning, then it will generate a `@defunx' line with the
arguments supplied.


  If the first at-sign in a schmooz comment is immediately followed by
whitespace, then the comment will be expanded to whatever follows that
whitespace.  If the at-sign is followed by a non-whitespace character
then the at-sign will be included as the first character of the
expansion.  This feature is intended to make it easy to include
Texinfo directives in schmooz comments.





File: slib.info, Node: Mathematical Packages, Next: Database Packages, Prev: Textual Conversion Packages, Up: Top

Mathematical Packages
*********************

* Menu:

* Bit-Twiddling::               'logical
* Modular Arithmetic::          'modular
* Prime Numbers::               'factor
* Random Numbers::              'random
* Fast Fourier Transform::      'fft
* Cyclic Checksum::             'crc
* Graphing::                    
* Solid Modeling::              VRML97
* Color::                       
* Root Finding::                'root
* Minimizing::                  'minimize
* Commutative Rings::           'commutative-ring
* Matrix Algebra::              'determinant




File: slib.info, Node: Bit-Twiddling, Next: Modular Arithmetic, Prev: Mathematical Packages, Up: Mathematical Packages

Bit-Twiddling
=============

  `(require 'logical)'

  The bit-twiddling functions are made available through the use of
the `logical' package.  `logical' is loaded by inserting `(require
'logical)' before the code that uses these functions.  These functions
behave as though operating on integers in two's-complement
representation.


Bitwise Operations
------------------

 -- Function: logand N1 N1
     Returns the integer which is the bit-wise AND of the two integer
     arguments.

     Example:
          (number->string (logand #b1100 #b1010) 2)
             => "1000"

 -- Function: logior N1 N2
     Returns the integer which is the bit-wise OR of the two integer
     arguments.

     Example:
          (number->string (logior #b1100 #b1010) 2)
             => "1110"

 -- Function: logxor N1 N2
     Returns the integer which is the bit-wise XOR of the two integer
     arguments.

     Example:
          (number->string (logxor #b1100 #b1010) 2)
             => "110"

 -- Function: lognot N
     Returns the integer which is the 2s-complement of the integer
     argument.

     Example:
          (number->string (lognot #b10000000) 2)
             => "-10000001"
          (number->string (lognot #b0) 2)
             => "-1"

 -- Function: bitwise-if MASK N0 N1
     Returns an integer composed of some bits from integer N0 and some
     from integer N1.  A bit of the result is taken from N0 if the
     corresponding bit of integer MASK is 1 and from N1 if that bit of
     MASK is 0.

 -- Function: logtest J K
          (logtest j k) == (not (zero? (logand j k)))

          (logtest #b0100 #b1011) => #f
          (logtest #b0100 #b0111) => #t

 -- Function: logcount N
     Returns the number of bits in integer N.  If integer is positive,
     the 1-bits in its binary representation are counted.  If
     negative, the 0-bits in its two's-complement binary
     representation are counted.  If 0, 0 is returned.

     Example:
          (logcount #b10101010)
             => 4
          (logcount 0)
             => 0
          (logcount -2)
             => 1



Bit Within Word
---------------

 -- Function: logbit? INDEX J
          (logbit? index j) == (logtest (integer-expt 2 index) j)

          (logbit? 0 #b1101) => #t
          (logbit? 1 #b1101) => #f
          (logbit? 2 #b1101) => #t
          (logbit? 3 #b1101) => #t
          (logbit? 4 #b1101) => #f

 -- Function: copy-bit INDEX FROM BIT
     Returns an integer the same as FROM except in the INDEXth bit,
     which is 1 if BIT is `#t' and 0 if BIT is `#f'.

     Example:
          (number->string (copy-bit 0 0 #t) 2)       => "1"
          (number->string (copy-bit 2 0 #t) 2)       => "100"
          (number->string (copy-bit 2 #b1111 #f) 2)  => "1011"


Fields of Bits
--------------

 -- Function: logical:ones N
     Returns the smallest non-negative integer having N binary ones.

 -- Function: bit-field N START END
     Returns the integer composed of the START (inclusive) through END
     (exclusive) bits of N.  The STARTth bit becomes the 0-th bit in
     the result.

     Example:
          (number->string (bit-field #b1101101010 0 4) 2)
             => "1010"
          (number->string (bit-field #b1101101010 4 9) 2)
             => "10110"

 -- Function: copy-bit-field TO START END FROM
     Returns an integer the same as TO except possibly in the START
     (inclusive) through END (exclusive) bits, which are the same as
     those of FROM.  The 0-th bit of FROM becomes the STARTth bit of
     the result.

     Example:
          (number->string (copy-bit-field #b1101101010 0 4 0) 2)
                  => "1101100000"
          (number->string (copy-bit-field #b1101101010 0 4 -1) 2)
                  => "1101101111"

 -- Function: ash N COUNT
     Returns an integer equivalent to `(inexact->exact (floor (* N
     (expt 2 COUNT))))'.

     Example:
          (number->string (ash #b1 3) 2)
             => "1000"
          (number->string (ash #b1010 -1) 2)
             => "101"

 -- Function: integer-length N
     Returns the number of bits neccessary to represent N.

     Example:
          (integer-length #b10101010)
             => 8
          (integer-length 0)
             => 0
          (integer-length #b1111)
             => 4

 -- Function: integer-expt N K
     Returns N raised to the non-negative integer exponent K.

     Example:
          (integer-expt 2 5)
             => 32
          (integer-expt -3 3)
             => -27


Bit order and Lamination
------------------------

 -- Function: logical:rotate K COUNT LEN
     Returns the low-order LEN bits of K cyclically permuted COUNT
     bits towards high-order.

     Example:
          (number->string (logical:rotate #b0100 3 4) 2)
          => "10"
          (number->string (logical:rotate #b0100 -1 4) 2)
          => "10"

 -- Function: bit-reverse K N
     Returns the low-order K bits of N with the bit order reversed.
     The low-order bit of N is the high order bit of the returned
     value.

          (number->string (bit-reverse 8 #xa7) 16)
            => "e5"

 -- Function: integer->list K LEN
 -- Function: integer->list K

`integer->list' returns a list of LEN booleans corresponding to
each bit of the given integer.  #t is coded for each 1; #f for 0.
The LEN argument defaults to `(integer-length K)'.
 -- Function: list->integer LIST
     `list->integer' returns an integer formed from the booleans in
     the list LIST, which must be a list of booleans.  A 1 bit is
     coded for each #t; a 0 bit for #f.

     `integer->list' and `list->integer' are inverses so far as
     `equal?' is concerned.

 -- Function: booleans->integer BOOL1 ...
     Returns the integer coded by the BOOL1 ... arguments.

 -- Function: bitwise:laminate K1 ...

Returns an integer composed of the bits of K1 ... interlaced in
argument order.  Given K1, ... KN, the n low-order bits of the
returned value will be the lowest-order bit of each argument.
 -- Function: bitwise:delaminate COUNT K
     Returns a list of COUNT integers comprised of every COUNTh bit of
     the integer K.

     For any non-negative integers K and COUNT:
          (eqv? k (bitwise:laminate (bitwise:delaminate count k)))



Gray code
---------

A "Gray code" is an ordering of non-negative integers in which exactly
one bit differs between each pair of successive elements.  There are
multiple Gray codings.  An n-bit Gray code corresponds to a
Hamiltonian cycle on an n-dimensional hypercube.

Gray codes find use communicating incrementally changing values
between asynchronous agents.  De-laminated Gray codes comprise the
coordinates of Peano-Hilbert space-filling curves.


 -- Function: integer->gray-code K

Converts K to a Gray code of the same `integer-length' as K.
 -- Function: gray-code->integer K
     Converts the Gray code K to an integer of the same
     `integer-length' as K.

     For any non-negative integer K,
          (eqv? k (gray-code->integer (integer->gray-code k)))

 -- Function: = K1 K2
 -- Function: gray-code<? K1 K2
 -- Function: gray-code>? K1 K2
 -- Function: gray-code<=? K1 K2
 -- Function: gray-code>=? K1 K2
     These procedures return #t if their Gray code arguments are
     (respectively): equal, monotonically increasing, monotonically
     decreasing, monotonically nondecreasing, or monotonically
     nonincreasing.

     For any non-negative integers K1 and K2, the Gray code predicate
     of `(integer->gray-code k1)' and `(integer->gray-code k2)' will
     return the same value as the corresponding predicate of K1 and
     K2.






File: slib.info, Node: Modular Arithmetic, Next: Prime Numbers, Prev: Bit-Twiddling, Up: Mathematical Packages

Modular Arithmetic
==================

  `(require 'modular)'


 -- Function: mod X1 X2
 -- Function: rem X1 X2

     These procedures implement the Common-Lisp functions of the same
     names.  The real number X2 must be non-zero.  `mod' returns `(-
     X1 (* X2 (floor (/ X1 X2))))'.  `rem' returns `(- X1 (* X2
     (truncate (/ X1 X2))))'.

     If X1 and X2 are integers, then `mod' behaves like `modulo' and
     `rem' behaves like `remainder'.

     (mod -90 360)                          => 270
     (rem -90 180)                          => -90

     (mod 540 360)                          => 180
     (rem 540 360)                          => 180

     (mod (* 5/2 pi) (* 2 pi))              => 1.5707963267948965
     (rem (* -5/2 pi) (* 2 pi))             => -1.5707963267948965


 -- Function: extended-euclid N1 N2

     Returns a list of 3 integers `(d x y)' such that d = gcd(N1, N2)
     = N1 * x + N2 * y.

 -- Function: symmetric:modulus N

     Returns `(quotient (+ -1 n) -2)' for positive odd integer N.

 -- Function: modulus->integer MODULUS

     Returns the non-negative integer characteristic of the ring
     formed when MODULUS is used with `modular:' procedures.

 -- Function: modular:normalize MODULUS N

     Returns the integer `(modulo N (modulus->integer MODULUS))' in
the representation specified by MODULUS.  The rest of these functions
assume normalized arguments; That is, the arguments are constrained by
the following table:

For all of these functions, if the first argument (MODULUS) is:
`positive?'
     Work as before.  The result is between 0 and MODULUS.

`zero?'
     The arguments are treated as integers.  An integer is returned.

`negative?'
     The arguments and result are treated as members of the integers
     modulo `(+ 1 (* -2 MODULUS))', but with "symmetric"
     representation; i.e. `(<= (- MODULUS) N MODULUS)'.

If all the arguments are fixnums the computation will use only
fixnums.


 -- Function: modular:invertable? MODULUS K

     Returns `#t' if there exists an integer n such that K * n
     == 1 mod MODULUS, and `#f' otherwise.

 -- Function: modular:invert MODULUS N2

     Returns an integer n such that 1 = (n * N2) mod MODULUS.  If N2
     has no inverse mod MODULUS an error is signaled.

 -- Function: modular:negate MODULUS N2

     Returns (-N2) mod MODULUS.

 -- Function: modular:+ MODULUS N2 N3

     Returns (N2 + N3) mod MODULUS.

 -- Function: modular:- MODULUS N2 N3

     Returns (N2 - N3) mod MODULUS.

 -- Function: modular:* MODULUS N2 N3

     Returns (N2 * N3) mod MODULUS.

     The Scheme code for `modular:*' with negative MODULUS is not
     completed for fixnum-only implementations.

 -- Function: modular:expt MODULUS N2 N3

     Returns (N2 ^ N3) mod MODULUS.




File: slib.info, Node: Prime Numbers, Next: Random Numbers, Prev: Modular Arithmetic, Up: Mathematical Packages

Prime Numbers
=============

  `(require 'factor)'


 -- Variable: prime:prngs

  PRIME:PRNGS is the random-state (*Note Random Numbers::) used by
these procedures.  If you call these procedures from more than one
thread (or from interrupt), `random' may complain about reentrant
calls.  *Note:* The prime test and generation procedures implement (or
use) the Solovay-Strassen primality test. See

   * Robert Solovay and Volker Strassen, `A Fast Monte-Carlo Test for
     Primality', SIAM Journal on Computing, 1977, pp 84-85.


 -- Function: jacobi-symbol P Q

     Returns the value (+1, -1, or 0) of the Jacobi-Symbol of exact
     non-negative integer P and exact positive odd integer Q.

 -- Variable: prime:trials

     PRIME:TRIALS the maxinum number of iterations of Solovay-Strassen
     that will be done to test a number for primality.

 -- Function: prime? N

     Returns `#f' if N is composite; `#t' if N is prime.  There is a
     slight chance `(expt 2 (- prime:trials))' that a composite will
     return `#t'.

 -- Function: primes< START COUNT

     Returns a list of the first COUNT prime numbers less than START.
     If there are fewer than COUNT prime numbers less than START, then
     the returned list will have fewer than START elements.

 -- Function: primes> START COUNT

     Returns a list of the first COUNT prime numbers greater than
     START.

 -- Function: factor K

     Returns a list of the prime factors of K.  The order of the
     factors is unspecified.  In order to obtain a sorted list do
     `(sort! (factor K) <)'.




File: slib.info, Node: Random Numbers, Next: Fast Fourier Transform, Prev: Prime Numbers, Up: Mathematical Packages

Random Numbers
==============

  A pseudo-random number generator is only as good as the tests it
passes.  George Marsaglia of Florida State University developed a
battery of tests named "DIEHARD"
(`http://stat.fsu.edu/~geo/diehard.html').  `diehard.c' has a bug
which the patch
`http://swissnet.ai.mit.edu/ftpdir/users/jaffer/diehard.c.pat'
corrects.

  SLIB's PRNG generates 8 bits at a time.  With the degenerate seed
`0', the numbers generated pass DIEHARD; but when bits are combined
from sequential bytes, tests fail.  With the seed
`http://swissnet.ai.mit.edu/~jaffer/SLIB.html', all of those tests
pass.

* Menu:

* Exact Random Numbers::        'random
* Inexact Random Numbers::      'random-inexact



File: slib.info, Node: Exact Random Numbers, Next: Inexact Random Numbers, Prev: Random Numbers, Up: Random Numbers

Exact Random Numbers
--------------------

  `(require 'random)'




 -- Function: random N STATE


 -- Function: random N

     N must be an exact positive integer.  `random' returns an exact
     integer between zero (inclusive) and N (exclusive).  The values
     returned by `random' are uniformly distributed from 0 to N.

     The optional argument STATE must be of the type returned by
     `(seed->random-state)' or `(make-random-state)'.  It defaults to
     the value of the variable `*random-state*'.  This object is used
     to maintain the state of the pseudo-random-number generator and
     is altered as a side effect of calls to `random'.
 -- Variable: *random-state*
     Holds a data structure that encodes the internal state of the
     random-number generator that `random' uses by default.  The
     nature of this data structure is implementation-dependent.  It
     may be printed out and successfully read back in, but may or may
     not function correctly as a random-number state object in another
     implementation.


 -- Function: copy-random-state STATE


Returns a new copy of argument STATE.

 -- Function: copy-random-state
     Returns a new copy of `*random-state*'.

 -- Function: seed->random-state SEED

     Returns a new object of type suitable for use as the value of the
     variable `*random-state*' or as a second argument to `random'.
     The number or string SEED is used to initialize the state.  If
     `seed->random-state' is called twice with arguments which are
     `equal?', then the returned data structures will be `equal?'.
     Calling `seed->random-state' with unequal arguments will nearly
     always return unequal states.

 -- Function: make-random-state


 -- Function: make-random-state OBJ
     Returns a new object of type suitable for use as the value of the
     variable `*random-state*' or as a second argument to `random'.
     If the optional argument OBJ is given, it should be a printable
     Scheme object; the first 50 characters of its printed
     representation will be used as the seed.  Otherwise the value of
     `*random-state*' is used as the seed.






File: slib.info, Node: Inexact Random Numbers, Prev: Exact Random Numbers, Up: Random Numbers

Inexact Random Numbers
----------------------

  `(require 'random-inexact)'


 -- Function: random:uniform


 -- Function: random:uniform STATE
     Returns an uniformly distributed inexact real random number in
     the range between 0 and 1.

 -- Function: random:exp


 -- Function: random:exp STATE
     Returns an inexact real in an exponential distribution with mean 1.  For
     an exponential distribution with mean U use
     `(* U (random:exp))'.

 -- Function: random:normal


 -- Function: random:normal STATE
     Returns an inexact real in a normal distribution with mean 0 and
     standard deviation 1.  For a normal distribution with mean M and
     standard deviation D use
     `(+ M (* D (random:normal)))'.

 -- Procedure: random:normal-vector! VECT


 -- Procedure: random:normal-vector! VECT STATE
     Fills VECT with inexact real random numbers which are independent
     and standard normally distributed (i.e., with mean 0 and variance
     1).

 -- Procedure: random:hollow-sphere! VECT


 -- Procedure: random:hollow-sphere! VECT STATE
     Fills VECT with inexact real random numbers the sum of whose
     squares is equal to 1.0.  Thinking of VECT as coordinates in
     space of dimension n = `(vector-length VECT)', the coordinates
     are uniformly distributed over the surface of the unit n-shere.

 -- Procedure: random:solid-sphere! VECT


 -- Procedure: random:solid-sphere! VECT STATE
     Fills VECT with inexact real random numbers the sum of whose
     squares is less than 1.0.  Thinking of VECT as coordinates in
     space of dimension N = `(vector-length VECT)', the coordinates
     are uniformly distributed within the unit N-shere.  The sum of
     the squares of the numbers is returned.




File: slib.info, Node: Fast Fourier Transform, Next: Cyclic Checksum, Prev: Random Numbers, Up: Mathematical Packages

Fast Fourier Transform
======================

  `(require 'fft)'


 -- Function: fft ARRAY

     ARRAY is an array of `(expt 2 n)' numbers.  `fft' returns an
     array of complex numbers comprising the "Discrete Fourier
     Transform" of ARRAY.

 -- Function: fft-1 ARRAY

     `fft-1' returns an array of complex numbers comprising the
inverse Discrete Fourier Transform of ARRAY.  `(fft-1 (fft ARRAY))'
will return an array of values close to ARRAY.

     (fft '#(1 0+i -1 0-i 1 0+i -1 0-i)) =>

     #(0.0 0.0 0.0+628.0783185208527e-18i 0.0
       0.0 0.0 8.0-628.0783185208527e-18i 0.0)

     (fft-1 '#(0 0 0 0 0 0 8 0)) =>

     #(1.0 -61.23031769111886e-18+1.0i -1.0 61.23031769111886e-18-1.0i
       1.0 -61.23031769111886e-18+1.0i -1.0 61.23031769111886e-18-1.0i)




File: slib.info, Node: Cyclic Checksum, Next: Graphing, Prev: Fast Fourier Transform, Up: Mathematical Packages

Cyclic Checksum
===============

  `(require 'crc)' Cyclic Redundancy Checks using Galois field GF(2)
polynomial arithmetic are used for error detection in many data
transmission and storage applications.

The generator polynomials for various CRC protocols are availble from
many sources.  But the polynomial is just one of many parameters which
must match in order for a CRC implementation to interoperate with
existing systems:


   * the byte-order and bit-order of the data stream;

   * whether the CRC or its inverse is being calculated;

   * the initial CRC value; and

   * whether and where the CRC value is appended (inverted or
     non-inverted) to the data stream.


There is even some controversy over the polynomials themselves.

 -- Constant: crc-32-polynomial
     For CRC-32,
     http://www2.sis.pitt.edu/~jkabara/tele-2100/lect08.html gives
     x^32+x^26+x^23+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+1.

     But
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,
     http://spinroot.com/spin/Doc/Book91_PDF/ch3.pdf,
     http://www.erg.abdn.ac.uk/users/gorry/course/dl-pages/crc.html,
     http://www.rad.com/networks/1994/err_con/crc_most.htm, and
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html,
     http://www.nobugconsulting.ro/crc.php give
     x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

     SLIB `crc-32-polynomial' uses the latter definition.

 -- Constant: crc-ccitt-polynomial

     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,
     http://www2.sis.pitt.edu/~jkabara/tele-2100/lect08.html, and
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html give CRC-CCITT:
     x^16+x^12+x^5+1.

 -- Constant: crc-16-polynomial

     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html, and
     http://www.usb.org/developers/data/crcdes.pdf give CRC-16:
     x^16+x^15+x^2+1.

 -- Constant: crc-12-polynomial

     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,
     http://www.it.iitb.ac.in/it605/lectures/link/node4.html, and
     http://spinroot.com/spin/Doc/Book91_PDF/ch3.pdf give CRC-12:
     x^12+x^11+x^3+x^2+1.

     But
     http://www.ffldusoe.edu/Faculty/Denenberg/Topics/Networks/Error_Detection_Correction/crc.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,
     http://www.eng.uwi.tt/depts/elec/staff/kimal/errorcc.html,
     http://www.ee.uwa.edu.au/~roberto/teach/itc314/java/CRC/,
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html, and
     http://www.efg2.com/Lab/Mathematics/CRC.htm give CRC-12:
     x^12+x^11+x^3+x^2+x+1.

     These differ in bit 1 and calculations using them return
     different values.  With citations near evenly split, it is hard
     to know which is correct.

 -- Constant: crc-10-polynomial

     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html
     gives CRC-10: x^10+x^9+x^5+x^4+1; but
     http://cell-relay.indiana.edu/cell-relay/publications/software/CRC/crc10.html,
     http://www.it.iitb.ac.in/it605/lectures/link/node4.html,
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html,
     http://www.techfest.com/networking/atm/atm.htm,
     http://www.protocols.com/pbook/atmcell2.htm, and
     http://www.nobugconsulting.ro/crc.php give CRC-10:
     x^10+x^9+x^5+x^4+x+1.

 -- Constant: crc-08-polynomial

     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,
     http://www.it.iitb.ac.in/it605/lectures/link/node4.html, and
     http://www.nobugconsulting.ro/crc.php give CRC-8: x^8+x^2+x^1+1

 -- Constant: atm-hec-polynomial

     http://cell-relay.indiana.edu/cell-relay/publications/software/CRC/32bitCRC.tutorial.html
     and http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html give ATM HEC:
     x^8+x^2+x+1.

 -- Constant: dowcrc-polynomial

     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html
     gives DOWCRC: x^8+x^5+x^4+1.

 -- Constant: usb-token-polynomial

     http://www.usb.org/developers/data/crcdes.pdf and
     http://www.nobugconsulting.ro/crc.php give USB-token: x^5+x^2+1.

Each of these polynomial constants is a string of `1's and `0's, the
exponent of each power of X in descending order.

 -- Function: crc:make-table POLY

     POLY must be string of `1's and `0's beginning with `1' and
     having length greater than 8.  `crc:make-table' returns a vector
     of 256 integers, such that:

          (set! CRC
                (logxor (ash (logand (+ -1 (ash 1 (- DEG 8))) CRC) 8)
                        (vector-ref CRC-TABLE
                                    (logxor (ash CRC (- 8 DEG)) BYTE))))

     will compute the CRC with the 8 additional bits in BYTE; where
     CRC is the previous accumulated CRC value, DEG is the degree of
     POLY, and CRC-TABLE is the vector returned by `crc:make-table'.

     If the implementation does not support DEG-bit integers, then
     `crc:make-table' returns #f.



 -- Function: cksum FILE


Computes the P1003.2/D11.2 (POSIX.2) 32-bit checksum of FILE.

     (require 'crc)
     (cksum (in-vicinity (library-vicinity) "ratize.scm"))
     => 157103930
 -- Function: cksum PORT
     Computes the checksum of the bytes read from PORT until the
     end-of-file.


`cksum-string', which returns the P1003.2/D11.2 (POSIX.2) 32-bit
checksum of the bytes in STR, can be defined as follows:

     (require 'string-port)
     (define (cksum-string str) (call-with-input-string str cksum))

 -- Function: crc16 FILE


Computes the USB data-packet (16-bit) CRC of FILE.
 -- Function: crc16 PORT
     Computes the USB data-packet (16-bit) CRC of the bytes read from
     PORT until the end-of-file.

     `crc16' calculates the same values as the crc16.pl program given
     in http://www.usb.org/developers/data/crcdes.pdf.


 -- Function: crc5 FILE


Computes the USB token (5-bit) CRC of FILE.
 -- Function: crc5 PORT
     Computes the USB token (5-bit) CRC of the bytes read from PORT
     until the end-of-file.

     `crc5' calculates the same values as the crc5.pl program given in
     http://www.usb.org/developers/data/crcdes.pdf.




File: slib.info, Node: Graphing, Next: Solid Modeling, Prev: Cyclic Checksum, Up: Mathematical Packages

Graphing
========

* Menu:

* Character Plotting::          
* PostScript Graphing::         



File: slib.info, Node: Character Plotting, Next: PostScript Graphing, Prev: Graphing, Up: Graphing

Character Plotting
------------------

  `(require 'charplot)'

 -- Variable: charplot:dimensions
     A list of the maximum height (number of lines) and maximum width
     (number of columns) for the graph, its scales, and labels.

     The default value for CHARPLOT:DIMENSIONS is the
     `output-port-height' and `output-port-width' of
     `current-output-port'.

 -- Procedure: plot COORDS X-LABEL Y-LABEL
     COORDS is a list or vector of coordinates, lists of x and y
     coordinates.  X-LABEL and Y-LABEL are strings with which to label
     the x and y axes.

     Example:
          (require 'charplot)
          (set! charplot:dimensions '(20 55))

          (define (make-points n)
            (if (zero? n)
                '()
                (cons (list (/ n 6) (sin (/ n 6))) (make-points (1- n)))))

          (plot (make-points 40) "x" "Sin(x)")
          -|
            Sin(x)   _________________________________________
                   1|-       ****                             |
                    |      **    **                           |
                0.75|-    *        *                          |
                    |    *          *                         |
                 0.5|-  *            *                        |
                    |  *                                     *|
                0.25|-                *                     * |
                    | *                *                      |
                   0|-------------------*------------------*--|
                    |                                     *   |
               -0.25|-                   *               *    |
                    |                     *             *     |
                -0.5|-                     *                  |
                    |                       *          *      |
               -0.75|-                       *        *       |
                    |                         **    **        |
                  -1|-                          ****          |
                    |:_____._____:_____._____:_____._____:____|
               x                 2           4           6

 -- Procedure: plot FUNC X1 X2
 -- Procedure: plot FUNC X1 X2 NPTS
     Plots the function of one argument FUNC over the range X1 to X2.
     If the optional integer argument NPTS is supplied, it specifies
     the number of points to evaluate FUNC at.

          (plot sin 0 (* 2 pi))
          -|
                     _________________________________________
                   1|-:       ****                            |
                    | :     **    **                          |
                0.75|-:    *        *                         |
                    | :   *          *                        |
                 0.5|-:  **          **                       |
                    | : *             *                       |
                0.25|-:**              **                     |
                    | :*                *                     |
                   0|-*------------------*--------------------|
                    | :                  *                 *  |
               -0.25|-:                   **              **  |
                    | :                    *             *    |
                -0.5|-:                     *           **    |
                    | :                      *          *     |
               -0.75|-:                       *       **      |
                    | :                        **    **       |
                  -1|-:                          ****         |
                    |_:_____._____:_____._____:_____._____:___|
                      0           2           4           6

 -- Procedure: histograph DATA LABEL
     Creates and displays a histogram of the numerical values
     contained in vector or list DATA

          (require 'random-inexact)
          (histograph (do ((idx 99 (+ -1 idx))
                           (lst '() (cons (* .02 (random:normal)) lst)))
                          ((negative? idx) lst))
                      "normal")
          -|
                     _________________________________________
                   8|-                :    I                  |
                    |                 :    I                  |
                   7|-           I  I :    I                  |
                    |            I  I :    I                  |
                   6|-          III I :I   I                  |
                    |           III I :I   I                  |
                   5|-          IIIIIIIIII I                  |
                    |           IIIIIIIIII I                  |
                   4|-          IIIIIIIIIIII                  |
                    |           IIIIIIIIIIII                  |
                   3|-I    I I  IIIIIIIIIIII  II     I        |
                    | I    I I  IIIIIIIIIIII  II     I        |
                   2|-I    I I IIIIIIIIIIIIIIIII     I        |
                    | I    I I IIIIIIIIIIIIIIIII     I        |
                   1|-II I I IIIIIIIIIIIIIIIIIIIII   I I I    |
                    | II I I IIIIIIIIIIIIIIIIIIIII   I I I    |
                   0|-IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII----|
                    |__.____:____.____:____.____:____.____:___|
            normal        -0.025      0       0.025      0.05




File: slib.info, Node: PostScript Graphing, Prev: Character Plotting, Up: Graphing

PostScript Graphing
-------------------

  `(require 'eps-graph)'

This is a graphing package creating encapsulated-PostScript files.
Its motivations and design choice are described in
`http://swissnet.ai.mit.edu/~jaffer/Docupage/grapheps'

A dataset to be plotted is taken from a 2-dimensional array.
Corresponding coordinates are in rows.  Coordinates from any pair of
columns can be plotted.


 -- Function: create-postscript-graph FILENAME.EPS SIZE ELT1 ...

     FILENAME.EPS should be a string naming an output file to be
     created.  SIZE should be an exact integer, a list of two exact
     integers, or #f.  ELT1, ... are values returned by graphing
     primitives described here.

     `create-postscript-graph' creates an "Encapsulated-PostScript"
     file named FILENAME.EPS containing graphs as directed by the
     ELT1, ... arguments.

     The size of the graph is determined by the SIZE argument.  If a
list of two integers, they specify the width and height.  If one
integer, then that integer is the width and the height is 3/4 of the
width.  If #f, the graph will be 800 by 600.  These graphing
procedures should be called as arguments to `create-postscript-graph'.
The order of these arguments is significant; PostScript graphics state
is affected serially from the first ELT argument to the last.


 -- Function: whole-page

     Pushes a rectangle for the whole encapsulated page onto the
     PostScript stack.  This pushed rectangle is an implicit argument
     to `partition-page' or `setup-plot'.
* Menu:

* Column Ranges::               
* Drawing the Graph::           
* Graphics Context::            
* Rectangles::                   
* Legending::
* Legacy Plotting::
* Example Graph::



File: slib.info, Node: Column Ranges, Next: Drawing the Graph, Prev: PostScript Graphing, Up: PostScript Graphing

Column Ranges
.............

  A "range" is a list of two numbers, the minimum and the maximum.
Ranges can be given explicity or computed in PostScript by
`column-range'.


 -- Function: column-range ARRAY K

     Returns the range of values in 2-dimensional ARRAY column K.

 -- Function: pad-range RANGE P

     Expands RANGE by P/100 on each end.

 -- Function: snap-range RANGE

     Expands RANGE to round number of ticks.

 -- Function: combine-ranges RANGE1 RANGE2 ...

     Returns the minimal range covering all RANGE1, RANGE2, ...

 -- Function: setup-plot X-RANGE Y-RANGE PAGERECT


 -- Function: setup-plot X-RANGE Y-RANGE
     X-RANGE and Y-RANGE should each be a list of two numbers or the
     value returned by `pad-range', `snap-range', or `combine-range'.
     PAGERECT is the rectangle bounding the graph to be drawn; if
     missing, the rectangle from the top of the PostScript stack is
     popped and used.

     Based on the given ranges, `setup-plot' sets up scaling and
     margins for making a graph.  The margins are sized proportional
     to the FONTHEIGHT value at the time of the call to setup-plot.
     `setup-plot' sets two variables:

     PLOTRECT
          The region where data points will be plotted.
     GRAPHRECT
          The PAGERECT argument to `setup-plot'.  Includes plotrect,
          legends, etc.


File: slib.info, Node: Drawing the Graph, Next: Graphics Context, Prev: Column Ranges, Up: PostScript Graphing

Drawing the Graph
.................


 -- Function: plot-column ARRAY X-COLUMN Y-COLUMN PROC3S

     Plots points with x coordinate in X-COLUMN of ARRAY and y
coordinate Y-COLUMN of ARRAY.  The symbol PROC3S specifies the type of
glyph or drawing style for presenting these coordinates.  The glyphs
and drawing styles available are:

`line'
     Draws line connecting points in order.
`mountain'
     Fill area below line connecting points.
`cloud'
     Fill area above line connecting points.
`impulse'
     Draw line from x-axis to each point.
`bargraph'
     Draw rectangle from x-axis to each point.
`disc'
     Solid round dot.
`point'
     Minimal point -- invisible if linewidth is 0.
`square'
     Square box.
`diamond'
     Square box at 45.o
`plus'
     Plus sign.
`cross'
     X sign.
`triup'
     Triangle pointing upward
`tridown'
     Triangle pointing downward
`pentagon'
     Five sided polygon
`circle'
     Hollow circle



File: slib.info, Node: Graphics Context, Next: Rectangles, Prev: Drawing the Graph, Up: PostScript Graphing

Graphics Context
................


 -- Function: in-graphic-context ARG ...

     Saves the current graphics state, executes ARGS, then restores to
     saved graphics state.

 -- Function: set-color COLOR

     COLOR should be a string naming a Resene color, a saturate color,
     or a number between 0 and 100.

     `set-color' sets the PostScript color to the color of the given
     string, or a grey value between black (0) and white (100).

 -- Function: set-font NAME FONTHEIGHT

     NAME should be a (case-sensitive) string naming a PostScript
     font.  FONTHEIGHT should be a positive real number.

     `set-font' Changes the current PostScript font to NAME with
height equal to FONTHEIGHT.  The default font is Helvetica (12pt).
The base set of PostScript fonts is:

Times          Times-Italic      Times-Bold        Times-BoldItalic      
Helvetica      Helvetica-Oblique Helvetica-Bold    Helvetica-BoldOblique 
Courier        Courier-Oblique   Courier-Bold      Courier-BoldOblique   
@end multitable

@noindent
Line parameters do no affect fonts; they do effect glyphs.@refill


@defun set-linewidth w

The default linewidth is 1.  Setting it to 0 makes the lines drawn
as skinny as possible.  Linewidth must be much smaller than
glyphsize for readable glyphs.@refill
@end defun

@defun set-linedash j k

Lines are drawn @var{j}-on @var{k}-off.@refill

@defunx set-linedash j
Lines are drawn @var{j}-on @var{j}-off.@refill

@defunx set-linedash
Turns off dashing.@refill
@end defun

@defun set-glyphsize w

Sets the (PostScript) variable glyphsize to @var{w}.  The default
glyphsize is 6.@refill
@end defun
@noindent
The effects of @code{clip-to-rect} are also part of the graphic
context.@refill

@node Rectangles, Legending, Graphics Context, PostScript Graphing
@subsubsection Rectangles

@noindent
A @dfn{rectangle} is a list of 4 numbers; the first two elements are@refill
@cindex rectangle
the x and y coordinates of lower left corner of the rectangle.  The
other two elements are the width and height of the rectangle.@refill


@defun whole-page

Pushes a rectangle for the whole encapsulated page onto the
PostScript stack.  This pushed rectangle is an implicit argument to
@code{partition-page} or @code{setup-plot}.@refill
@end defun

@defun partition-page xparts yparts

Pops the rectangle currently on top of the stack and pushes @var{xparts} * @var{yparts}
sub-rectangles onto the stack in decreasing y and increasing x order.
If you are drawing just one graph, then you don't need @code{partition-page}.@refill
@end defun

@defvar plotrect

The rectangle where data points should be plotted.  @var{plotrect} is set by
@code{setup-plot}.@refill
@end defvar

@defvar graphrect

The @var{pagerect} argument of the most recent call to
@code{setup-plot}.  Includes plotrect, legends, etc.@refill
@end defvar

@defun fill-rect rect

fills @var{rect} with the current color.@refill
@end defun

@defun outline-rect rect

Draws the perimiter of @var{rect} in the current color.@refill
@end defun

@defun clip-to-rect rect

Modifies the current graphics-state so that nothing will be drawn
outside of the rectangle @var{rect}.  Use @code{in-graphic-context} to limit
the extent of @code{clip-to-rect}.@refill
@end defun
@node Legending, Legacy Plotting, Rectangles, PostScript Graphing
@subsubsection Legending


@defun title-top title subtitle


@defunx title-top title
Puts a @var{title} line and an optional @var{subtitle} line above the @code{graphrect}.@refill
@end defun

@defun title-bottom title subtitle


@defunx title-bottom title
Puts a @var{title} line and an optional @var{subtitle} line below the @code{graphrect}.@refill
@end defun

@defvar topedge
@defvarx bottomedge

These edge coordinates of @code{graphrect} are suitable for passing
as the first argument to @code{rule-horizontal}.@refill
@end defvar

@defvar leftedge
@defvarx rightedge

These edge coordinates of @code{graphrect} are suitable for passing
as the first argument to @code{rule-vertical}.@refill
@end defvar

@defun rule-vertical x-coord text tick-width

Draws a vertical ruler with X coordinate @var{x-coord} and labeled with string
@var{text}.  If @var{tick-width} is positive, then the ticks are @var{tick-width} long on the right side
of @var{x-coord}; and @var{text} and numeric legends are on the left.  If @var{tick-width} is
negative, then the ticks are -@var{tick-width} long on the left side of @var{x-coord}; and @var{text}
and numeric legends are on the right.@refill
@end defun

@defun rule-horizontal x-coord text tick-height

Draws a horizontal ruler with X coordinate @var{x-coord} and labeled with
string @var{text}.  If @var{tick-height} is positive, then the ticks are @var{tick-height} long on the
right side of @var{x-coord}; and @var{text} and numeric legends are on the left.  If @var{tick-height}
is negative, then the ticks are -@var{tick-height} long on the left side of @var{x-coord}; and
@var{text} and numeric legends are on the right.@refill
@end defun

@defun y-axis

Draws the y-axis.@refill
@end defun

@defun x-axis

Draws the x-axis.@refill
@end defun

@defun grid-verticals

Draws vertical lines through @code{graphrect} at each tick on the
vertical ruler.@refill
@end defun

@defun grid-horizontals

Draws horizontal lines through @code{graphrect} at each tick on the
horizontal ruler.@refill
@end defun
@node Legacy Plotting, Example Graph, Legending, PostScript Graphing
@subsubsection Legacy Plotting


@defvar graph:dimensions

A list of the width and height of the graph to be plotted using
@code{plot}.@refill
@end defvar

@defun plot func x1 x2 npts


@defunx plot func x1 x2
Creates and displays using @code{(system "gv tmp.eps")} an
encapsulated PostScript graph of the function of one argument @var{func}
over the range @var{x1} to @var{x2}.  If the optional integer argument @var{npts} is
supplied, it specifies the number of points to evaluate @var{func} at.@refill

@defunx plot coords x-label y-label
@var{coords} is a list or vector of coordinates, lists of x and y
coordinates.  @var{x-label} and @var{y-label} are strings with which
to label the x and y axes.@refill
@end defun
@node Example Graph,  , Legacy Plotting, PostScript Graphing
@subsubsection Example Graph

@noindent
The file @file{am1.5.html}, a table of solar irradiance, is fetched
with @samp{wget} if it isn't already in the working directory.  The
file is read and stored into an array, @var{irradiance}.@refill

@code{create-postscript-graph} is then called to create an
encapsulated-PostScript file, @file{solarad.eps}.  The size of the
page is set to 600 by 300.  @code{whole-page} is called and leaves
the rectangle on the PostScript stack.  @code{setup-plot} is called
with a literal range for x and computes the range for column 1.@refill

Two calls to @code{top-title} are made so a different font can be
used for the lower half.  @code{in-graphic-context} is used to limit
the scope of the font change.  The graphing area is outlined and a
rule drawn on the left side.@refill

Because the X range was intentionally reduced,
@code{in-graphic-context} is called and @code{clip-to-rect} limits
drawing to the plotting area.  A black line is drawn from data
column 1.  That line is then overlayed with a mountain plot of the
same column colored "Bright Sun".@refill

After returning from the @code{in-graphic-context}, the bottom ruler
is drawn.  Had it been drawn earlier, all its ticks would have been
painted over by the mountain plot.@refill

The color is then changed to @samp{seagreen} and the same graphrect
is setup again, this time with a different Y scale, 0 to 1000.  The
graphic context is again clipped to @var{plotrect}, linedash is set,
and column 2 is plotted as a dashed line.  Finally the rightedge is
ruled.  Having the line and its scale both in green helps
disambiguate the scales.@refill

@example
(require 'eps-graph)
(require 'line-i/o)
(require 'string-port)

(define irradiance
  (let ((url "http://www.pv.unsw.edu.au/am1.5.html")
        (file "am1.5.html"))
    (define (read->list line)
      (define elts '())
      (call-with-input-string line
        (lambda (iprt) (do ((elt (read iprt) (read iprt)))
                           ((eof-object? elt) elts)
                         (set! elts (cons elt elts))))))
    (if (not (file-exists? file))
        (system (string-append "wget -c -O" file " " url)))
    (call-with-input-file file
      (lambda (iprt)
        (define lines '())
        (do ((line (read-line iprt) (read-line iprt)))
            ((eof-object? line)
             (let ((nra (create-array (Ar64)
                                      (length lines)
                                      (length (car lines)))))
               (do ((lns lines (cdr lns))
                    (idx (+ -1 (length lines)) (+ -1 idx)))
                   ((null? lns) nra)
                 (do ((kdx (+ -1 (length (car lines))) (+ -1 kdx))
                      (lst (car lns) (cdr lst)))
                     ((null? lst))
                   (array-set! nra (car lst) idx kdx)))))
          (if (and (positive? (string-length line))
                   (char-numeric? (string-ref line 0)))
              (set! lines (cons (read->list line) lines))))))))

(let ((xrange '(.25 2.5)))
  (create-postscript-graph
   "solarad.eps" '(600 300)
   (whole-page)
   (setup-plot xrange (column-range irradiance 1))
   (title-top
    "Solar Irradiance   http://www.pv.unsw.edu.au/am1.5.html")
   (in-graphic-context
    (set-font "Helvetica-Oblique" 12)
    (title-top
     ""
     "Key Centre for Photovoltaic Engineering UNSW - Air Mass 1.5 Global Spectrum"))
   (outline-rect plotrect)
   (rule-vertical leftedge "W/(m^2.um)" 10)
   (in-graphic-context (clip-to-rect plotrect)
                       (plot-column irradiance 0 1 'line)
                       (set-color "Bright Sun")
                       (plot-column irradiance 0 1 'mountain)
                       )
   (rule-horizontal bottomedge "Wavelength in .um" 5)
   (set-color 'seagreen)

   (setup-plot xrange '(0 1000) graphrect)
   (in-graphic-context (clip-to-rect plotrect)
                       (set-linedash 5 2)
                       (plot-column irradiance 0 2 'line))
   (rule-vertical rightedge "Integrated .W/(m^2)" -10)
   ))

(system "gv solarad.eps")
@end example


@node Solid Modeling, Color, Graphing, Mathematical Packages
@section Solid Modeling

@ifset html
<A NAME="Solid">@refill
@end ifset
@code{(require 'solid)}@refill
@ifset html
</A>@refill
@end ifset
@ftindex solids
@ftindex solid
@ftindex solid-modeling

@noindent
@uref{http://swissnet.ai.mit.edu/~jaffer/Solid/#Example} gives an
example use of this package.@refill


@defun vrml node @dots{}
Returns the VRML97 string (including header) of the concatenation
of strings @var{nodes}, @dots{}.@refill
@end defun

@defun vrml-append node1 node2 @dots{}
Returns the concatenation with interdigitated newlines of
strings @var{node1}, @var{node2}, @dots{}.@refill
@end defun

@defun vrml-to-file file node @dots{}
Writes to file named @var{file} the VRML97 string (including header) of
the concatenation of strings @var{nodes}, @dots{}.@refill
@end defun

@defun world:info title info @dots{}
Returns a VRML97 string setting the title of the file in which
it appears to @var{title}.  Additional strings @var{info}, @dots{} are comments.@refill
@end defun
@noindent

VRML97 strings passed to @code{vrml} and @code{vrml-to-file} as
arguments will appear in the resulting VRML code.  This string turns
off the headlight at the viewpoint:@refill
@example
" NavigationInfo @{headlight FALSE@}"
@end example


@defun scene:panorama front right back left top bottom
Specifies the distant images on the inside faces of the cube
enclosing the virtual world.@refill
@end defun

@defun scene:sphere colors angles


@var{colors} is a list of color objects.  Each may be of type @ref{Color
Data-Type, color}, a 24-bit sRGB integer, or a list of 3 numbers
between 0.0 and 1.0.@refill

@var{angles} is a list of non-increasing angles the same length as
@var{colors}.  Each angle is between 90 and -90 degrees.  If 90 or -90 are not
elements of @var{angles}, then the color at the zenith and nadir are taken from
the colors paired with the angles nearest them.@refill

@code{scene:sphere} fills horizontal bands with interpolated colors on the backgroud
sphere encasing the world.@refill
@end defun

@defun scene:sky-and-dirt
Returns a blue and brown backgroud sphere encasing the world.@refill
@end defun

@defun scene:sky-and-grass
Returns a blue and green backgroud sphere encasing the world.@refill
@end defun

@defun scene:sun latitude julian-day hour turbidity strength


@defunx scene:sun latitude julian-day hour turbidity

@var{latitude} is the virtual place's latitude in degrees.  @var{julian-day} is an integer from
0 to 366, the day of the year.  @var{hour} is a real number from 0 to 24 for
the time of day; 12 is noon.  @var{turbidity} is the degree of fogginess described
in @xref{Daylight, turbidity}.@refill

@code{scene:sun} returns a bright yellow, distant sphere where the sun would be at
@var{hour} on @var{julian-day} at @var{latitude}.  If @var{strength} is positive, included is a light source of @var{strength}
(default 1).@refill
@end defun

@defun scene:overcast latitude julian-day hour turbidity strength


@defunx scene:overcast latitude julian-day hour turbidity

@var{latitude} is the virtual place's latitude in degrees.  @var{julian-day} is an integer from
0 to 366, the day of the year.  @var{hour} is a real number from 0 to 24 for
the time of day; 12 is noon.  @var{turbidity} is the degree of cloudiness described
in @xref{Daylight, turbidity}.@refill

@code{scene:overcast} returns an overcast sky as it might look at @var{hour} on @var{julian-day} at @var{latitude}.  If @var{strength}
is positive, included is an ambient light source of @var{strength} (default 1).@refill
@end defun
@noindent
Viewpoints are objects in the virtual world, and can be transformed
individually or with solid objects.@refill


@defun scene:viewpoint name distance compass pitch


@defunx scene:viewpoint name distance compass
Returns a viewpoint named @var{name} facing the origin and placed @var{distance} from it.
@var{compass} is a number from 0 to 360 giving the compass heading.  @var{pitch} is a
number from -90 to 90, defaulting to 0, specifying the angle from the
horizontal.@refill
@end defun

@defun scene:viewpoints proximity
Returns 6 viewpoints, one at the center of each face of a cube
with sides 2 * @var{proximity}, centered on the origin.@refill
@end defun
@subheading Light Sources

@noindent
In VRML97, lights shine only on objects within the same children node
and descendants of that node.  Although it would have been convenient
to let light direction be rotated by @code{solid:rotation}, this
restricts a rotated light's visibility to objects rotated with it.@refill

@noindent
To workaround this limitation, these directional light source
procedures accept either Cartesian or spherical coordinates for
direction.  A spherical coordinate is a list @code{(@var{theta}
@var{azimuth})}; where @var{theta} is the angle in degrees from the
zenith, and @var{azimuth} is the angle in degrees due west of south.@refill

@noindent
It is sometimes useful for light sources to be brighter than @samp{1}.
When @var{intensity} arguments are greater than 1, these functions
gang multiple sources to reach the desired strength.@refill


@defun light:ambient color intensity


@defunx light:ambient color
Ambient light shines on all surfaces with which it is grouped.@refill

@var{color} is a an object of type @ref{Color Data-Type, color}, a 24-bit sRGB
integer, or a list of 3 numbers between 0.0 and 1.0.  If @var{color} is #f,
then the default color will be used.  @var{intensity} is a real non-negative number
defaulting to @samp{1}.@refill

@code{light:ambient} returns a light source or sources of @var{color} with total strength of @var{intensity}
(or 1 if omitted).@refill
@end defun

@defun light:directional color direction intensity


@defunx light:directional color direction

@defunx light:directional color
Directional light shines parallel rays with uniform intensity on all
objects with which it is grouped.@refill

@var{color} is a an object of type @ref{Color Data-Type, color}, a 24-bit sRGB
integer, or a list of 3 numbers between 0.0 and 1.0.  If @var{color} is #f,
then the default color will be used.@refill

@var{direction} must be a list or vector of 2 or 3 numbers specifying the direction
to this light.  If @var{direction} has 2 numbers, then these numbers are the angle
from zenith and the azimuth in degrees; if @var{direction} has 3 numbers, then
these are taken as a Cartesian vector specifying the direction to the
light source.  The default direction is upwards; thus its light will
shine down.@refill

@var{intensity} is a real non-negative number defaulting to @samp{1}.@refill

@code{light:directional} returns a light source or sources of @var{color} with total strength of @var{intensity},
shining from @var{direction}.@refill
@end defun

@defun light:beam attenuation radius aperture peak


@defunx light:beam attenuation radius aperture

@defunx light:beam attenuation radius

@defunx light:beam attenuation

@var{attenuation} is a list or vector of three nonnegative real numbers specifying
the reduction of intensity, the reduction of intensity with distance,
and the reduction of intensity as the square of distance.  @var{radius} is the
distance beyond which the light does not shine.  @var{radius} defaults to
@samp{100}.@refill

@var{aperture} is a real number between 0 and 180, the angle centered on the
light's axis through which it sheds some light.  @var{peak} is a real number
between 0 and 90, the angle of greatest illumination.@refill
@end defun

@defun light:point location color intensity beam


@defunx light:point location color intensity

@defunx light:point location color

@defunx light:point location

Point light radiates from @var{location}, intensity decreasing with distance,
towards all objects with which it is grouped.@refill

@var{color} is a an object of type @ref{Color Data-Type, color}, a 24-bit sRGB
integer, or a list of 3 numbers between 0.0 and 1.0.  If @var{color} is #f,
then the default color will be used.  @var{intensity} is a real non-negative number
defaulting to @samp{1}.  @var{beam} is a structure returned by
@code{light:beam} or #f.@refill

@code{light:point} returns a light source or sources at @var{location} of @var{color} with total strength
@var{intensity} and @var{beam} properties.  Note that the pointlight itself is not visible.
To make it so, place an object with emissive appearance at @var{location}.@refill
@end defun

@defun light:spot location direction color intensity beam


@defunx light:spot location direction color intensity

@defunx light:spot location direction color

@defunx light:spot location direction

@defunx light:spot location

Spot light radiates from @var{location} towards @var{direction}, intensity decreasing with
distance, illuminating objects with which it is grouped.@refill

@var{direction} must be a list or vector of 2 or 3 numbers specifying the direction
to this light.  If @var{direction} has 2 numbers, then these numbers are the angle
from zenith and the azimuth in degrees; if @var{direction} has 3 numbers, then
these are taken as a Cartesian vector specifying the direction to the
light source.  The default direction is upwards; thus its light will
shine down.@refill

@var{color} is a an object of type @ref{Color Data-Type, color}, a 24-bit sRGB
integer, or a list of 3 numbers between 0.0 and 1.0.  If @var{color} is #f,
then the default color will be used.@refill

@var{intensity} is a real non-negative number defaulting to @samp{1}.@refill

@code{light:spot} returns a light source or sources at @var{location} of @var{direction} with total strength
@var{color}.  Note that the spotlight itself is not visible.  To make it so,
place an object with emissive appearance at @var{location}.@refill
@end defun
@subheading Object Primitives


@defun solid:box geometry appearance


@defunx solid:box geometry
@var{geometry} must be a number or a list or vector of three numbers.  If @var{geometry} is a
number, the @code{solid:box} returns a cube with sides of length @var{geometry} centered on the
origin.  Otherwise, @code{solid:box} returns a rectangular box with dimensions @var{geometry}
centered on the origin.  @var{appearance} determines the surface properties of the
returned object.@refill
@end defun

@defun solid:cylinder radius height appearance


@defunx solid:cylinder radius height
Returns a right cylinder with dimensions @var{radius} and @code{(abs @var{height})}
centered on the origin.  If @var{height} is positive, then the cylinder ends
will be capped.  @var{appearance} determines the surface properties of the returned
object.@refill
@end defun

@defun solid:disk radius thickness appearance


@defunx solid:disk radius thickness
@var{thickness} must be a positive real number.  @code{solid:disk} returns a circular disk
with dimensions @var{radius} and @var{thickness} centered on the origin.  @var{appearance} determines the
surface properties of the returned object.@refill
@end defun

@defun solid:cone radius height appearance


@defunx solid:cone radius height
Returns an isosceles cone with dimensions @var{radius} and @var{height} centered on
the origin.  @var{appearance} determines the surface properties of the returned
object.@refill
@end defun

@defun solid:pyramid side height appearance


@defunx solid:pyramid side height
Returns an isosceles pyramid with dimensions @var{side} and @var{height} centered on
the origin.  @var{appearance} determines the surface properties of the returned
object.@refill
@end defun

@defun solid:sphere radius appearance


@defunx solid:sphere radius
Returns a sphere of radius @var{radius} centered on the origin.  @var{appearance} determines
the surface properties of the returned object.@refill
@end defun

@defun solid:ellipsoid geometry appearance


@defunx solid:ellipsoid geometry
@var{geometry} must be a number or a list or vector of three numbers.  If @var{geometry} is a
number, the @code{solid:ellipsoid} returns a sphere of diameter @var{geometry} centered on the origin.
Otherwise, @code{solid:ellipsoid} returns an ellipsoid with diameters @var{geometry} centered on the
origin.  @var{appearance} determines the surface properties of the returned object.@refill
@end defun

@defun solid:basrelief width height depth colorray appearance


@defunx solid:basrelief width height depth appearance

@defunx solid:basrelief width height depth
One of @var{width}, @var{height}, or @var{depth} must be a 2-dimensional array; the others must
be real numbers giving the length of the basrelief in those
dimensions.  The rest of this description assumes that @var{height} is an
array of heights.@refill

@code{solid:basrelief} returns a @var{width} by @var{depth} basrelief solid with heights per array @var{height} with
the buttom surface centered on the origin.@refill

If present, @var{appearance} determines the surface properties of the returned
object.  If present, @var{colorray} must be an array of objects of type
@ref{Color Data-Type, color}, 24-bit sRGB integers or lists of 3
numbers between 0.0 and 1.0.@refill

If @var{colorray}'s dimensions match @var{height}, then each element of @var{colorray} paints its
corresponding vertex of @var{height}.  If @var{colorray} has all dimensions one smaller
than @var{height}, then each element of @var{colorray} paints the corresponding face of
@var{height}.  Other dimensions for @var{colorray} are in error.@refill
@end defun
@subheading Surface Attributes


@defun solid:color diffuseColor ambientIntensity specularColor shininess emissiveColor transparency


@defunx solid:color diffuseColor ambientIntensity specularColor shininess emissiveColor

@defunx solid:color diffuseColor ambientIntensity specularColor shininess

@defunx solid:color diffuseColor ambientIntensity specularColor

@defunx solid:color diffuseColor ambientIntensity

@defunx solid:color diffuseColor

Returns an @dfn{appearance}, the optical properties of the objects@refill
@cindex appearance
with which it is associated.  @var{ambientIntensity}, @var{shininess}, and @var{transparency} must be numbers between 0
and 1.  @var{diffuseColor}, @var{specularColor}, and @var{emissiveColor} are objects of type @ref{Color Data-Type, color},
24-bit sRGB integers or lists of 3 numbers between 0.0 and 1.0.
If a color argument is omitted or #f, then the default color will be used.@refill
@end defun

@defun solid:texture image color scale rotation center translation


@defunx solid:texture image color scale rotation center

@defunx solid:texture image color scale rotation

@defunx solid:texture image color scale

@defunx solid:texture image color

@defunx solid:texture image

Returns an @dfn{appearance}, the optical properties of the objects@refill
@cindex appearance
with which it is associated.  @var{image} is a string naming a JPEG or PNG
image resource.  @var{color} is #f, a color, or the string returned by
@code{solid:color}.  The rest of the optional arguments specify
2-dimensional transforms applying to the @var{image}.@refill

@var{scale} must be #f, a number, or list or vector of 2 numbers specifying the
scale to apply to @var{image}.  @var{rotation} must be #f or the number of degrees to
rotate @var{image}.  @var{center} must be #f or a list or vector of 2 numbers specifying
the center of @var{image} relative to the @var{image} dimensions.  @var{translation} must be #f or a
list or vector of 2 numbers specifying the translation to apply to @var{image}.@refill
@end defun
@subheading Aggregating Objects


@defun solid:center-row-of number solid spacing
Returns a row of @var{number} @var{solid} objects spaced evenly @var{spacing} apart.@refill
@end defun

@defun solid:center-array-of number-a number-b solid spacing-a spacing-b
Returns @var{number-b} rows, @var{spacing-b} apart, of @var{number-a} @var{solid} objects @var{spacing-a} apart.@refill
@end defun

@defun solid:center-pile-of number-a number-b number-c solid spacing-a spacing-b spacing-c
Returns @var{number-c} planes, @var{spacing-c} apart, of @var{number-b} rows, @var{spacing-b} apart, of @var{number-a} @var{solid} objects @var{spacing-a} apart.@refill
@end defun

@defun solid:arrow center

@var{center} must be a list or vector of three numbers.  Returns an upward
pointing metallic arrow centered at @var{center}.@refill


@defunx solid:arrow
Returns an upward pointing metallic arrow centered at the origin.@refill
@end defun
@subheading Spatial Transformations


@defun solid:translation center solid @dots{}
@var{center} must be a list or vector of three numbers.  @code{solid:translation} Returns an
aggregate of @var{solids}, @dots{} with their origin moved to @var{center}.@refill
@end defun

@defun solid:scale scale solid @dots{}
@var{scale} must be a number or a list or vector of three numbers.  @code{solid:scale}
Returns an aggregate of @var{solids}, @dots{} scaled per @var{scale}.@refill
@end defun

@defun solid:rotation axis angle solid @dots{}
@var{axis} must be a list or vector of three numbers.  @code{solid:rotation} Returns an
aggregate of @var{solids}, @dots{} rotated @var{angle} degrees around the axis @var{axis}.@refill
@end defun


@node Color, Root Finding, Solid Modeling, Mathematical Packages
@section Color

@ifset html
<A NAME="Color"></A>@refill
@end ifset

@uref{http://swissnet.ai.mit.edu/~jaffer/Color}

@noindent
The goals of this package are to provide methods to specify, compute,
and transform colors in a core set of additive color spaces.  The color
spaces supported should be sufficient for working with the color data
encountered in practice and the literature.@refill

@menu
* Color Data-Type::             'color
* Color Spaces::                XYZ, L*a*b*, L*u*v*, L*C*h, RGB709, sRGB
* Spectra::                     Color Temperatures and CIEXYZ(1931)
* Color Difference Metrics::    Society of Dyers and Colorists
* Color Conversions::           Low-level
* Color Names::                 in relational databases
* Daylight::                    Sunlight and sky colors
@end menu

@node Color Data-Type, Color Spaces, Color, Color
@subsection Color Data-Type

@ifset html
<A NAME="Color_Data-Type"></A>@refill
@end ifset
@code{(require 'color)}@refill

@defun color? obj
Returns #t if @var{obj} is a color.@refill

@defunx color? obj typ
Returns #t if @var{obj} is a color of color-space @var{typ}.  The symbol
@var{typ} must be one of:@refill

@itemize @bullet
@item
CIEXYZ@refill
@item
RGB709@refill
@item
L*a*b*@refill
@item
L*u*v*@refill
@item
sRGB@refill
@item
e-sRGB@refill
@item
L*C*h@refill
@end itemize
@end defun

@defun make-color space arg @dots{}
Returns a color of type @var{space}.@refill
@end defun

@defun color-space color
Returns the symbol for the color-space in which @var{color} is embedded.@refill
@end defun

@defun color-precision color
For colors in digital color-spaces, @code{color-precision} returns the
number of bits used for each of the R, G, and B channels of the
encoding.  Otherwise, @code{color-precision} returns #f@refill
@end defun

@defun color-white-point color
Returns the white-point of @var{color} in all color-spaces except CIEXYZ.@refill
@end defun

@defun convert-color color space white-point
@defunx convert-color color space
@defunx convert-color color e-sRGB precision
Converts @var{color} into @var{space} at optional @var{white-point}.@refill
@end defun

@subsubsection External Representation

@noindent
Each color encoding has an external, case-insensitive representation.
To ensure portability, the white-point for all color strings is D65.
@footnote{Readers may recognize these color string formats from Xlib.
X11's color management system was doomed by its fiction that CRT
monitors' (and X11 default) color-spaces were linear RGBi.  Unable to
shed this legacy, the only practical way to view pictures on X is to
ignore its color management system and use an sRGB monitor.  In this
implementation the device-independent RGB709 and sRGB spaces replace the
device-dependent RGBi and RGB spaces of Xlib.}@refill

@multitable @columnfractions .33 .66
@item Color Space
@tab External Representation
@item CIEXYZ
@tab CIEXYZ:@i{<X>}/@i{<Y>}/@i{<Z>}
@item RGB709
@tab RGBi:@i{<R>}/@i{<G>}/@i{<B>}
@item L*a*b*
@tab CIELAB:@i{<L>}/@i{<a>}/@i{<b>}
@item L*u*v*
@tab CIELuv:@i{<L>}/@i{<u>}/@i{<v>}
@item L*C*h
@tab CIELCh:@i{<L>}/@i{<C>}/@i{<h>}
@end multitable

@noindent
The @var{X}, @var{Y}, @var{Z}, @var{L}, @var{a}, @var{b}, @var{u},
@var{v}, @var{C}, @var{h}, @var{R}, @var{G}, and @var{B} fields are
(Scheme) real numbers within the appropriate ranges.@refill

@multitable @columnfractions .33 .66
@item Color Space
@tab External Representation
@item sRGB
@tab sRGB:@i{<R>}/@i{<G>}/@i{<B>}
@item e-sRGB10
@tab e-sRGB10:@i{<R>}/@i{<G>}/@i{<B>}
@item e-sRGB12
@tab e-sRGB12:@i{<R>}/@i{<G>}/@i{<B>}
@item e-sRGB16
@tab e-sRGB16:@i{<R>}/@i{<G>}/@i{<B>}
@end multitable

@noindent
The @var{R}, @var{G}, and @var{B}, fields are non-negative exact decimal
integers within the appropriate ranges.@refill

@noindent
Several additional syntaxes are supported by @code{string->color}:@refill

@multitable @columnfractions .33 .66
@item Color Space
@tab External Representation
@item sRGB
@tab sRGB:@i{<RRGGBB>}
@item sRGB
@tab #@i{<RRGGBB>}
@item sRGB
@tab 0x@i{<RRGGBB>}
@item sRGB
@tab #x@i{<RRGGBB>}
@end multitable

Where @var{RRGGBB} is a non-negative six-digit hexadecimal number.@refill

@defun color->string color
Returns a string representation of @var{color}.@refill
@end defun

@defun string->color string
Returns the color represented by @var{string}.  If @var{string} is not a
syntactically valid notation for a color, then @code{string->color}
returns #f.@refill
@end defun

@subsubsection White

@noindent
We experience color relative to the illumination around us.
CIEXYZ coordinates, although subject to uniform scaling, are
objective.  Thus other color spaces are specified relative to a@refill
@cindex white point
@dfn{white point} in CIEXYZ coordinates.
@cindex white point

@noindent
The white point for digital color spaces is set to D65.  For the other
spaces a @var{white-point} argument can be specified.  The default if
none is specified is the white-point with which the color was created
or last converted; and D65 if none has been specified.@refill

@defvr Constant D65
Is the color of 6500.K (blackbody) illumination.  D65 is close
to the average color of daylight.@refill
@end defvr

@defvr Constant D50
Is the color of 5000.K (blackbody) illumination.  D50 is the color of
indoor lighting by incandescent bulbs, whose filaments have
temperatures around 5000.K.@refill
@end defvr


@node Color Spaces, Spectra, Color Data-Type, Color
@subsection Color Spaces

@ifset html
<A NAME="Color_Spaces"></A>@refill
@end ifset
@subsubheading Measurement-based Color Spaces

@noindent
@cindex tristimulus
The @dfn{tristimulus} color spaces are those whose component values@refill
@cindex tristimulus
are proportional measurements of light intensity.  The CIEXYZ(1931)
system provides 3 sets of spectra to convolve with a spectrum of
interest.  The result of those convolutions is coordinates in CIEXYZ
space.  All tristimuls color spaces are related to CIEXYZ by linear
transforms, namely matrix multiplication.  Of the color spaces listed
here, CIEXYZ and RGB709 are tristimulus spaces.@refill

@deftp {Color Space} CIEXYZ
The CIEXYZ color space covers the full @dfn{gamut}.@refill
@cindex gamut
It is the basis for color-space conversions.@refill

CIEXYZ is a list of three inexact numbers between 0 and 1.1.
'(0. 0. 0.) is black; '(1. 1. 1.) is white.@refill
@end deftp


@defun ciexyz->color xyz

@var{xyz} must be a list of 3 numbers.  If @var{xyz} is valid CIEXYZ coordinates,
then @code{ciexyz->color} returns the color specified by @var{xyz}; otherwise returns #f.@refill
@end defun

@defun color:ciexyz x y z

Returns the CIEXYZ color composed of @var{x}, @var{y}, @var{z}.  If the
coordinates do not encode a valid CIEXYZ color, then an error is
signaled.@refill
@end defun

@defun color->ciexyz color
Returns the list of 3 numbers encoding @var{color} in CIEXYZ.@refill
@end defun
@deftp {Color Space} RGB709
BT.709-4 (03/00) @cite{Parameter values for the HDTV standards for
production and international programme exchange} specifies parameter
values for chromaticity, sampling, signal format, frame rates, etc., of
high definition television signals.@refill

An RGB709 color is represented by a list of three inexact numbers
between 0 and 1.  '(0. 0. 0.) is black '(1. 1. 1.) is white.@refill
@end deftp


@defun rgb709->color rgb

@var{rgb} must be a list of 3 numbers.  If @var{rgb} is valid RGB709 coordinates,
then @code{rgb709->color} returns the color specified by @var{rgb}; otherwise returns #f.@refill
@end defun

@defun color:rgb709 r g b

Returns the RGB709 color composed of @var{r}, @var{g}, @var{b}.  If the
coordinates do not encode a valid RGB709 color, then an error is
signaled.@refill
@end defun

@defun color->rgb709 color
Returns the list of 3 numbers encoding @var{color} in RGB709.@refill
@end defun
@subsubheading Perceptual Uniformity

@noindent
Although properly encoding the chromaticity, tristimulus spaces do not
match the logarithmic response of human visual systems to intensity.
Minimum detectable differences between colors correspond to a smaller
range of distances (6:1) in the L*a*b* and L*u*v* spaces than in
tristimulus spaces (80:1).  For this reason, color distances are
computed in L*a*b* (or L*C*h).@refill

@deftp {Color Space} L*a*b*
Is a CIE color space which better matches the human visual system's
perception of color.  It is a list of three numbers:@refill

@itemize @bullet
@item
0 <= L* <= 100 (CIE @dfn{Lightness})@refill
@cindex Lightness

@item
-500 <= a* <= 500@refill
@item
-200 <= b* <= 200@refill
@end itemize
@end deftp


@defun l*a*b*->color L*a*b* white-point

@var{L*a*b*} must be a list of 3 numbers.  If @var{L*a*b*} is valid L*a*b* coordinates,
then @code{l*a*b*->color} returns the color specified by @var{L*a*b*}; otherwise returns #f.@refill
@end defun

@defun color:l*a*b* L* a* b* white-point

Returns the L*a*b* color composed of @var{L*}, @var{a*}, @var{b*} with @var{white-point}.@refill

@defunx color:l*a*b* L* a* b*
Returns the L*a*b* color composed of @var{L*}, @var{a*}, @var{b*}.  If the coordinates
do not encode a valid L*a*b* color, then an error is signaled.@refill
@end defun

@defun color->l*a*b* color white-point

Returns the list of 3 numbers encoding @var{color} in L*a*b* with @var{white-point}.@refill

@defunx color->l*a*b* color
Returns the list of 3 numbers encoding @var{color} in L*a*b*.@refill
@end defun
@deftp {Color Space} L*u*v*
Is another CIE encoding designed to better match the human visual
system's perception of color.@refill
@end deftp


@defun l*u*v*->color L*u*v* white-point

@var{L*u*v*} must be a list of 3 numbers.  If @var{L*u*v*} is valid L*u*v* coordinates,
then @code{l*u*v*->color} returns the color specified by @var{L*u*v*}; otherwise returns #f.@refill
@end defun

@defun color:l*u*v* L* u* v* white-point

Returns the L*u*v* color composed of @var{L*}, @var{u*}, @var{v*} with @var{white-point}.@refill

@defunx color:l*u*v* L* u* v*
Returns the L*u*v* color composed of @var{L*}, @var{u*}, @var{v*}.  If the coordinates
do not encode a valid L*u*v* color, then an error is signaled.@refill
@end defun

@defun color->l*u*v* color white-point

Returns the list of 3 numbers encoding @var{color} in L*u*v* with @var{white-point}.@refill

@defunx color->l*u*v* color
Returns the list of 3 numbers encoding @var{color} in L*u*v*.@refill
@end defun
@subsubheading Cylindrical Coordinates

@noindent
HSL (Hue Saturation Lightness), HSV (Hue Saturation Value), HSI (Hue
Saturation Intensity) and HCI (Hue Chroma Intensity) are cylindrical
color spaces (with angle hue).  But these spaces are all defined in
terms device-dependent RGB spaces.@refill

@noindent
One might wonder if there is some fundamental reason why intuitive
specification of color must be device-dependent.  But take heart!  A
cylindrical system can be based on L*a*b* and is used for predicting how
close colors seem to observers.@refill

@deftp {Color Space} L*C*h
Expresses the *a and b* of L*a*b* in polar coordinates.  It is a list of
three numbers:@refill

@itemize @bullet
@item
0 <= L* <= 100 (CIE @dfn{Lightness})@refill
@cindex Lightness

@item
C* (CIE @dfn{Chroma}) is the distance from the neutral (gray) axis.@refill
@cindex Chroma
@item
0 <= h <= 360 (CIE @dfn{Hue}) is the angle.@refill
@cindex Hue
@end itemize

The colors by quadrant of h are:@refill

@multitable @columnfractions .20 .60 .20
@item 0 @tab red, orange, yellow @tab 90
@item 90 @tab yellow, yellow-green, green @tab 180
@item 180 @tab green, cyan (blue-green), blue @tab 270
@item 270 @tab blue, purple, magenta @tab 360
@end multitable

@end deftp


@defun l*c*h->color L*C*h white-point

@var{L*C*h} must be a list of 3 numbers.  If @var{L*C*h} is valid L*C*h coordinates,
then @code{l*c*h->color} returns the color specified by @var{L*C*h}; otherwise returns #f.@refill
@end defun

@defun color:l*c*h L* C* h white-point

Returns the L*C*h color composed of @var{L*}, @var{C*}, @var{h} with @var{white-point}.@refill

@defunx color:l*c*h L* C* h
Returns the L*C*h color composed of @var{L*}, @var{C*}, @var{h}.  If the coordinates
do not encode a valid L*C*h color, then an error is signaled.@refill
@end defun

@defun color->l*c*h color white-point

Returns the list of 3 numbers encoding @var{color} in L*C*h with @var{white-point}.@refill

@defunx color->l*c*h color
Returns the list of 3 numbers encoding @var{color} in L*C*h.@refill
@end defun
@subsubheading Digital Color Spaces

@noindent
The color spaces discussed so far are impractical for image data because
of numerical precision and computational requirements.  In 1998 the IEC
adopted @cite{A Standard Default Color Space for the Internet - sRGB}
(@url{http://www.w3.org/Graphics/Color/sRGB}).  sRGB was cleverly
designed to employ the 24-bit (256x256x256) color encoding already in
widespread use; and the 2.2 gamma intrinsic to CRT monitors.@refill

@noindent
Conversion from CIEXYZ to digital (sRGB) color spaces is accomplished by
conversion first to a RGB709 tristimulus space with D65 white-point;
then each coordinate is individually subjected to the same non-linear
mapping.  Inverse operations in the reverse order create the inverse
transform.@refill

@deftp {Color Space} sRGB
Is "A Standard Default Color Space for the Internet".  Most display
monitors will work fairly well with sRGB directly.  Systems using ICC
profiles@refill
@ftindex ICC Profile
@footnote{
@noindent
A comprehensive encoding of transforms between CIEXYZ and device color
spaces is the International Color Consortium profile format,
ICC.1:1998-09:@refill

@quotation
The intent of this format is to provide a cross-platform device profile
format.  Such device profiles can be used to translate color data
created on one device into another device's native color space.@refill
@end quotation
}
should work very well with sRGB.@refill

@end deftp


@defun srgb->color rgb

@var{rgb} must be a list of 3 numbers.  If @var{rgb} is valid sRGB coordinates,
then @code{srgb->color} returns the color specified by @var{rgb}; otherwise returns #f.@refill
@end defun

@defun color:srgb r g b

Returns the sRGB color composed of @var{r}, @var{g}, @var{b}.  If the
coordinates do not encode a valid sRGB color, then an error is
signaled.@refill
@end defun
@deftp {Color Space} xRGB
Represents the equivalent sRGB color with a single 24-bit integer.  The
most significant 8 bits encode red, the middle 8 bits blue, and the
least significant 8 bits green.@refill
@end deftp


@defun color->srgb color

Returns the list of 3 integers encoding @var{color} in sRGB.@refill
@end defun

@defun color->xrgb color
Returns the 24-bit integer encoding @var{color} in sRGB.@refill
@end defun

@defun xrgb->color k

Returns the sRGB color composed of the 24-bit integer @var{k}.@refill
@end defun
@deftp {Color Space} e-sRGB
Is "Photography - Electronic still picture imaging - Extended sRGB color
encoding" (PIMA 7667:2001).  It extends the gamut of sRGB; and its
higher precision numbers provide a larger dynamic range.@refill

A triplet of integers represent e-sRGB colors.  Three precisions are
supported:@refill

@table @r
@item e-sRGB10
0 to 1023@refill
@item e-sRGB12
0 to 4095@refill
@item e-sRGB16
0 to 65535@refill
@end table
@end deftp


@defun e-srgb->color precision rgb
@var{precision} must be the integer 10, 12, or 16.  @var{rgb} must be a list of 3
numbers.  If @var{rgb} is valid e-sRGB coordinates, then @code{e-srgb->color} returns the color
specified by @var{rgb}; otherwise returns #f.@refill
@end defun

@defun color:e-srgb 10 r g b

Returns the e-sRGB10 color composed of integers @var{r}, @var{g}, @var{b}.@refill

@defunx color:e-srgb 12 r g b
Returns the e-sRGB12 color composed of integers @var{r}, @var{g}, @var{b}.@refill

@defunx color:e-srgb 16 r g b
Returns the e-sRGB16 color composed of integers @var{r}, @var{g}, @var{b}.
If the coordinates do not encode a valid e-sRGB color, then an error
is signaled.@refill
@end defun

@defun color->e-srgb precision color
@var{precision} must be the integer 10, 12, or 16.  @code{color->e-srgb} returns the list of 3
integers encoding @var{color} in sRGB10, sRGB12, or sRGB16.@refill
@end defun



























@node Spectra, Color Difference Metrics, Color Spaces, Color
@subsection Spectra

@ifset html
<A NAME="Spectra"></A>@refill
@end ifset
@noindent
The following functions compute colors from spectra, scale color
luminance, and extract chromaticity.  XYZ is used in the names of
procedures for unnormalized colors; the coordinates of CIEXYZ colors are
constrained as described in @ref{Color Spaces}.@refill

@code{(require 'color-space)}@refill

@noindent
A spectrum may be represented as:@refill

@itemize @bullet
@item
A procedure of one argument accepting real numbers from 380e-9 to
780e-9, the wavelength in meters; or@refill
@item
A vector of real numbers representing intensity samples evenly spaced
over some range of wavelengths overlapping the range 380e-9 to 780e-9.@refill
@end itemize

@noindent
CIEXYZ values are calculated as dot-product with the X, Y (Luminance),
and Z @dfn{Spectral Tristimulus Values}.  The files @file{cie1931.xyz}
and @file{cie1964.xyz} in the distribution contain these CIE-defined
values.@refill
@cindex Spectral Tristimulus Values

@deftp {Feature} cie1964
@ftindex cie1964
Loads the Spectral Tristimulus Values defining @cite{CIE 1964
Supplementary Standard Colorimetric Observer}.@refill
@deftpx {Feature} cie1931
@ftindex cie1931
Loads the Spectral Tristimulus Values defining @cite{CIE 1931
Supplementary Standard Colorimetric Observer}.@refill
@deftpx {Feature} ciexyz
@ftindex ciexyz
Requires Spectral Tristimulus Values, defaulting to cie1931.@refill
@end deftp

@noindent
@code{(require 'cie1964)} or @code{(require 'cie1931)} will@refill
@findex load-ciexyz
@code{load-ciexyz} specific values used by the following spectrum
conversion procedures.  The spectrum conversion procedures
@code{(require 'ciexyz)} to assure that a set is loaded.@refill

@defun spectrum->XYZ proc
@var{proc} must be a function of one argument.  @code{spectrum->XYZ}
computes the CIEXYZ(1931) values for the spectrum returned by @var{proc}
when called with arguments from 380e-9 to 780e-9, the wavelength in
meters.@refill

@defunx spectrum->XYZ spectrum x1 x2
@var{x1} and @var{x2} must be positive real numbers specifying the
wavelengths (in meters) corresponding to the zeroth and last elements of
vector or list @var{spectrum}.  @code{spectrum->XYZ} returns the
CIEXYZ(1931) values for a light source with spectral values proportional
to the elements of @var{spectrum} at evenly spaced wavelengths between
@var{x1} and @var{x2}.@refill

Compute the colors of 6500.K and 5000.K blackbody radiation:@refill

@example
(require 'color-space)
(define xyz (spectrum->XYZ (blackbody-spectrum 6500)))
(define y_n (cadr xyz))
(map (lambda (x) (/ x y_n)) xyz)
    @result{} (0.9687111145512467 1.0 1.1210875945303613)

(define xyz (spectrum->XYZ (blackbody-spectrum 5000)))
(map (lambda (x) (/ x y_n)) xyz)
    @result{} (0.2933441826889158 0.2988931825387761 0.25783646831201573)
@end example

@defunx spectrum->CIEXYZ proc
@defunx spectrum->CIEXYZ spectrum x1 x2
@code{spectrum->CIEXYZ} computes the CIEXYZ(1931) values for the
spectrum, scaled so their sum is 1.@refill
@end defun

@defun spectrum->chromaticity proc
@defunx spectrum->chromaticity spectrum x1 x2
Computes the chromaticity for the given spectrum.@refill
@end defun

@defun wavelength->XYZ w
@defunx wavelength->chromaticity w
@defunx wavelength->CIEXYZ w
@var{w} must be a number between 380e-9 to 780e-9.
@code{wavelength->XYZ} returns (unnormalized) XYZ values for a
monochromatic light source with wavelength @var{w}.
@code{wavelength->chromaticity} returns the chromaticity for a
monochromatic light source with wavelength @var{w}.
@code{wavelength->CIEXYZ} returns XYZ values for the saturated color
having chromaticity of a monochromatic light source with wavelength
@var{w}.@refill
@end defun

@defun blackbody-spectrum temp
@defunx blackbody-spectrum temp span
Returns a procedure of one argument (wavelength in meters), which
returns the radiance of a black body at @var{temp}.@refill

The optional argument @var{span} is the wavelength analog of bandwidth.
With the default @var{span} of 1.nm (1e-9.m), the values returned by the
procedure correspond to the power of the photons with wavelengths
@var{w} to @var{w}+1e-9.@refill
@end defun

@defun temperature->XYZ x
The positive number @var{x} is a temperature in degrees kelvin.
@code{temperature->XYZ} computes the CIEXYZ(1931) values for the
spectrum of a black body at temperature @var{x}.@refill

Compute the chromaticities of 6500.K and 5000.K blackbody radiation:@refill

@example
(require 'color-space)
(XYZ->chromaticity (temperature->XYZ 6500))
    @result{} (0.3135191660557008 0.3236456786200268)

(XYZ->chromaticity (temperature->XYZ 5000))
    @result{} (0.34508082841161052 0.3516084965163377)
@end example
@end defun

@defun temperature->CIEXYZ x
The positive number @var{x} is a temperature in degrees kelvin.
@code{temperature->CIEXYZ} computes the CIEXYZ(1931) values for the
spectrum of a black body at temperature @var{x}, scaled to be just
inside the RGB709 gamut.@refill
@end defun

@defun temperature->chromaticity x
@end defun

@defun XYZ:normalize xyz
@var{xyz} is a list of three non-negative real numbers.
@code{XYZ:normalize} returns a list of numbers proportional to
@var{xyz}; scaled so their sum is 1.@refill
@end defun

@defun XYZ:normalize-colors colors @dots{}
@var{colors} is a list of XYZ triples.  @code{XYZ:normalize-colors}
scales all the triples by a common factor such that the maximum sum of
numbers in a scaled triple is 1.@refill
@end defun

@defun XYZ->chromaticity xyz
Returns a two element list: the x and y components of @var{xyz}
normalized to 1 (= @var{x} + @var{y} + @var{z}).@refill
@end defun

@defun chromaticity->CIEXYZ x y
Returns the list of @var{x}, and @var{y}, 1 - @var{y} - @var{x}.@refill
@end defun

@defun chromaticity->whitepoint x y
Returns the CIEXYZ(1931) values having luminosity 1 and chromaticity
@var{x} and @var{y}.@refill
@end defun

@cindex xyY
@noindent
Many color datasets are expressed in @dfn{xyY} format; chromaticity with
CIE luminance (Y).  But xyY is not a CIE standard like CIEXYZ, CIELAB,
and CIELUV.  Although chrominance is well defined, the luminance
component is sometimes scaled to 1, sometimes to 100, but usually has no
obvious range.  With no given whitepoint, the only reasonable course is
to ascertain the luminance range of a dataset and normalize the values
to lie from 0 to 1.@refill

@defun XYZ->xyY xyz
Returns a three element list: the @var{x} and @var{y} components of
@var{XYZ} normalized to 1, and CIE luminance @var{Y}.@refill
@end defun

@defun xyY->XYZ xyY
@end defun

@defun xyY:normalize-colors colors
@var{colors} is a list of xyY triples.  @code{xyY:normalize-colors}
scales each chromaticity so it sums to 1 or less; and divides the
@var{Y} values by the maximum @var{Y} in the dataset, so all lie between
0 and 1.@refill

@defunx xyY:normalize-colors colors n
If @var{n} is positive real, then @code{xyY:normalize-colors} divides
the @var{Y} values by @var{n} times the maximum @var{Y} in the dataset.@refill

If @var{n} is an exact non-positive integer, then
@code{xyY:normalize-colors} divides the @var{Y} values by the maximum of
the @var{Y}s in the dataset excepting the -@var{n} largest @var{Y}
values.@refill

In all cases, returned @var{Y} values are limited to lie from 0 to 1.@refill
@end defun

@noindent
Why would one want to normalize to other than 1?  If the sun or its
reflection is the brightest object in a scene, then normalizing to its
luminance will tend to make the rest of the scene very dark.  As with
photographs, limiting the specular highlights looks better than
darkening everything else.@refill

@noindent
The results of measurements being what they are,
@code{xyY:normalize-colors} is extremely tolerant.  Negative numbers are
replaced with zero, and chromaticities with sums greater than one are
scaled to sum to one.@refill


@node Color Difference Metrics, Color Conversions, Spectra, Color
@subsection Color Difference Metrics

@ifset html
<A NAME="Color_Difference_Metrics"></A>@refill
@end ifset

@code{(require 'color-space)}@refill

The low-level metric functions operate on lists of 3 numbers, lab1,
lab2, lch1, or lch2.@refill

@code{(require 'color)}@refill

The wrapped functions operate on objects of type color, color1 and
color2 in the function entries.@refill

@defun L*a*b*:DE* lab1 lab2
Returns the Euclidean distance between @var{lab1} and @var{lab2}.@refill

@defunx CIE:DE* color1 color2 white-point
@defunx CIE:DE* color1 color2
Returns the Euclidean distance in L*a*b* space between @var{color1} and
@var{color2}.@refill
@end defun


@defun L*C*h:DE*94 lch1 lch2 parametric-factors
@defunx L*C*h:DE*94 lch1 lch2

@defunx CIE:DE*94 color1 color2 parametric-factors
@defunx CIE:DE*94 color1 color2

Measures distance in the L*C*h cylindrical color-space.
The three axes are individually scaled (depending on C*) in their
contributions to the total distance.@refill

The CIE has defined reference conditions under which the metric with
default parameters can be expected to perform well.  These are:@refill

@itemize @bullet
@item
The specimens are homogeneous in colour.@refill
@item
The colour difference (CIELAB) is <= 5 units.@refill
@item
They are placed in direct edge contact.@refill
@item
Each specimen subtends an angle of >4 degrees to the assessor, whose
colour vision is normal.@refill
@item
They are illuminated at 1000 lux, and viewed against a background of
uniform grey, with L* of 50, under illumination simulating D65.@refill
@end itemize

The @var{parametric-factors} argument is a list of 3 quantities kL, kC
and kH.  @var{parametric-factors} independently adjust each
colour-difference term to account for any deviations from the reference
viewing conditions.  Under the reference conditions explained above, the
default is kL = kC = kH = 1.@refill
@end defun


@noindent
The Color Measurement Committee of The Society of Dyers and Colorists in
Great Britain created a more sophisticated color-distance function for
use in judging the consistency of dye lots.  With CMC:DE* it is possible
to use a single value pass/fail tolerance for all shades.@refill

@defun CMC-DE lch1 lch2 parametric-factors
@defunx CMC-DE lch1 lch2 l c
@defunx CMC-DE lch1 lch2 l
@defunx CMC-DE lch1 lch2

@defunx CMC:DE* color1 color2 l c
@defunx CMC:DE* color1 color2

@code{CMC:DE} is a L*C*h metric.  The @var{parametric-factors}
argument is a list of 2 numbers @var{l} and @var{c}.  @var{l} and
@var{c} parameterize this metric.  1 and 1 are recommended for
perceptibility; the default, 2 and 1, for acceptability.@refill
@end defun



@node Color Conversions, Color Names, Color Difference Metrics, Color
@subsection Color Conversions

@ifset html
<A NAME="Color_Conversions"></A>@refill
@end ifset

@noindent
This package contains the low-level color conversion and color metric
routines operating on lists of 3 numbers.  There is no type or range
checking.@refill

@code{(require 'color-space)}@refill

@defvr Constant CIEXYZ:D65
Is the color of 6500.K (blackbody) illumination.  D65 is close to the
average color of daylight.@refill
@end defvr

@defvr Constant CIEXYZ:D50
Is the color of 5000.K (blackbody) illumination.  D50 is the color of
indoor lighting by incandescent bulbs.@refill
@end defvr

@defvr Constant CIEXYZ:A
@defvrx Constant CIEXYZ:B
@defvrx Constant CIEXYZ:C
@defvrx Constant CIEXYZ:E
CIE 1931 illuminants normalized to 1 = y.@refill
@end defvr

@defun color:linear-transform matrix row
@end defun

@defun CIEXYZ->RGB709 xyz
@defunx RGB709->CIEXYZ srgb
@end defun

@defun CIEXYZ->L*u*v* xyz white-point
@defunx CIEXYZ->L*u*v* xyz
@defunx L*u*v*->CIEXYZ L*u*v* white-point
@defunx L*u*v*->CIEXYZ L*u*v*
The @var{white-point} defaults to CIEXYZ:D65.@refill
@end defun

@defun CIEXYZ->L*a*b* xyz white-point
@defunx CIEXYZ->L*a*b* xyz
@defunx L*a*b*->CIEXYZ L*a*b* white-point
@defunx L*a*b*->CIEXYZ L*a*b*
The XYZ @var{white-point} defaults to CIEXYZ:D65.@refill
@end defun

@defun L*a*b*->L*C*h L*a*b*
@defunx L*C*h->L*a*b* L*C*h
@end defun

@defun CIEXYZ->sRGB xyz
@defunx sRGB->CIEXYZ srgb
@end defun

@defun CIEXYZ->xRGB xyz
@defunx xRGB->CIEXYZ srgb
@end defun

@defun sRGB->xRGB xyz
@defunx xRGB->sRGB srgb
@end defun

@defun CIEXYZ->e-sRGB n xyz
@defunx e-sRGB->CIEXYZ n srgb
@end defun

@defun sRGB->e-sRGB n srgb
@defunx e-sRGB->sRGB n srgb
The integer @var{n} must be 10, 12, or 16.  Because sRGB and e-sRGB use
the same RGB709 chromaticities, conversion between them is simpler than
conversion through CIEXYZ.@refill
@end defun

@noindent
Do not convert e-sRGB precision through @code{e-sRGB->sRGB} then
@code{sRGB->e-sRGB} -- values would be truncated to 8-bits!@refill

@defun e-sRGB->e-sRGB n1 srgb n2
The integers @var{n1} and @var{n2} must be 10, 12, or 16.
@code{e-sRGB->e-sRGB} converts @var{srgb} to e-sRGB of precision
@var{n2}.@refill
@end defun



@node Color Names, Daylight, Color Conversions, Color
@subsection Color Names

@ifset html
<A NAME="Color_Names"></A>@refill
@end ifset
@code{(require 'color-names)}@refill
@ftindex color-names

@noindent
Rather than ballast the color dictionaries with numbered grays,
@code{file->color-dictionary} discards them.  They are provided
through the @code{grey} procedure:@refill


@defun grey k

Returns @code{(inexact->exact (round (* k 2.55)))}, the X11 color
grey@i{<k>}.@refill
@end defun
@noindent
A color dictionary is a database table relating @dfn{canonical}@refill
@cindex canonical
color-names to color-strings
(@pxref{Color Data-Type, External Representation}).@refill

@noindent
The column names in a color dictionary are unimportant; the first
field is the key, and the second is the color-string.@refill


@defun color-name:canonicalize name
Returns a downcased copy of the string or symbol @var{name} with
@samp{_}, @samp{-}, and whitespace removed.@refill
@end defun

@defun color-name->color name table1 table2 @dots{}


@var{table1}, @var{table2}, @dots{} must be color-dictionary tables.  @code{color-name->color} searches for the
canonical form of @var{name} in @var{table1}, @var{table2}, @dots{} in order; returning the
color-string of the first matching record; #f otherwise.@refill
@end defun

@defun color-dictionaries->lookup table1 table2 @dots{}


@var{table1}, @var{table2}, @dots{} must be color-dictionary tables.  @code{color-dictionaries->lookup} returns a
procedure which searches for the canonical form of its string argument
in @var{table1}, @var{table2}, @dots{}; returning the color-string of the first matching
record; and #f otherwise.@refill
@end defun

@defun color-dictionary name rdb base-table-type


@var{rdb} must be a string naming a relational database file; and the symbol
@var{name} a table therein.  The database will be opened as
@var{base-table-type}.  @code{color-dictionary} returns the read-only table @var{name} in database
@var{name} if it exists; #f otherwise.@refill


@defunx color-dictionary name rdb

@var{rdb} must be an open relational database or a string naming a relational
database file; and the symbol @var{name} a table therein.  @code{color-dictionary} returns the
read-only table @var{name} in database @var{name} if it exists; #f otherwise.@refill
@end defun

@defun load-color-dictionary name rdb base-table-type


@defunx load-color-dictionary name rdb

@var{rdb} must be a string naming a relational database file; and the symbol
@var{name} a table therein.  If the symbol @var{base-table-type} is provided, the database will
be opened as @var{base-table-type}.  @code{load-color-dictionary} creates a top-level definition of the symbol @var{name}
to a lookup procedure for the color dictionary @var{name} in @var{rdb}.@refill

The value returned by @code{load-color-dictionary} is unspecified.@refill
@end defun

@subsubheading Dictionary Creation

@code{(require 'color-database)}@refill
@ftindex color-database


@defun file->color-dictionary file table-name rdb base-table-type


@defunx file->color-dictionary file table-name rdb

@var{rdb} must be an open relational database or a string naming a relational
database file, @var{table-name} a symbol, and the string @var{file} must name an existing
file with colornames and their corresponding xRGB (6-digit hex)
values.  @code{file->color-dictionary} creates a table @var{table-name} in @var{rdb} and enters the associations found
in @var{file} into it.@refill
@end defun

@defun url->color-dictionary url table-name rdb base-table-type


@defunx url->color-dictionary url table-name rdb

@var{rdb} must be an open relational database or a string naming a relational
database file and @var{table-name} a symbol.  @code{url->color-dictionary} retrieves the resource named by the
string @var{url} using the @dfn{wget} program; then calls@refill
@cindex wget
@code{file->color-dictionary} to enter its associations in @var{table-name} in @var{url}.@refill
@end defun
@noindent
This section has detailed the procedures for creating and loading
color dictionaries.  So where are the dictionaries to load?@refill

@uref{http://swissnet.ai.mit.edu/~jaffer/Color/Dictionaries.html}

@noindent
Describes and evaluates several color-name dictionaries on the web.
The following procedure creates a database containing two of these
dictionaries.@refill


@defun make-slib-color-name-db

Creates an @r{alist-table} relational database in @r{library-vicinity}
containing the @dfn{Resene} and @dfn{saturate} color-name@refill
@cindex Resene
@cindex saturate
dictionaries.@refill

If the files @file{resenecolours.txt} and @file{saturate.txt} exist in
the @r{library-vicinity}, then they used as the source of color-name
data.  Otherwise, @code{make-slib-color-name-db} calls url->color-dictionary with the URLs of
appropriate source files.@refill
@end defun

@subsubheading The Short List

@code{(require 'saturate)}@refill
@ftindex saturate

@defun saturate name
Looks for @var{name} among the 19 saturated colors from
@cite{Approximate Colors on CIE Chromaticity Diagram}:@refill

@multitable @columnfractions .25 .25 .25 .25
@item reddish orange  @tab orange        @tab yellowish orange @tab yellow
@item greenish yellow @tab yellow green  @tab yellowish green  @tab green
@item bluish green    @tab blue green    @tab greenish blue    @tab blue
@item purplish blue   @tab bluish purple @tab purple           @tab reddish purple
@item red purple      @tab purplish red  @tab red
@end multitable

(@url{http://swissnet.ai.mit.edu/~jaffer/Color/saturate.pdf}).  If
@var{name} is found, the corresponding color is returned.  Otherwise #f
is returned.  Use saturate only for light source colors.@refill
@end defun


@noindent
Resene Paints Limited, New Zealand's largest privately-owned and
operated paint manufacturing company, has generously made their
@cite{Resene RGB Values List} available.@refill

@code{(require 'resene)}@refill
@ftindex resene

@defun resene name
Looks for @var{name} among the 1300 entries in the Resene color-name
dictionary (@url{http://swissnet.ai.mit.edu/~jaffer/Color/resene.pdf}).
If @var{name} is found, the corresponding color is returned.  Otherwise
#f is returned.  The @cite{Resene RGB Values List} is an excellent
source for surface colors.@refill
@end defun

@noindent
If you include the @dfn{Resene RGB Values List} in binary form in a
program, then you must include its license with your program:@refill

@quotation
Resene RGB Values List@*
For further information refer to http://www.resene.co.nz@*
Copyright Resene Paints Ltd 2001

Permission to copy this dictionary, to modify it, to redistribute it,
to distribute modified versions, and to use it for any purpose is
granted, subject to the following restrictions and understandings.@refill

@enumerate
@item
Any text copy made of this dictionary must include this copyright
notice in full.@refill

@item
Any redistribution in binary form must reproduce this copyright
notice in the documentation or other materials provided with the
distribution.@refill

@item
Resene Paints Ltd makes no warranty or representation that this
dictionary is error-free, and is under no obligation to provide any
services, by way of maintenance, update, or otherwise.@refill

@item
There shall be no use of the name of Resene or Resene Paints Ltd
in any advertising, promotional, or sales literature without prior
written consent in each case.@refill

@item
These RGB colour formulations may not be used to the detriment of
Resene Paints Ltd.@refill
@end enumerate
@end quotation


@node Daylight,  , Color Names, Color
@subsection Daylight

@ifset html
<A NAME="Daylight"></A>@refill
@end ifset
@code{(require 'daylight)}@refill
@ftindex daylight
@ftindex sunlight
@ftindex sun
@ftindex sky

@noindent
This package calculates the colors of sky as detailed in:@*
@uref{http://www.cs.utah.edu/vissim/papers/sunsky/sunsky.pdf}@*
@cite{A Practical Analytic Model for Daylight}@*
A. J. Preetham, Peter Shirley, Brian Smits


@defun solar-hour julian-day hour


Returns the solar-time in hours given the integer @var{julian-day} in the range 1 to
366, and the local time in hours.@refill

To be meticulous, subtract 4 minutes for each degree of longitude west
of the standard meridian of your time zone.@refill
@end defun

@defun solar-declination julian-day

@end defun

@defun solar-polar declination latitude solar-hour
Returns a list of @var{theta_s}, the solar angle from the
zenith, and @var{phi_s}, the solar azimuth.  0 <= @var{theta_s}
measured in degrees.  @var{phi_s} is measured in degrees from due
south; west of south being positive.@refill
@end defun
@noindent
In the following procedures, the number 0 <= @var{theta_s} <= 90 is
the solar angle from the zenith in degrees.@refill

@cindex turbidity
@noindent
Turbidity is a measure of the fraction of scattering due to haze as
opposed to molecules.  This is a convenient quantity because it can be
estimated based on visibility of distant objects.  This model fails
for turbidity values less than 1.3.@refill

@example
@group
    _______________________________________________________________
512|-:                                                             |
   | * pure-air                                                    |
256|-:**                                                           |
   | : ** exceptionally-clear                                      |
128|-:   *                                                         |
   | :    **                                                       |
 64|-:      *                                                      |
   | :       ** very-clear                                         |
 32|-:         **                                                  |
   | :           **                                                |
 16|-:             *** clear                                       |
   | :               ****                                          |
  8|-:                  ****                                       |
   | :                     **** light-haze                         |
  4|-:                         ****                                |
   | :                             ******                          |
  2|-:                                  ******** haze         thin-|
   | :                                          ***********    fog |
  1|-:----------------------------------------------------*******--|
   |_:____.____:____.____:____.____:____.____:____.____:____.____:_|
     1         2         4         8        16        32        64
              Meterorological range (km) versus Turbidity
@end group
@end example


@defun sunlight-spectrum turbidity theta_s
Returns a vector of 41 values, the spectrum of sunlight from
380.nm to 790.nm for a given @var{turbidity} and @var{theta_s}.@refill
@end defun

@defun sunlight-xyz turbidity theta_s
Returns (unnormalized) XYZ values for color of sunlight for a
given @var{turbidity} and @var{theta_s}.@refill
@end defun

@defun sunlight-ciexyz turbidity theta_s
Given @var{turbidity} and @var{theta_s}, @code{sunlight-ciexyz} returns the CIEXYZ triple for color of
sunlight scaled to be just inside the RGB709 gamut.@refill
@end defun

@defun zenith-xyy turbidity theta_s
Returns the xyY (chromaticity and luminance) at the zenith.  The
Luminance has units kcd/m^2.@refill
@end defun

@defun overcast-sky-color-xyy turbidity theta_s
@var{turbidity} is a positive real number expressing the amount of light
scattering.  The real number @var{theta_s} is the solar angle from the zenith in
degrees.@refill

@code{overcast-sky-color-xyy} returns a function of one angle @var{theta}, the angle from the
zenith of the viewing direction (in degrees); and returning the xyY
value for light coming from that elevation of the sky.@refill
@end defun

@defun clear-sky-color-xyy turbidity theta_s phi_s
@defunx sky-color-xyy turbidity theta_s phi_s
@var{turbidity} is a positive real number expressing the amount of light
scattering.  The real number @var{theta_s} is the solar angle from the zenith in
degrees.  The real number @var{phi_s} is the solar angle from south.@refill

@code{clear-sky-color-xyy} returns a function of two angles, @var{theta} and @var{phi} which
specify the angles from the zenith and south meridian of the viewing
direction (in degrees); returning the xyY value for light coming from
that direction of the sky.@refill

@code{sky-color-xyY} calls @code{overcast-sky-color-xyY} for
@var{turbidity} <= 20; otherwise the @code{clear-sky-color-xyy} function.@refill
@end defun



@node Root Finding, Minimizing, Color, Mathematical Packages
@section Root Finding

@code{(require 'root)}@refill
@ftindex root

@defun newton:find-integer-root f df/dx x0
Given integer valued procedure @var{f}, its derivative (with respect to
its argument) @var{df/dx}, and initial integer value @var{x0} for which
@var{df/dx}(@var{x0}) is non-zero, returns an integer @var{x} for which
@var{f}(@var{x}) is closer to zero than either of the integers adjacent
to @var{x}; or returns @code{#f} if such an integer can't be found.@refill

To find the closest integer to a given integers square root:@refill

@example
(define (integer-sqrt y)
  (newton:find-integer-root
   (lambda (x) (- (* x x) y))
   (lambda (x) (* 2 x))
   (ash 1 (quotient (integer-length y) 2))))

(integer-sqrt 15) @result{} 4
@end example
@end defun

@defun integer-sqrt y
Given a non-negative integer @var{y}, returns the rounded square-root of
@var{y}.@refill
@end defun

@defun newton:find-root f df/dx x0 prec
Given real valued procedures @var{f}, @var{df/dx} of one (real)
argument, initial real value @var{x0} for which @var{df/dx}(@var{x0}) is
non-zero, and positive real number @var{prec}, returns a real @var{x}
for which @code{abs}(@var{f}(@var{x})) is less than @var{prec}; or
returns @code{#f} if such a real can't be found.@refill

If @var{prec} is instead a negative integer, @code{newton:find-root}
returns the result of -@var{prec} iterations.@refill
@end defun

@noindent
H. J. Orchard, @cite{The Laguerre Method for Finding the Zeros of
Polynomials}, IEEE Transactions on Circuits and Systems, Vol. 36,
No. 11, November 1989, pp 1377-1381.@refill

@quotation
There are 2 errors in Orchard's Table II.  Line k=2 for starting
value of 1000+j0 should have Z_k of 1.0475 + j4.1036 and line k=2
for starting value of 0+j1000 should have Z_k of 1.0988 + j4.0833.@refill
@end quotation


@defun laguerre:find-root f df/dz ddf/dz^2 z0 prec
Given complex valued procedure @var{f} of one (complex) argument, its
derivative (with respect to its argument) @var{df/dx}, its second
derivative @var{ddf/dz^2}, initial complex value @var{z0}, and positive
real number @var{prec}, returns a complex number @var{z} for which
@code{magnitude}(@var{f}(@var{z})) is less than @var{prec}; or returns
@code{#f} if such a number can't be found.@refill

If @var{prec} is instead a negative integer, @code{laguerre:find-root}
returns the result of -@var{prec} iterations.@refill
@end defun

@defun laguerre:find-polynomial-root deg f df/dz ddf/dz^2 z0 prec
Given polynomial procedure @var{f} of integer degree @var{deg} of one
argument, its derivative (with respect to its argument) @var{df/dx}, its
second derivative @var{ddf/dz^2}, initial complex value @var{z0}, and
positive real number @var{prec}, returns a complex number @var{z} for
which @code{magnitude}(@var{f}(@var{z})) is less than @var{prec}; or
returns @code{#f} if such a number can't be found.@refill

If @var{prec} is instead a negative integer,
@code{laguerre:find-polynomial-root} returns the result of -@var{prec}
iterations.@refill
@end defun

@defun secant:find-root f x0 x1 prec
@defunx secant:find-bracketed-root f x0 x1 prec
Given a real valued procedure @var{f} and two real valued starting
points @var{x0} and @var{x1}, returns a real @var{x} for which
@code{(abs (f x))} is less than @var{prec}; or returns
@code{#f} if such a real can't be found.@refill

If @var{x0} and @var{x1} are chosen such that they bracket a root, that is@refill
@example
(or (< (f x0) 0 (f x1))
    (< (f x1) 0 (f x0)))
@end example
then the root returned will be between @var{x0} and @var{x1}, and
@var{f} will not be passed an argument outside of that interval.@refill

@code{secant:find-bracketed-root} will return @code{#f} unless @var{x0}
and @var{x1} bracket a root.@refill

The secant method is used until a bracketing interval is found, at which point
a modified @i{regula falsi} method is used.@refill

If @var{prec} is instead a negative integer, @code{secant:find-root}
returns the result of -@var{prec} iterations.@refill

If @var{prec} is a procedure it should accept 5 arguments: @var{x0}
@var{f0} @var{x1} @var{f1} and @var{count}, where @var{f0} will be
@code{(f x0)}, @var{f1} @code{(f x1)}, and @var{count} the number of
iterations performed so far.  @var{prec} should return non-false
if the iteration should be stopped.@refill
@end defun

@node Minimizing, Commutative Rings, Root Finding, Mathematical Packages
@section Minimizing

@code{(require 'minimize)}@refill
@ftindex minimize
@cindex minimize

@noindent

The Golden Section Search
@footnote{David Kahaner, Cleve Moler, and Stephen Nash
@cite{Numerical Methods and Software}
Prentice-Hall, 1989, ISBN 0-13-627258-4}
algorithm finds minima of functions which
are expensive to compute or for which derivatives are not available.
Although optimum for the general case, convergence is slow,
requiring nearly 100 iterations for the example (x^3-2x-5).@refill

@noindent

If the derivative is available, Newton-Raphson is probably a better
choice.  If the function is inexpensive to compute, consider
approximating the derivative.@refill


@defun golden-section-search f x0 x1 prec


@var{x_0} are @var{x_1} real numbers.  The (single argument)
procedure @var{f} is unimodal over the open interval (@var{x_0},
@var{x_1}).  That is, there is exactly one point in the interval for
which the derivative of @var{f} is zero.@refill

@code{golden-section-search} returns a pair (@var{x} . @var{f}(@var{x})) where @var{f}(@var{x})
is the minimum.  The @var{prec} parameter is the stop criterion.  If
@var{prec} is a positive number, then the iteration continues until
@var{x} is within @var{prec} from the true value.  If @var{prec} is
a negative integer, then the procedure will iterate @var{-prec}
times or until convergence.  If @var{prec} is a procedure of seven
arguments, @var{x0}, @var{x1}, @var{a}, @var{b}, @var{fa}, @var{fb},
and @var{count}, then the iterations will stop when the procedure
returns @code{#t}.@refill

Analytically, the minimum of x^3-2x-5 is 0.816497.@refill
@example
(define func (lambda (x) (+ (* x (+ (* x x) -2)) -5)))
(golden-section-search func 0 1 (/ 10000))
      ==> (816.4883855245578e-3 . -6.0886621077391165)
(golden-section-search func 0 1 -5)
      ==> (819.6601125010515e-3 . -6.088637561916407)
(golden-section-search func 0 1
                       (lambda (a b c d e f g ) (= g 500)))
      ==> (816.4965933140557e-3 . -6.088662107903635)
@end example
@end defun

@node Commutative Rings, Matrix Algebra, Minimizing, Mathematical Packages
@section Commutative Rings

Scheme provides a consistent and capable set of numeric functions.
Inexacts implement a field; integers a commutative ring (and Euclidean
domain).  This package allows one to use basic Scheme numeric functions
with symbols and non-numeric elements of commutative rings.@refill

@code{(require 'commutative-ring)}@refill
@ftindex commutative-ring
@cindex ring, commutative

The @dfn{commutative-ring} package makes the procedures @code{+},
@code{-}, @code{*}, @code{/}, and @code{^} @dfn{careful} in the sense@refill
@cindex careful
that any non-numeric arguments they do not reduce appear in the
expression output.  In order to see what working with this package is
like, self-set all the single letter identifiers (to their corresponding
symbols).@refill
@cindex self-set

@example
(define a 'a)
@dots{}
(define z 'z)
@end example

Or just @code{(require 'self-set)}.  Now try some sample expressions:@refill
@ftindex self-set

@example
(+ (+ a b) (- a b)) @result{} (* a 2)
(* (+ a b) (+ a b)) @result{} (^ (+ a b) 2)
(* (+ a b) (- a b)) @result{} (* (+ a b) (- a b))
(* (- a b) (- a b)) @result{} (^ (- a b) 2)
(* (- a b) (+ a b)) @result{} (* (+ a b) (- a b))
(/ (+ a b) (+ c d)) @result{} (/ (+ a b) (+ c d))
(^ (+ a b) 3) @result{} (^ (+ a b) 3)
(^ (+ a 2) 3) @result{} (^ (+ 2 a) 3)
@end example

Associative rules have been applied and repeated addition and
multiplication converted to multiplication and exponentiation.@refill

We can enable distributive rules, thus expanding to sum of products
form:@refill
@example
(set! *ruleset* (combined-rulesets distribute* distribute/))

(* (+ a b) (+ a b)) @result{} (+ (* 2 a b) (^ a 2) (^ b 2))
(* (+ a b) (- a b)) @result{} (- (^ a 2) (^ b 2))
(* (- a b) (- a b)) @result{} (- (+ (^ a 2) (^ b 2)) (* 2 a b))
(* (- a b) (+ a b)) @result{} (- (^ a 2) (^ b 2))
(/ (+ a b) (+ c d)) @result{} (+ (/ a (+ c d)) (/ b (+ c d)))
(/ (+ a b) (- c d)) @result{} (+ (/ a (- c d)) (/ b (- c d)))
(/ (- a b) (- c d)) @result{} (- (/ a (- c d)) (/ b (- c d)))
(/ (- a b) (+ c d)) @result{} (- (/ a (+ c d)) (/ b (+ c d)))
(^ (+ a b) 3) @result{} (+ (* 3 a (^ b 2)) (* 3 b (^ a 2)) (^ a 3) (^ b 3))
(^ (+ a 2) 3) @result{} (+ 8 (* a 12) (* (^ a 2) 6) (^ a 3))
@end example

Use of this package is not restricted to simple arithmetic expressions:@refill

@example
(require 'determinant)

(determinant '((a b c) (d e f) (g h i))) @result{}
(- (+ (* a e i) (* b f g) (* c d h)) (* a f h) (* b d i) (* c e g))
@end example

Currently, only @code{+}, @code{-}, @code{*}, @code{/}, and @code{^}
support non-numeric elements.  Expressions with @code{-} are converted
to equivalent expressions without @code{-}, so behavior for @code{-} is
not defined separately.  @code{/} expressions are handled similarly.@refill

This list might be extended to include @code{quotient}, @code{modulo},
@code{remainder}, @code{lcm}, and @code{gcd}; but these work only for
the more restrictive Euclidean (Unique Factorization) Domain.@refill
@cindex Unique Factorization
@cindex Euclidean Domain

@section Rules and Rulesets

The @dfn{commutative-ring} package allows control of ring properties
through the use of @dfn{rulesets}.@refill

@defvar *ruleset*
Contains the set of rules currently in effect.  Rules defined by
@code{cring:define-rule} are stored within the value of *ruleset* at the
time @code{cring:define-rule} is called.  If @var{*ruleset*} is
@code{#f}, then no rules apply.@refill
@end defvar

@defun make-ruleset rule1 @dots{}
@defunx make-ruleset name rule1 @dots{}
Returns a new ruleset containing the rules formed by applying
@code{cring:define-rule} to each 4-element list argument @var{rule}.  If
the first argument to @code{make-ruleset} is a symbol, then the database
table created for the new ruleset will be named @var{name}.  Calling
@code{make-ruleset} with no rule arguments creates an empty ruleset.@refill
@end defun

@defun combined-rulesets ruleset1 @dots{}
@defunx combined-rulesets name ruleset1 @dots{}
Returns a new ruleset containing the rules contained in each ruleset
argument @var{ruleset}.  If the first argument to
@code{combined-ruleset} is a symbol, then the database table created for
the new ruleset will be named @var{name}.  Calling
@code{combined-ruleset} with no ruleset arguments creates an empty
ruleset.@refill
@end defun

Two rulesets are defined by this package.@refill

@defvr Constant distribute*
Contains the ruleset to distribute multiplication over addition and
subtraction.@refill
@end defvr

@defvr Constant distribute/
Contains the ruleset to distribute division over addition and
subtraction.@refill

Take care when using both @var{distribute*} and @var{distribute/}
simultaneously.  It is possible to put @code{/} into an infinite loop.@refill
@end defvr

You can specify how sum and product expressions containing non-numeric
elements simplify by specifying the rules for @code{+} or @code{*} for
cases where expressions involving objects reduce to numbers or to
expressions involving different non-numeric elements.@refill

@defun cring:define-rule op sub-op1 sub-op2 reduction
Defines a rule for the case when the operation represented by symbol
@var{op} is applied to lists whose @code{car}s are @var{sub-op1} and
@var{sub-op2}, respectively.  The argument @var{reduction} is a
procedure accepting 2 arguments which will be lists whose @code{car}s
are @var{sub-op1} and @var{sub-op2}.@refill

@defunx cring:define-rule op sub-op1 'identity reduction
Defines a rule for the case when the operation represented by symbol
@var{op} is applied to a list whose @code{car} is @var{sub-op1}, and
some other argument.  @var{Reduction} will be called with the list whose
@code{car} is @var{sub-op1} and some other argument.@refill

If @var{reduction} returns @code{#f}, the reduction has failed and other
reductions will be tried.  If @var{reduction} returns a non-false value,
that value will replace the two arguments in arithmetic (@code{+},
@code{-}, and @code{*}) calculations involving non-numeric elements.@refill

The operations @code{+} and @code{*} are assumed commutative; hence both
orders of arguments to @var{reduction} will be tried if necessary.@refill

The following rule is the definition for distributing @code{*} over
@code{+}.@refill

@example
(cring:define-rule
 '* '+ 'identity
 (lambda (exp1 exp2)
   (apply + (map (lambda (trm) (* trm exp2)) (cdr exp1))))))
@end example
@end defun

@section How to Create a Commutative Ring

The first step in creating your commutative ring is to write procedures
to create elements of the ring.  A non-numeric element of the ring must
be represented as a list whose first element is a symbol or string.
This first element identifies the type of the object.  A convenient and
clear convention is to make the type-identifying element be the same
symbol whose top-level value is the procedure to create it.@refill

@example
(define (n . list1)
  (cond ((and (= 2 (length list1))
              (eq? (car list1) (cadr list1)))
         0)
        ((not (term< (first list1) (last1 list1)))
         (apply n (reverse list1)))
        (else (cons 'n list1))))

(define (s x y) (n x y))

(define (m . list1)
  (cond ((neq? (first list1) (term_min list1))
         (apply m (cyclicrotate list1)))
        ((term< (last1 list1) (cadr list1))
         (apply m (reverse (cyclicrotate list1))))
        (else (cons 'm list1))))
@end example

Define a procedure to multiply 2 non-numeric elements of the ring.
Other multiplicatons are handled automatically.  Objects for which rules
have @emph{not} been defined are not changed.@refill

@example
(define (n*n ni nj)
  (let ((list1 (cdr ni)) (list2 (cdr nj)))
    (cond ((null? (intersection list1 list2)) #f)
          ((and (eq? (last1 list1) (first list2))
                (neq? (first list1) (last1 list2)))
           (apply n (splice list1 list2)))
          ((and (eq? (first list1) (first list2))
                (neq? (last1 list1) (last1 list2)))
           (apply n (splice (reverse list1) list2)))
          ((and (eq? (last1 list1) (last1 list2))
                (neq? (first list1) (first list2)))
           (apply n (splice list1 (reverse list2))))
          ((and (eq? (last1 list1) (first list2))
                (eq? (first list1) (last1 list2)))
           (apply m (cyclicsplice list1 list2)))
          ((and (eq? (first list1) (first list2))
                (eq? (last1 list1) (last1 list2)))
           (apply m (cyclicsplice (reverse list1) list2)))
          (else #f))))
@end example

Test the procedures to see if they work.@refill

@example
;;; where cyclicrotate(list) is cyclic rotation of the list one step
;;; by putting the first element at the end
(define (cyclicrotate list1)
  (append (rest list1) (list (first list1))))
;;; and where term_min(list) is the element of the list which is
;;; first in the term ordering.
(define (term_min list1)
  (car (sort list1 term<)))
(define (term< sym1 sym2)
  (string<? (symbol->string sym1) (symbol->string sym2)))
(define first car)
(define rest cdr)
(define (last1 list1) (car (last-pair list1)))
(define (neq? obj1 obj2) (not (eq? obj1 obj2)))
;;; where splice is the concatenation of list1 and list2 except that their
;;; common element is not repeated.
(define (splice list1 list2)
  (cond ((eq? (last1 list1) (first list2))
         (append list1 (cdr list2)))
        (else (slib:error 'splice list1 list2))))
;;; where cyclicsplice is the result of leaving off the last element of
;;; splice(list1,list2).
(define (cyclicsplice list1 list2)
  (cond ((and (eq? (last1 list1) (first list2))
              (eq? (first list1) (last1 list2)))
         (butlast (splice list1 list2) 1))
        (else (slib:error 'cyclicsplice list1 list2))))

(N*N (S a b) (S a b)) @result{} (m a b)
@end example

Then register the rule for multiplying type N objects by type N objects.@refill

@example
(cring:define-rule '* 'N 'N N*N))
@end example

Now we are ready to compute!@refill

@example
(define (t)
  (define detM
    (+ (* (S g b)
          (+ (* (S f d)
                (- (* (S a f) (S d g)) (* (S a g) (S d f))))
             (* (S f f)
                (- (* (S a g) (S d d)) (* (S a d) (S d g))))
             (* (S f g)
                (- (* (S a d) (S d f)) (* (S a f) (S d d))))))
       (* (S g d)
          (+ (* (S f b)
                (- (* (S a g) (S d f)) (* (S a f) (S d g))))
             (* (S f f)
                (- (* (S a b) (S d g)) (* (S a g) (S d b))))
             (* (S f g)
                (- (* (S a f) (S d b)) (* (S a b) (S d f))))))
       (* (S g f)
          (+ (* (S f b)
                (- (* (S a d) (S d g)) (* (S a g) (S d d))))
             (* (S f d)
                (- (* (S a g) (S d b)) (* (S a b) (S d g))))
             (* (S f g)
                (- (* (S a b) (S d d)) (* (S a d) (S d b))))))
       (* (S g g)
          (+ (* (S f b)
                (- (* (S a f) (S d d)) (* (S a d) (S d f))))
             (* (S f d)
                (- (* (S a b) (S d f)) (* (S a f) (S d b))))
             (* (S f f)
                (- (* (S a d) (S d b)) (* (S a b) (S d d))))))))
  (* (S b e) (S c a) (S e c)
     detM
     ))
(pretty-print (t))
@print{}
(- (+ (m a c e b d f g)
      (m a c e b d g f)
      (m a c e b f d g)
      (m a c e b f g d)
      (m a c e b g d f)
      (m a c e b g f d))
   (* 2 (m a b e c) (m d f g))
   (* (m a c e b d) (m f g))
   (* (m a c e b f) (m d g))
   (* (m a c e b g) (m d f)))
@end example


@node Matrix Algebra,  , Commutative Rings, Mathematical Packages
@section Matrix Algebra

@code{(require 'determinant)}@refill
@ftindex determinant

@noindent
A Matrix can be either a list of lists (rows) or an array.
As with linear-algebra texts, this package uses 1-based coordinates.@refill


@defun matrix->lists matrix

Returns the list-of-lists form of @var{matrix}.@refill
@end defun

@defun matrix->array matrix

Returns the (ones-based) array form of @var{matrix}.@refill
@end defun

@defun determinant matrix

@var{matrix} must be a square matrix.
@code{determinant} returns the determinant of @var{matrix}.@refill

@example
(require 'determinant)
(determinant '((1 2) (3 4))) @result{} -2
(determinant '((1 2 3) (4 5 6) (7 8 9))) @result{} 0
@end example
@end defun

@defun transpose matrix

Returns a copy of @var{matrix} flipped over the diagonal containing the 1,1
element.@refill
@end defun

@defun matrix:product m1 m2

Returns the product of matrices @var{m1} and @var{m2}.@refill
@end defun

@defun matrix:inverse matrix

@var{matrix} must be a square matrix.
If @var{matrix} is singlar, then @code{matrix:inverse} returns #f; otherwise @code{matrix:inverse} returns the
@code{matrix:product} inverse of @var{matrix}.@refill
@end defun


@node Database Packages, Other Packages, Mathematical Packages, Top
@chapter Database Packages

@menu
* Relational Database::         'relational-database
* Relational Infrastructure::   
* Weight-Balanced Trees::       'wt-tree
@end menu

@node Relational Database, Relational Infrastructure, Database Packages, Database Packages
@section Relational Database

@code{(require 'relational-database)}@refill
@ftindex relational-database

This package implements a database system inspired by the Relational
Model (@cite{E. F. Codd, A Relational Model of Data for Large Shared
Data Banks}).  An SLIB relational database implementation can be created
from any @ref{Base Table} implementation.@refill

Why relational database?  For motivations and design issues see@*
@uref{http://swissnet.ai.mit.edu/~jaffer/DBManifesto.html}.

@menu
* Using Databases::             'databases
* Table Operations::            
* Database Interpolation::      'database-interpolate
* Embedded Commands::           'database-commands
* Database Macros::             'within-database
* Database Browser::            'database-browse
@end menu

@node Using Databases, Table Operations, Relational Database, Relational Database
@subsection Using Databases

@code{(require 'databases)}@refill
@ftindex databases

@noindent
This enhancement wraps a utility layer on @code{relational-database}
which provides:@refill

@itemize @bullet
@item
Identification of open databases by filename.@refill
@item
Automatic sharing of open (immutable) databases.@refill
@item
Automatic loading of base-table package when creating a database.@refill
@item
Detection and automatic loading of the appropriate base-table package
when opening a database.@refill
@item
Table and data definition from Scheme lists.@refill
@end itemize

@subsubheading Database Sharing

@noindent
@dfn{Auto-sharing} refers to a call to the procedure
@cindex Auto-sharing
@code{open-database} returning an already open database (procedure),
rather than opening the database file a second time.@refill

@quotation
@emph{Note:} Databases returned by @code{open-database} do not include
wrappers applied by packages like @ref{Embedded Commands}.  But
wrapped databases do work as arguments to these functions.@refill
@end quotation

@noindent
When a database is created, it is mutable by the creator and not
auto-sharable.  A database opened mutably is also not auto-sharable.
But any number of readers can (open) share a non-mutable database file.@refill

@noindent
This next set of procedures mirror the whole-database methods in
@ref{Database Operations}.  Except for @code{create-database}, each
procedure will accept either a filename or database procedure for its
first argument.@refill


@defun create-database filename base-table-type

@var{filename} should be a string naming a file; or @code{#f}.  @var{base-table-type} must be a
symbol naming a feature which can be passed to @code{require}.  @code{create-database}
returns a new, open relational database (with base-table type @var{base-table-type})
associated with @var{filename}, or a new ephemeral database if @var{filename} is @code{#f}.@refill

@code{create-database} is the only run-time use of require in SLIB
which crosses module boundaries.  When @var{base-table-type} is @code{require}d by @code{create-database}; it
adds an association of @var{base-table-type} with its @dfn{relational-system} procedure@refill
@cindex relational-system
to @var{mdbm:*databases*}.@refill

alist-table is the default base-table type:@refill

@example
(require 'databases)
(define my-rdb (create-database "my.db" 'alist-table))
@end example
@end defun
@noindent
Only @code{alist-table} and base-table modules which have been
@code{require}d will dispatch correctly from the
@code{open-database} procedures.  Therefore, either pass two
arguments to @code{open-database}, or require the base-table of your
database file uses before calling @code{open-database} with one
argument.@refill


@deffn {Procedure} open-database! rdb base-table-type

Returns @emph{mutable} open relational database or #f.@refill
@end deffn

@defun open-database rdb base-table-type

Returns an open relational database associated with @var{rdb}.  The
database will be opened with base-table type @var{base-table-type}).@refill


@defunx open-database rdb
Returns an open relational database associated with @var{rdb}.
@code{open-database} will attempt to deduce the correct base-table-type.@refill
@end defun

@defun write-database rdb filename

Writes the mutable relational-database @var{rdb} to @var{filename}.@refill
@end defun

@defun sync-database rdb

Writes the mutable relational-database @var{rdb} to the filename it was
opened with.@refill
@end defun

@defun solidify-database rdb

Syncs @var{rdb} and makes it immutable.@refill
@end defun

@defun close-database rdb

@var{rdb} will only be closed when the count of @code{open-database} - @code{close-database}
calls for @var{rdb} (and its filename) is 0.  @code{close-database} returns #t if successful;
and #f otherwise.@refill
@end defun

@defun mdbm:report

Prints a table of open database files.  The columns are the
base-table type, number of opens, @samp{!} for mutable, the
filename, and the lock certificate (if locked).@refill
@end defun
@example
(mdbm:report)
@print{}
  alist-table 003   /usr/local/lib/slib/clrnamdb.scm
  alist-table 001 ! sdram.db jaffer@@aubrey.jaffer.3166:1038628199
@end example

@subsubheading Opening Tables


@defun open-table rdb table-name

@var{rdb} must be a relational database and @var{table-name} a symbol.@refill

@code{open-table} returns a "methods" procedure for an existing relational table in
@var{rdb} if it exists and can be opened for reading, otherwise returns
@code{#f}.@refill
@end defun

@deffn {Procedure} open-table! rdb table-name

@var{rdb} must be a relational database and @var{table-name} a symbol.@refill

@code{open-table!} returns a "methods" procedure for an existing relational table in
@var{rdb} if it exists and can be opened in mutable mode, otherwise returns
@code{#f}.@refill
@end deffn
@subsubheading Defining Tables


@defun define-domains rdb row5 @dots{}

Adds the domain rows @var{row5} @dots{} to the @samp{*domains-data*} table
in @var{rdb}.  The format of the row is given in @ref{Catalog
Representation}.@refill

@example
(define-domains rdb '(permittivity #f complex? c64 #f))
@end example
@end defun

@defun add-domain rdb row5

Use @code{define-domains} instead.@refill
@end defun

@defun define-tables rdb spec-0 @dots{}

Adds tables as specified in @var{spec-0} @dots{} to the open
relational-database @var{rdb}.  Each @var{spec} has the form:@refill

@lisp
(@r{<name>} @r{<descriptor-name>} @r{<descriptor-name>} @r{<rows>})
@end lisp
or@refill
@lisp
(@r{<name>} @r{<primary-key-fields>} @r{<other-fields>} @r{<rows>})
@end lisp

where @r{<name>} is the table name, @r{<descriptor-name>} is the symbol
name of a descriptor table, @r{<primary-key-fields>} and
@r{<other-fields>} describe the primary keys and other fields
respectively, and @r{<rows>} is a list of data rows to be added to the
table.@refill

@r{<primary-key-fields>} and @r{<other-fields>} are lists of field
descriptors of the form:@refill

@lisp
(@r{<column-name>} @r{<domain>})
@end lisp
or@refill
@lisp
(@r{<column-name>} @r{<domain>} @r{<column-integrity-rule>})
@end lisp

where @r{<column-name>} is the column name, @r{<domain>} is the domain
of the column, and @r{<column-integrity-rule>} is an expression whose
value is a procedure of one argument (which returns @code{#f} to signal
an error).@refill

If @r{<domain>} is not a defined domain name and it matches the name of
this table or an already defined (in one of @var{spec-0} @dots{}) single
key field table, a foreign-key domain will be created for it.@refill
@end defun
@subsubheading Listing Tables


@defun list-table-definition rdb table-name

If symbol @var{table-name} exists in the open relational-database
@var{rdb}, then returns a list of the table-name, its primary key names
and domains, its other key names and domains, and the table's records
(as lists).  Otherwise, returns #f.@refill

The list returned by @code{list-table-definition}, when passed as an
argument to @code{define-tables}, will recreate the table.@refill
@end defun



@node Table Operations, Database Interpolation, Using Databases, Relational Database
@subsection Table Operations

@noindent
These are the descriptions of the methods available from an open
relational table.  A method is retrieved from a table by calling
the table with the symbol name of the operation.  For example:@refill

@example
((plat 'get 'processor) 'djgpp) @result{} i386
@end example

@noindent
Some operations described below require primary key arguments.  Primary
keys arguments are denoted @var{key1} @var{key2} @dots{}.  It is an
error to call an operation for a table which takes primary key arguments
with the wrong number of primary keys for that table.@refill

@defop {Operation} {relational-table} get column-name
Returns a procedure of arguments @var{key1} @var{key2} @dots{} which
returns the value for the @var{column-name} column of the row associated
with primary keys @var{key1}, @var{key2} @dots{} if that row exists in
the table, or @code{#f} otherwise.@refill

@example
((plat 'get 'processor) 'djgpp) @result{} i386
((plat 'get 'processor) 'be-os) @result{} #f
@end example
@end defop

@menu
* Single Row Operations::       
* Match-Keys::                  
* Multi-Row Operations::        
* Indexed Sequential Access Methods::  
* Sequential Index Operations::  
* Table Administration::        
@end menu


@node Single Row Operations, Match-Keys, Table Operations, Table Operations
@subsubsection Single Row Operations

@noindent
The term @dfn{row} used below refers to a Scheme list of values (one for
each column) in the order specified in the descriptor (table) for this
table.  Missing values appear as @code{#f}.  Primary keys must not
be missing.@refill

@defop {Operation} {relational-table} row:insert
Adds the row @var{row} to this table.  If a row for the primary key(s)
specified by @var{row} already exists in this table an error is
signaled.  The value returned is unspecified.@refill
@end defop

@example
@group
(define telephone-table-desc
        ((my-database 'create-table) 'telephone-table-desc))
(define ndrp (telephone-table-desc 'row:insert))
(ndrp '(1 #t name #f string))
(ndrp '(2 #f telephone
          (lambda (d)
            (and (string? d) (> (string-length d) 2)
                 (every
                  (lambda (c)
                    (memv c '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
                                  #\+ #\( #\  #\) #\-)))
                  (string->list d))))
          string))
@end group
@end example

@defop {Operation} {relational-table} row:update
Returns a procedure of one argument, @var{row}, which adds the row,
@var{row}, to this table.  If a row for the primary key(s) specified by
@var{row} already exists in this table, it will be overwritten.  The
value returned is unspecified.@refill
@end defop

@defop {Operation} {relational-table} row:retrieve
Returns a procedure of arguments @var{key1} @var{key2} @dots{} which
returns the row associated with primary keys @var{key1}, @var{key2}
@dots{} if it exists, or @code{#f} otherwise.@refill
@end defop

@example
((plat 'row:retrieve) 'linux) @result{} (linux i386 linux gcc)
((plat 'row:retrieve) 'multics) @result{} #f
@end example

@defop {Operation} {relational-table} row:remove
Returns a procedure of arguments @var{key1} @var{key2} @dots{} which
removes and returns the row associated with primary keys @var{key1},
@var{key2} @dots{} if it exists, or @code{#f} otherwise.@refill
@end defop

@defop {Operation} {relational-table} row:delete
Returns a procedure of arguments @var{key1} @var{key2} @dots{} which
deletes the row associated with primary keys @var{key1}, @var{key2}
@dots{} if it exists.  The value returned is unspecified.@refill
@end defop


@node Match-Keys, Multi-Row Operations, Single Row Operations, Table Operations
@subsubsection Match-Keys

@noindent
@cindex match-keys
The (optional) @var{match-key1} @dots{} arguments are used to restrict
actions of a whole-table operation to a subset of that table.  Those
procedures (returned by methods) which accept match-key arguments will
accept any number of match-key arguments between zero and the number of
primary keys in the table.  Any unspecified @var{match-key} arguments
default to @code{#f}.@refill

@noindent
The @var{match-key1} @dots{} restrict the actions of the table command
to those records whose primary keys each satisfy the corresponding
@var{match-key} argument.  The arguments and their actions are:@refill

@quotation
@table @asis
@item @code{#f}
The false value matches any key in the corresponding position.@refill
@item an object of type procedure
This procedure must take a single argument, the key in the corresponding
position.  Any key for which the procedure returns a non-false value is
a match; Any key for which the procedure returns a @code{#f} is not.@refill
@item other values
Any other value matches only those keys @code{equal?} to it.@refill
@end table
@end quotation

@defop {Operation} {relational-table} get* column-name
Returns a procedure of optional arguments @var{match-key1} @dots{} which
returns a list of the values for the specified column for all rows in
this table.  The optional @var{match-key1} @dots{} arguments restrict
actions to a subset of the table.@refill

@example
((plat 'get* 'processor)) @result{}
(i386 i8086 i386 i8086 i386 i386 i8086 m68000
 m68000 m68000 m68000 m68000 powerpc)

((plat 'get* 'processor) #f) @result{}
(i386 i8086 i386 i8086 i386 i386 i8086 m68000
 m68000 m68000 m68000 m68000 powerpc)

(define (a-key? key)
   (char=? #\a (string-ref (symbol->string key) 0)))

((plat 'get* 'processor) a-key?) @result{}
(m68000 m68000 m68000 m68000 m68000 powerpc)

((plat 'get* 'name) a-key?) @result{}
(atari-st-turbo-c atari-st-gcc amiga-sas/c-5.10
 amiga-aztec amiga-dice-c aix)
@end example
@end defop


@node Multi-Row Operations, Indexed Sequential Access Methods, Match-Keys, Table Operations
@subsubsection Multi-Row Operations

@defop {Operation} {relational-table} row:retrieve*
Returns a procedure of optional arguments @var{match-key1} @dots{}
which returns a list of all rows in this table.  The optional
@var{match-key1} @dots{} arguments restrict actions to a subset of the
table.  For details see @xref{Match-Keys}.@refill
@end defop

@example
((plat 'row:retrieve*) a-key?) @result{}
((atari-st-turbo-c m68000 atari turbo-c)
 (atari-st-gcc m68000 atari gcc)
 (amiga-sas/c-5.10 m68000 amiga sas/c)
 (amiga-aztec m68000 amiga aztec)
 (amiga-dice-c m68000 amiga dice-c)
 (aix powerpc aix -))
@end example

@defop {Operation} {relational-table} row:remove*
Returns a procedure of optional arguments @var{match-key1} @dots{} which
removes and returns a list of all rows in this table.  The optional
@var{match-key1} @dots{} arguments restrict actions to a subset of the
table.@refill
@end defop

@defop {Operation} {relational-table} row:delete*
Returns a procedure of optional arguments @var{match-key1} @dots{}
which Deletes all rows from this table.  The optional @var{match-key1}
@dots{} arguments restrict deletions to a subset of the table.  The
value returned is unspecified.  The descriptor table and catalog entry
for this table are not affected.@refill
@end defop

@defop {Operation} {relational-table} for-each-row
Returns a procedure of arguments @var{proc} @var{match-key1} @dots{}
which calls @var{proc} with each @var{row} in this table.  The
optional @var{match-key1} @dots{} arguments restrict actions to a
subset of the table.  For details see @xref{Match-Keys}.@refill
@end defop

@noindent
Note that @code{row:insert*} and @code{row:update*} do @emph{not} use
match-keys.@refill

@defop {Operation} {relational-table} row:insert*
Returns a procedure of one argument, @var{rows}, which adds each row in
the list of rows, @var{rows}, to this table.  If a row for the primary
key specified by an element of @var{rows} already exists in this table,
an error is signaled.  The value returned is unspecified.@refill
@end defop

@defop {Operation} {relational-table} row:update*
Returns a procedure of one argument, @var{rows}, which adds each row in
the list of rows, @var{rows}, to this table.  If a row for the primary
key specified by an element of @var{rows} already exists in this table,
it will be overwritten.  The value returned is unspecified.@refill
@end defop


@node Indexed Sequential Access Methods, Sequential Index Operations, Multi-Row Operations, Table Operations
@subsubsection Indexed Sequential Access Methods

@noindent
@cindex ISAM
@dfn{Indexed Sequential Access Methods} are a way of arranging
database information so that records can be accessed both by key and
by key sequence (ordering).  @dfn{ISAM} is not part of Codd's
relational model.  Hardcore relational programmers might use some
least-upper-bound join for every row to get them into an order.@refill

@noindent
Associative memory in B-Trees is an example of a database
implementation which can support a native key ordering.  SLIB's
@code{alist-table} implementation uses @code{sort} to implement
@code{for-each-row-in-order}, but does not support @code{isam-next}
and @code{isam-prev}.@refill

@noindent
The multi-primary-key ordering employed by these operations is the
lexicographic collation of those primary-key fields in their given
order.  For example:@refill

@example
(12 a 34) < (12 a 36) < (12 b 1) < (13 a 0)
@end example


@node Sequential Index Operations, Table Administration, Indexed Sequential Access Methods, Table Operations
@subsubsection Sequential Index Operations

@noindent
The following procedures are individually optional depending on the
base-table implememtation.  If an operation is @emph{not} supported,
then calling the table with that operation symbol will return false.@refill

@defop {Operation} {relational-table} for-each-row-in-order
Returns a procedure of arguments @var{proc} @var{match-key1} @dots{}
which calls @var{proc} with each @var{row} in this table in the
(implementation-dependent) natural, repeatable ordering for rows.  The
optional @var{match-key1} @dots{} arguments restrict actions to a
subset of the table.  For details see @xref{Match-Keys}.@refill
@end defop

@defop {Operation} {relational-table} isam-next
Returns a procedure of arguments @var{key1} @var{key2} @dots{} which
returns the key-list identifying the lowest record higher than
@var{key1} @var{key2} @dots{} which is stored in the relational-table;
or false if no higher record is present.@refill

@defopx {Operation} {relational-table} isam-next column-name
The symbol @var{column-name} names a key field.  In the list returned
by @code{isam-next}, that field, or a field to its left, will be
changed.  This allows one to skip over less significant key fields.@refill
@end defop

@defop {Operation} {relational-table} isam-prev
Returns a procedure of arguments @var{key1} @var{key2} @dots{} which
returns the key-list identifying the highest record less than
@var{key1} @var{key2} @dots{} which is stored in the relational-table;
or false if no lower record is present.@refill

@defopx {Operation} {relational-table} isam-prev index
The symbol @var{column-name} names a key field.  In the list returned
by @code{isam-next}, that field, or a field to its left, will be
changed.  This allows one to skip over less significant key fields.@refill
@end defop

For example, if a table has key fields:@refill
@example
(col1 col2)
(9 5)
(9 6)
(9 7)
(9 8)
(12 5)
(12 6)
(12 7)
@end example

Then:@refill
@example
((table 'isam-next)       '(9 5))       @result{} (9 6)
((table 'isam-next 'col2) '(9 5))       @result{} (9 6)
((table 'isam-next 'col1) '(9 5))       @result{} (12 5)
((table 'isam-prev)       '(12 7))      @result{} (12 6)
((table 'isam-prev 'col2) '(12 7))      @result{} (12 6)
((table 'isam-prev 'col1) '(12 7))      @result{} (9 8)
@end example


@node Table Administration,  , Sequential Index Operations, Table Operations
@subsubsection Table Administration

@defop {Operation} {relational-table} column-names
@defopx {Operation} {relational-table} column-foreigns
@defopx {Operation} {relational-table} column-domains
@defopx {Operation} {relational-table} column-types
Return a list of the column names, foreign-key table names, domain
names, or type names respectively for this table.  These 4 methods are
different from the others in that the list is returned, rather than a
procedure to obtain the list.@refill

@defopx {Operation} {relational-table} primary-limit
Returns the number of primary keys fields in the relations in this
table.@refill
@end defop

@defop {Operation} {relational-table} close-table
Subsequent operations to this table will signal an error.@refill
@end defop

@node Database Interpolation, Embedded Commands, Table Operations, Relational Database
@subsection Database Interpolation

@code{(require 'database-interpolate)}@refill

@noindent
Indexed sequential access methods allow finding the keys (having
associations) closest to a given value.  This facilitates the
interpolation of associations between those in the table.@refill

@defun interpolate-from-table table column
@var{Table} should be a relational table with one numeric primary key
field which supports the @code{isam-prev} and @code{isam-next}
operations.  @var{column} should be a symbol or exact positive integer
designating a numerically valued column of @var{table}.@refill

@code{interpolate-from-table} calculates and returns a value
proportionally intermediate between its values in the next and
previous key records contained in @var{table}.  For keys larger than
all the stored keys the value associated with the largest stored key
is used.  For keys smaller than all the stored keys the value
associated with the smallest stored key is used.@refill
@end defun



@node Embedded Commands, Database Macros, Database Interpolation, Relational Database
@subsection Embedded Commands

@code{(require 'database-commands)}@refill

@noindent
This enhancement wraps a utility layer on @code{relational-database}
which provides:@refill

@itemize @bullet
@item
Automatic execution of initialization commands stored in database.@refill
@item
Transparent execution of database commands stored in @code{*commands*}
table in database.@refill
@end itemize

When an enhanced relational-database is called with a symbol which
matches a @var{name} in the @code{*commands*} table, the associated
procedure expression is evaluated and applied to the enhanced
relational-database.  A procedure should then be returned which the user
can invoke on (optional) arguments.@refill

The command @code{*initialize*} is special.  If present in the
@code{*commands*} table, @code{open-database} or @code{open-database!}
will return the value of the @code{*initialize*} command.  Notice that
arbitrary code can be run when the @code{*initialize*} procedure is
automatically applied to the enhanced relational-database.@refill

Note also that if you wish to shadow or hide from the user
relational-database methods described in @ref{Database Operations}, this
can be done by a dispatch in the closure returned by the
@code{*initialize*} expression rather than by entries in the
@code{*commands*} table if it is desired that the underlying methods
remain accessible to code in the @code{*commands*} table.@refill


@menu
* Database Extension::          
* Command Intrinsics::          
* Define-tables Example::       
* The *commands* Table::        
* Command Service::             
* Command Example::             
@end menu


@node Database Extension, Command Intrinsics, Embedded Commands, Embedded Commands
@subsubsection Database Extension

@defun wrap-command-interface rdb
Returns relational database @var{rdb} wrapped with additional commands
defined in its *commands* table.@refill
@end defun

@defun add-command-tables rdb
The relational database @var{rdb} must be mutable.
@var{add-command-tables} adds a *command* table to @var{rdb}; then
returns @code{(wrap-command-interface @var{rdb})}.@refill
@end defun

@defun define-*commands* rdb spec-0 @dots{}

Adds commands to the @code{*commands*} table as specified in
@var{spec-0} @dots{} to the open relational-database @var{rdb}.  Each
@var{spec} has the form:@refill

@lisp
((@r{<name>} @r{<rdb>}) @r{"comment"} @r{<expression1>} @r{<expression2>} @dots{})
@end lisp
or@refill
@lisp
((@r{<name>} @r{<rdb>}) @r{<expression1>} @r{<expression2>} @dots{})
@end lisp

where @r{<name>} is the command name, @r{<rdb>} is a formal passed the
calling relational database, @r{"comment"} describes the
command, and @r{<expression1>}, @r{<expression1>}, @dots{} are the
body of the procedure.@refill

@code{define-*commands*} adds to the @code{*commands*} table a command
@r{<name>}:@refill

@lisp
(lambda (@r{<name>} @r{<rdb>}) @r{<expression1>} @r{<expression2>} @dots{})
@end lisp

@end defun


@defun open-command-database filename
@defunx open-command-database filename base-table-type
Returns an open enhanced relational database associated with
@var{filename}.  The database will be opened with base-table type
@var{base-table-type}) if supplied.  If @var{base-table-type} is not
supplied, @code{open-command-database} will attempt to deduce the correct
base-table-type.  If the database can not be opened or if it lacks the
@code{*commands*} table, @code{#f} is returned.@refill

@defunx open-command-database! filename
@defunx open-command-database! filename base-table-type
Returns @emph{mutable} open enhanced relational database @dots{}@refill

@defunx open-command-database database
Returns @var{database} if it is an immutable relational database; #f
otherwise.@refill

@defunx open-command-database! database
Returns @var{database} if it is a mutable relational database; #f
otherwise.@refill
@end defun


@node Command Intrinsics, Define-tables Example, Database Extension, Embedded Commands
@subsubsection Command Intrinsics

Some commands are defined in all extended relational-databases.  The are
called just like @ref{Database Operations}.@refill

@defop {Operation} {relational-database} add-domain domain-row
Adds @var{domain-row} to the @dfn{domains} table if there is no row in
the domains table associated with key @code{(car @var{domain-row})} and
returns @code{#t}.  Otherwise returns @code{#f}.@refill

For the fields and layout of the domain table, @xref{Catalog
Representation}.  Currently, these fields are@refill
@itemize @bullet
@item
domain-name@refill
@item
foreign-table@refill
@item
domain-integrity-rule@refill
@item
type-id@refill
@item
type-param@refill
@end itemize

The following example adds 3 domains to the @samp{build} database.
@samp{Optstring} is either a string or @code{#f}.  @code{filename} is a
string and @code{build-whats} is a symbol.@refill

@example
(for-each (build 'add-domain)
          '((optstring #f
                       (lambda (x) (or (not x) (string? x)))
                       string
                       #f)
            (filename #f #f string #f)
            (build-whats #f #f symbol #f)))
@end example
@end defop

@defop {Operation} {relational-database} delete-domain domain-name
Removes and returns the @var{domain-name} row from the @dfn{domains}
table.@refill
@end defop

@defop {Operation} {relational-database} domain-checker domain
Returns a procedure to check an argument for conformance to domain
@var{domain}.@refill
@end defop


@node Define-tables Example, The *commands* Table, Command Intrinsics, Embedded Commands
@subsubsection Define-tables Example

@noindent
The following example shows a new database with the name of
@file{foo.db} being created with tables describing processor families
and processor/os/compiler combinations.  The database is then
solidified; saved and changed to immutable.@refill

@example
(require 'databases)
@ftindex databases
(define my-rdb (create-database "foo.db" 'alist-table))
(define-tables my-rdb
  '(processor-family
    ((family    atom))
    ((also-ran  processor-family))
    ((m68000           #f)
     (m68030           m68000)
     (i386             i8086)
     (i8086            #f)
     (powerpc          #f)))

  '(platform
    ((name      symbol))
    ((processor processor-family)
     (os        symbol)
     (compiler  symbol))
    ((aix              powerpc aix     -)
     (amiga-dice-c     m68000  amiga   dice-c)
     (amiga-aztec      m68000  amiga   aztec)
     (amiga-sas/c-5.10 m68000  amiga   sas/c)
     (atari-st-gcc     m68000  atari   gcc)
     (atari-st-turbo-c m68000  atari   turbo-c)
     (borland-c-3.1    i8086   ms-dos  borland-c)
     (djgpp            i386    ms-dos  gcc)
     (linux            i386    linux   gcc)
     (microsoft-c      i8086   ms-dos  microsoft-c)
     (os/2-emx         i386    os/2    gcc)
     (turbo-c-2        i8086   ms-dos  turbo-c)
     (watcom-9.0       i386    ms-dos  watcom))))

(solidify-database my-rdb)
@end example


@node The *commands* Table, Command Service, Define-tables Example, Embedded Commands
@subsubsection The *commands* Table

@noindent
The table @code{*commands*} in an @dfn{enhanced} relational-database has
the fields (with domains):@refill
@example
@group
PRI name        symbol
    parameters  parameter-list
    procedure   expression
    documentation string
@end group
@end example

The @code{parameters} field is a foreign key (domain
@code{parameter-list}) of the @code{*catalog-data*} table and should
have the value of a table described by @code{*parameter-columns*}.  This
@code{parameter-list} table describes the arguments suitable for passing
to the associated command.  The intent of this table is to be of a form
such that different user-interfaces (for instance, pull-down menus or
plain-text queries) can operate from the same table.  A
@code{parameter-list} table has the following fields:@refill
@example
@group
PRI index       ordinal
    name        symbol
    arity       parameter-arity
    domain      domain
    defaulter   expression
    expander    expression
    documentation string
@end group
@end example

The @code{arity} field can take the values:@refill

@table @code
@item single
Requires a single parameter of the specified domain.@refill
@item optional
A single parameter of the specified domain or zero parameters is
acceptable.@refill
@item boolean
A single boolean parameter or zero parameters (in which case @code{#f}
is substituted) is acceptable.@refill
@item nary
Any number of parameters of the specified domain are acceptable.  The
argument passed to the command function is always a list of the
parameters.@refill
@item nary1
One or more of parameters of the specified domain are acceptable.  The
argument passed to the command function is always a list of the
parameters.@refill
@end table

The @code{domain} field specifies the domain which a parameter or
parameters in the @code{index}th field must satisfy.@refill

The @code{defaulter} field is an expression whose value is either
@code{#f} or a procedure of one argument (the parameter-list) which
returns a @emph{list} of the default value or values as appropriate.
Note that since the @code{defaulter} procedure is called every time a
default parameter is needed for this column, @dfn{sticky} defaults can
be implemented using shared state with the domain-integrity-rule.@refill


@node Command Service, Command Example, The *commands* Table, Embedded Commands
@subsubsection Command Service

@defun make-command-server rdb table-name
Returns a procedure of 2 arguments, a (symbol) command and a call-back
procedure.  When this returned procedure is called, it looks up
@var{command} in table @var{table-name} and calls the call-back
procedure with arguments:@refill
@table @var
@item command
The @var{command}@refill
@item command-value
The result of evaluating the expression in the @var{procedure} field of
@var{table-name} and calling it with @var{rdb}.@refill
@item parameter-name
A list of the @dfn{official} name of each parameter.  Corresponds to the
@code{name} field of the @var{command}'s parameter-table.@refill
@item positions
A list of the positive integer index of each parameter.  Corresponds to
the @code{index} field of the @var{command}'s parameter-table.@refill
@item arities
A list of the arities of each parameter.  Corresponds to the
@code{arity} field of the @var{command}'s parameter-table.  For a
description of @code{arity} see table above.@refill
@item types
A list of the type name of each parameter.  Correspnds to the
@code{type-id} field of the contents of the @code{domain} of the
@var{command}'s parameter-table.@refill
@item defaulters
A list of the defaulters for each parameter.  Corresponds to
the @code{defaulters} field of the @var{command}'s parameter-table.@refill
@item domain-integrity-rules
A list of procedures (one for each parameter) which tests whether a
value for a parameter is acceptable for that parameter.  The procedure
should be called with each datum in the list for @code{nary} arity
parameters.@refill
@item aliases
A list of lists of @code{(@r{alias} @r{parameter-name})}.  There can be
more than one alias per @var{parameter-name}.@refill
@end table
@end defun

For information about parameters, @xref{Parameter lists}.@refill


@node Command Example,  , Command Service, Embedded Commands
@subsubsection Command Example

Here is an example of setting up a command with arguments and parsing
those arguments from a @code{getopt} style argument list
(@pxref{Getopt}).@refill

@example
(require 'database-commands)
@ftindex database-commands
(require 'databases)
@ftindex databases
(require 'getopt-parameters)
@ftindex getopt-parameters
(require 'parameters)
@ftindex parameters
(require 'getopt)
@ftindex getopt
(require 'fluid-let)
(require 'printf)

(define my-rdb (add-command-tables (create-database #f 'alist-table)))

(define-tables my-rdb
  '(foo-params
    *parameter-columns*
    *parameter-columns*
    ((1 single-string single string
        (lambda (pl) '("str")) #f "single string")
     (2 nary-symbols nary symbol
        (lambda (pl) '()) #f "zero or more symbols")
     (3 nary1-symbols nary1 symbol
        (lambda (pl) '(symb)) #f "one or more symbols")
     (4 optional-number optional ordinal
        (lambda (pl) '()) #f "zero or one number")
     (5 flag boolean boolean
        (lambda (pl) '(#f)) #f "a boolean flag")))
  '(foo-pnames
    ((name string))
    ((parameter-index ordinal))
    (("s" 1)
     ("single-string" 1)
     ("n" 2)
     ("nary-symbols" 2)
     ("N" 3)
     ("nary1-symbols" 3)
     ("o" 4)
     ("optional-number" 4)
     ("f" 5)
     ("flag" 5)))
  '(my-commands
    ((name symbol))
    ((parameters parameter-list)
     (parameter-names parameter-name-translation)
     (procedure expression)
     (documentation string))
    ((foo
      foo-params
      foo-pnames
      (lambda (rdb) (lambda args (print args)))
      "test command arguments"))))

(define (dbutil:serve-command-line rdb command-table command argv)
  (set! *argv* (if (vector? argv) (vector->list argv) argv))
  ((make-command-server rdb command-table)
   command
   (lambda (comname comval options positions
                    arities types defaulters dirs aliases)
     (apply comval (getopt->arglist options positions
                    arities types defaulters dirs aliases)))))

(define (cmd . opts)
  (fluid-let ((*optind* 1))
    (printf "%-34s @result{} "
            (call-with-output-string
             (lambda (pt) (write (cons 'cmd opts) pt))))
    (set! opts (cons "cmd" opts))
    (force-output)
    (dbutil:serve-command-line
     my-rdb 'my-commands 'foo (length opts) opts)))

(cmd)                              @result{} ("str" () (symb) () #f)
(cmd "-f")                         @result{} ("str" () (symb) () #t)
(cmd "--flag")                     @result{} ("str" () (symb) () #t)
(cmd "-o177")                      @result{} ("str" () (symb) (177) #f)
(cmd "-o" "177")                   @result{} ("str" () (symb) (177) #f)
(cmd "--optional" "621")           @result{} ("str" () (symb) (621) #f)
(cmd "--optional=621")             @result{} ("str" () (symb) (621) #f)
(cmd "-s" "speciality")            @result{} ("speciality" () (symb) () #f)
(cmd "-sspeciality")               @result{} ("speciality" () (symb) () #f)
(cmd "--single" "serendipity")     @result{} ("serendipity" () (symb) () #f)
(cmd "--single=serendipity")       @result{} ("serendipity" () (symb) () #f)
(cmd "-n" "gravity" "piety")       @result{} ("str" () (piety gravity) () #f)
(cmd "-ngravity" "piety")          @result{} ("str" () (piety gravity) () #f)
(cmd "--nary" "chastity")          @result{} ("str" () (chastity) () #f)
(cmd "--nary=chastity" "")         @result{} ("str" () ( chastity) () #f)
(cmd "-N" "calamity")              @result{} ("str" () (calamity) () #f)
(cmd "-Ncalamity")                 @result{} ("str" () (calamity) () #f)
(cmd "--nary1" "surety")           @result{} ("str" () (surety) () #f)
(cmd "--nary1=surety")             @result{} ("str" () (surety) () #f)
(cmd "-N" "levity" "fealty")       @result{} ("str" () (fealty levity) () #f)
(cmd "-Nlevity" "fealty")          @result{} ("str" () (fealty levity) () #f)
(cmd "--nary1" "surety" "brevity") @result{} ("str" () (brevity surety) () #f)
(cmd "--nary1=surety" "brevity")   @result{} ("str" () (brevity surety) () #f)
(cmd "-?")
@print{}
Usage: cmd [OPTION ARGUMENT ...] ...

  -f, --flag
  -o, --optional[=]<number>
  -n, --nary[=]<symbols> ...
  -N, --nary1[=]<symbols> ...
  -s, --single[=]<string>

ERROR: getopt->parameter-list "unrecognized option" "-?"
@end example



@node Database Macros, Database Browser, Embedded Commands, Relational Database
@subsection Database Macros

@code{(require 'within-database)}@refill

The object-oriented programming interface to SLIB relational databases
has failed to support clear, understandable, and modular code-writing
for database applications.@refill

This seems to be a failure of the object-oriented paradigm where the
type of an object is not manifest (or even traceable) in source code.@refill

@code{within-database}, along with the @samp{databases} package,
reorganizes high-level database functions toward a more declarative
style.  Using this package, one can tag database table and command
declarations for emacs:@refill

@example
etags -lscheme -r'/ *(define-\(command\|table\) (\([^; \t]+\)/\2/' \
      source1.scm ...
@end example

@menu
* Within-database Example::     
@end menu

@defun within-database database statement-1 @dots{}

@code{within-database} creates a lexical scope in which the commands
@code{define-table} and @code{define-command} create tables and
@code{*commands*}-table entries respectively in open relational
database @var{database}.@refill

@code{within-database} Returns @var{database}.@refill
@end defun

@deffn Syntax define-command (@r{<name>} @r{<rdb>}) @r{"comment"} @r{<expression1>} @r{<expression2>} @dots{}
@deffnx Syntax define-command (@r{<name>} @r{<rdb>}) @r{<expression1>} @r{<expression2>} @dots{}

Adds to the @code{*commands*} table a command
@r{<name>}:@refill

@lisp
(lambda (@r{<name>} @r{<rdb>}) @r{<expression1>} @r{<expression2>} @dots{})
@end lisp

@end deffn

@deffn Syntax define-table @r{<name>} @r{<descriptor-name>} @r{<descriptor-name>} @r{<rows>}
@deffnx Syntax define-table @r{<name>} @r{<primary-key-fields>} @r{<other-fields>} @r{<rows>}

where @r{<name>} is the table name, @r{<descriptor-name>} is the symbol
name of a descriptor table, @r{<primary-key-fields>} and
@r{<other-fields>} describe the primary keys and other fields
respectively, and @r{<rows>} is a list of data rows to be added to the
table.@refill

@r{<primary-key-fields>} and @r{<other-fields>} are lists of field
descriptors of the form:@refill

@lisp
(@r{<column-name>} @r{<domain>})
@end lisp
or@refill
@lisp
(@r{<column-name>} @r{<domain>} @r{<column-integrity-rule>})
@end lisp

where @r{<column-name>} is the column name, @r{<domain>} is the domain
of the column, and @r{<column-integrity-rule>} is an expression whose
value is a procedure of one argument (which returns @code{#f} to signal
an error).@refill

If @r{<domain>} is not a defined domain name and it matches the name of
this table or an already defined (in one of @var{spec-0} @dots{}) single
key field table, a foreign-key domain will be created for it.@refill

@end deffn


@node Within-database Example,  , Database Macros, Database Macros
@subsubsection Within-database Example

@noindent
Here is an example of @code{within-database} macros:@refill

@example
(require 'within-database)

(define my-rdb
  (add-command-tables
   (create-database "foo.db" 'alist-table)))

(within-database my-rdb
  (define-command (*initialize* rdb)
    "Print Welcome"
    (display "Welcome")
    (newline)
    rdb)
  (define-command (without-documentation rdb)
    (display "without-documentation called")
    (newline))
  (define-table (processor-family
                 ((family   atom))
                 ((also-ran processor-family)))
    (m68000  #f)
    (m68030  m68000)
    (i386    i8086)
    (i8086   #f)
    (powerpc #f))
  (define-table (platform
                 ((name symbol))
                 ((processor processor-family)
                  (os        symbol)
                  (compiler  symbol)))
    (aix              powerpc aix     -)
    ;; ...
    (amiga-aztec      m68000  amiga   aztec)
    (amiga-sas/c-5.10 m68000  amiga   sas/c)
    (atari-st-gcc     m68000  atari   gcc)
    ;; ...
    (watcom-9.0       i386    ms-dos  watcom))
  (define-command (get-processor rdb)
    "Get processor for given platform."
    (((rdb 'open-table) 'platform #f) 'get 'processor)))

(close-database my-rdb)

(set! my-rdb (open-command-database! "foo.db"))
@print{}
Welcome

(my-rdb 'without-documentation)
@print{}
without-documentation called

((my-rdb 'get-processor) 'amiga-sas/c-5.10)
@result{} m68000

(close-database my-rdb)
@end example



@node Database Browser,  , Database Macros, Relational Database
@subsection Database Browser

(require 'database-browse)@refill

@deffn {Procedure} browse database

Prints the names of all the tables in @var{database} and sets browse's
default to @var{database}.@refill

@deffnx {Procedure} browse

Prints the names of all the tables in the default database.@refill

@deffnx {Procedure} browse table-name

For each record of the table named by the symbol @var{table-name},
prints a line composed of all the field values.@refill

@deffnx {Procedure} browse pathname

Opens the database named by the string @var{pathname}, prints the names
of all its tables, and sets browse's default to the database.@refill

@deffnx {Procedure} browse database table-name

Sets browse's default to @var{database} and prints the records of the
table named by the symbol @var{table-name}.@refill

@deffnx {Procedure} browse pathname table-name

Opens the database named by the string @var{pathname} and sets browse's
default to it; @code{browse} prints the records of the table named by
the symbol @var{table-name}.@refill

@end deffn


@node Relational Infrastructure, Weight-Balanced Trees, Relational Database, Database Packages
@section Relational Infrastructure


@menu
* Base Table::                  
* Catalog Representation::      
* Relational Database Objects::  
* Database Operations::         
@end menu


@node Base Table, Catalog Representation, Relational Infrastructure, Relational Infrastructure
@subsection Base Table

@cindex base-table
A @dfn{base-table} is the primitive database layer upon which SLIB
relational databases are built.  At the minimum, it must support the
types integer, symbol, string, and boolean.  The base-table may restrict
the size of integers, symbols, and strings it supports.@refill

A base table implementation is available as the value of the identifier
naming it (eg. @var{alist-table}) after requiring the symbol of that
name.@refill

@deftp {Feature} alist-table
@code{(require 'alist-table)}@refill
@ftindex alist-table

Association-list base tables support all Scheme types and are suitable
for small databases.  In order to be retrieved after being written to a
file, the data stored should include only objects which are readable and
writeable in the Scheme implementation.@refill

The @dfn{alist-table} base-table implementation is included in the
SLIB distribution.@refill
@end deftp

@dfn{WB} is a B-tree database package with SCM interfaces.  Being
disk-based, WB databases readily store and access hundreds of
megabytes of data.  WB comes with two base-table embeddings.@refill

@deftp {Feature} wb-table
@code{(require 'wb-table)}@refill
@ftindex wb-table

@cindex WB
@code{wb-table} supports scheme expressions for keys and values whose
text representations are less than 255 characters in length.
@xref{wb-table, , , wb, WB}.@refill
@end deftp


@deftp {Feature} rwb-isam
@code{(require 'rwb-isam)}@refill
@ftindex rwb-isam

@dfn{rwb-isam} is a sophisticated base-table implementation built on
WB and SCM which uses binary numerical formats for key and non-key
fields.  It supports IEEE floating-point and fixed-precision integer
keys with the correct numerical collation order.@refill
@end deftp

This rest of this section documents the interface for a base table
implementation from which the @ref{Relational Database} package
constructs a Relational system.  It will be of interest primarily to
those wishing to port or write new base-table implementations.@refill

@defvar *base-table-implementations*
To support automatic dispatch for @code{open-database}, each base-table
module adds an association to @var{*base-table-implementations*} when
loaded.  This association is the list of the base-table symbol and the
value returned by @code{(make-relational-system @var{base-table})}.@refill
@end defvar

@menu
* The Base::                    
* Base Tables::                 
* Base Field Types::            
* Composite Keys::              
* Base Record Operations::      
* Match Keys::                  
* Aggregate Base Operations::   
* Base ISAM Operations::        
@end menu

@node The Base, Base Tables, Base Table, Base Table
@subsubsection The Base

All of these functions are accessed through a single procedure by
calling that procedure with the symbol name of the operation.  A
procedure will be returned if that operation is supported and @code{#f}
otherwise.  For example:@refill

@example
@group
(require 'alist-table)
@ftindex alist-table
@findex alist-table
(define my-base (alist-table 'make-base))
my-base         @result{} *a procedure*
(define foo (alist-table 'foo))
foo             @result{} #f
@end group
@end example

@defop {Operation} {base-table} make-base filename key-dimension column-types
Returns a new, open, low-level database (collection of tables)
associated with @var{filename}.  This returned database has an empty
table associated with @var{catalog-id}.  The positive integer
@var{key-dimension} is the number of keys composed to make a
@var{primary-key} for the catalog table.  The list of symbols
@var{column-types} describes the types of each column for that table.
If the database cannot be created as specified, @code{#f} is returned.@refill

Calling the @code{close-base} method on this database and possibly other
operations will cause @var{filename} to be written to.  If
@var{filename} is @code{#f} a temporary, non-disk based database will be
created if such can be supported by the base table implelentation.@refill
@end defop

@defop {Operation} {base-table} open-base filename mutable
Returns an open low-level database associated with @var{filename}.  If
@var{mutable} is @code{#t}, this database will have methods capable of
effecting change to the database.  If @var{mutable} is @code{#f}, only
methods for inquiring the database will be available.  If the database
cannot be opened as specified @code{#f} is returned.@refill

Calling the @code{close-base} (and possibly other) method on a
@var{mutable} database will cause @var{filename} to be written to.@refill
@end defop

@defop {Operation} {base-table} write-base lldb filename
Causes the low-level database @var{lldb} to be written to
@var{filename}.  If the write is successful, also causes @var{lldb} to
henceforth be associated with @var{filename}.  Calling the
@code{close-database} (and possibly other) method on @var{lldb} may
cause @var{filename} to be written to.  If @var{filename} is @code{#f}
this database will be changed to a temporary, non-disk based database if
such can be supported by the underlying base table implelentation.  If
the operations completed successfully, @code{#t} is returned.
Otherwise, @code{#f} is returned.@refill
@end defop

@defop {Operation} {base-table} sync-base lldb
Causes the file associated with the low-level database @var{lldb} to be
updated to reflect its current state.  If the associated filename is
@code{#f}, no action is taken and @code{#f} is returned.  If this
operation completes successfully, @code{#t} is returned.  Otherwise,
@code{#f} is returned.@refill
@end defop

@defop {Operation} {base-table} close-base lldb
Causes the low-level database @var{lldb} to be written to its associated
file (if any).  If the write is successful, subsequent operations to
@var{lldb} will signal an error.  If the operations complete
successfully, @code{#t} is returned.  Otherwise, @code{#f} is returned.@refill
@end defop


@node Base Tables, Base Field Types, The Base, Base Table
@subsubsection Base Tables

@defop {Operation} {base-table} make-table lldb key-dimension column-types
Returns the ordinal @var{base-id} for a new base table, otherwise
returns @code{#f}.  The base table can then be opened using
@code{(open-table @var{lldb} @var{base-id})}.  The positive integer
@var{key-dimension} is the number of keys composed to make a
@var{primary-key} for this table.  The list of symbols
@var{column-types} describes the types of each column.@refill
@end defop

@defop {Operation} {base-table} open-table lldb base-id key-dimension column-types
Returns a @var{handle} for an existing base table in the low-level
database @var{lldb} if that table exists and can be opened in the mode
indicated by @var{mutable}, otherwise returns @code{#f}.@refill

As with @code{make-table}, the positive integer @var{key-dimension} is
the number of keys composed to make a @var{primary-key} for this table.
The list of symbols @var{column-types} describes the types of each
column.@refill
@end defop

@defop {Operation} {base-table} kill-table lldb base-id key-dimension column-types
Returns @code{#t} if the base table associated with @var{base-id} was
removed from the low level database @var{lldb}, and @code{#f} otherwise.@refill
@end defop

@defop {Operation} {base-table} catalog-id
A constant @var{base-id} ordinal suitable for passing as a parameter to
@code{open-table}.  @var{catalog-id} will be used as the base table for
the system catalog.@refill
@end defop


@node Base Field Types, Composite Keys, Base Tables, Base Table
@subsubsection Base Field Types

@defop {Operation} {base-table} supported-type? symbol
Returns @code{#t} if @var{symbol} names a type allowed as a column
value by the implementation, and @code{#f} otherwise.  At a minimum,
an implementation must support the types @code{integer},
@code{ordinal}, @code{symbol}, @code{string}, and @code{boolean}.@refill
@end defop

@defop {Operation} {base-table} supported-key-type? symbol
Returns @code{#t} if @var{symbol} names a type allowed as a key value
by the implementation, and @code{#f} otherwise.  At a minimum, an
implementation must support the types @code{ordinal}, and
@code{symbol}.@refill
@end defop

@noindent
An @dfn{ordinal} is an exact positive integer.  The other types are
standard Scheme.@refill


@node Composite Keys, Base Record Operations, Base Field Types, Base Table
@subsubsection Composite Keys

@defop {Operation} {base-table} make-keyifier-1 type
Returns a procedure which accepts a single argument which must be of
type @var{type}.  This returned procedure returns an object suitable for
being a @var{key} argument in the functions whose descriptions follow.@refill

Any 2 arguments of the supported type passed to the returned function
which are not @code{equal?} must result in returned values which are not
@code{equal?}.@refill
@end defop

@defop {Operation} {base-table} make-list-keyifier key-dimension types
The list of symbols @var{types} must have at least @var{key-dimension}
elements.  Returns a procedure which accepts a list of length
@var{key-dimension} and whose types must corresopond to the types named
by @var{types}.  This returned procedure combines the elements of its
list argument into an object suitable for being a @var{key} argument in
the functions whose descriptions follow.@refill

Any 2 lists of supported types (which must at least include symbols and
non-negative integers) passed to the returned function which are not
@code{equal?} must result in returned values which are not
@code{equal?}.@refill
@end defop

@defop {Operation} {base-table} make-key-extractor key-dimension types column-number
Returns a procedure which accepts objects produced by application of the
result of @code{(make-list-keyifier @var{key-dimension} @var{types})}.
This procedure returns a @var{key} which is @code{equal?} to the
@var{column-number}th element of the list which was passed to create
@var{composite-key}.  The list @var{types} must have at least
@var{key-dimension} elements.@refill
@end defop

@defop {Operation} {base-table} make-key->list key-dimension types
Returns a procedure which accepts objects produced by application of
the result of @code{(make-list-keyifier @var{key-dimension}
@var{types})}.  This procedure returns a list of @var{key}s which are
elementwise @code{equal?} to the list which was passed to create
@var{composite-key}.@refill
@end defop


@node Base Record Operations, Match Keys, Composite Keys, Base Table
@subsubsection Base Record Operations

@noindent
In the following functions, the @var{key} argument can always be assumed
to be the value returned by a call to a @emph{keyify} routine.@refill

@defop {Operation} {base-table} present? handle key
Returns a non-@code{#f} value if there is a row associated with
@var{key} in the table opened in @var{handle} and @code{#f} otherwise.@refill
@end defop

@defop {Operation} {base-table} make-getter key-dimension types
Returns a procedure which takes arguments @var{handle} and @var{key}.
This procedure returns a list of the non-primary values of the relation
(in the base table opened in @var{handle}) whose primary key is
@var{key} if it exists, and @code{#f} otherwise.@refill
@end defop

@noindent
@code{make-getter-1} is a new operation.  The relational-database
module works with older base-table implementations by using
@code{make-getter}.@refill

@defop {Operation} {base-table} make-getter-1 key-dimension types index
Returns a procedure which takes arguments @var{handle} and @var{key}.
This procedure returns the value of the @var{index}th field (in the
base table opened in @var{handle}) whose primary key is @var{key} if
it exists, and @code{#f} otherwise.@refill

@var{index} must be larger than @var{key-dimension}.@refill
@end defop

@defop {Operation} {base-table} make-putter key-dimension types
Returns a procedure which takes arguments @var{handle} and @var{key} and
@var{value-list}.  This procedure associates the primary key @var{key}
with the values in @var{value-list} (in the base table opened in
@var{handle}) and returns an unspecified value.@refill
@end defop

@defop {Operation} {base-table} delete handle key
Removes the row associated with @var{key} from the table opened in
@var{handle}.  An unspecified value is returned.@refill
@end defop


@node Match Keys, Aggregate Base Operations, Base Record Operations, Base Table
@subsubsection Match Keys

@noindent
@cindex match-keys
@cindex match
@cindex wild-card
A @var{match-keys} argument is a list of length equal to
the number of primary keys.  The @var{match-keys} restrict the actions
of the table command to those records whose primary keys all satisfy the
corresponding element of the @var{match-keys} list.  The elements and
their actions are:@refill

@quotation
@table @asis
@item @code{#f}
The false value matches any key in the corresponding position.@refill
@item an object of type procedure
This procedure must take a single argument, the key in the corresponding
position.  Any key for which the procedure returns a non-false value is
a match; Any key for which the procedure returns a @code{#f} is not.@refill
@item other values
Any other value matches only those keys @code{equal?} to it.@refill
@end table
@end quotation


@node Aggregate Base Operations, Base ISAM Operations, Match Keys, Base Table
@subsubsection Aggregate Base Operations

@noindent
The @var{key-dimension} and @var{column-types} arguments are needed to
decode the composite-keys for matching with @var{match-keys}.@refill

@defop {Operation} {base-table} delete* handle key-dimension column-types match-keys
Removes all rows which satisfy @var{match-keys} from the table opened in
@var{handle}.  An unspecified value is returned.@refill
@end defop

@defop {Operation} {base-table} for-each-key handle procedure key-dimension column-types match-keys
Calls @var{procedure} once with each @var{key} in the table opened in
@var{handle} which satisfy @var{match-keys} in an unspecified order.
An unspecified value is returned.@refill
@end defop

@defop {Operation} {base-table} map-key handle procedure key-dimension column-types match-keys
Returns a list of the values returned by calling @var{procedure} once
with each @var{key} in the table opened in @var{handle} which satisfy
@var{match-keys} in an unspecified order.@refill
@end defop


@node Base ISAM Operations,  , Aggregate Base Operations, Base Table
@subsubsection Base ISAM Operations

@noindent
These operations are optional for a Base-Table implementation.@refill

@defop {Operation} {base-table} ordered-for-each-key handle procedure key-dimension column-types match-keys
Calls @var{procedure} once with each @var{key} in the table opened in
@var{handle} which satisfy @var{match-keys} in the natural order for
the types of the primary key fields of that table.  An unspecified value
is returned.@refill
@end defop

@defop {Operation} {base-table} make-nexter handle key-dimension column-types index
Returns a procedure of arguments @var{key1} @var{key2} @dots{} which
returns the key-list identifying the lowest record higher than
@var{key1} @var{key2} @dots{} which is stored in the base-table and
which differs in column @var{index} or a lower indexed key; or false
if no higher record is present.@refill
@end defop

@defop {Operation} {base-table} make-prever handle key-dimension column-types index
Returns a procedure of arguments @var{key1} @var{key2} @dots{} which
returns the key-list identifying the highest record less than
@var{key1} @var{key2} @dots{} which is stored in the base-table and
which differs in column @var{index} or a lower indexed key; or false
if no higher record is present.@refill
@end defop

@node Catalog Representation, Relational Database Objects, Base Table, Relational Infrastructure
@subsection Catalog Representation

@noindent
Each database (in an implementation) has a @dfn{system catalog} which
describes all the user accessible tables in that database (including
itself).@refill

@noindent
The system catalog base table has the following fields.  @code{PRI}
indicates a primary key for that table.@refill

@example
@group
PRI table-name
    column-limit            the highest column number
    coltab-name             descriptor table name
    bastab-id               data base table identifier
    user-integrity-rule
    view-procedure          A scheme thunk which, when called,
                            produces a handle for the view.  coltab
                            and bastab are specified if and only if
                            view-procedure is not.
@end group
@end example

@noindent
Descriptors for base tables (not views) are tables (pointed to by
system catalog).  Descriptor (base) tables have the fields:@refill

@example
@group
PRI column-number           sequential integers from 1
    primary-key?            boolean TRUE for primary key components
    column-name
    column-integrity-rule
    domain-name
@end group
@end example

@noindent
A @dfn{primary key} is any column marked as @code{primary-key?} in the
corresponding descriptor table.  All the @code{primary-key?} columns
must have lower column numbers than any non-@code{primary-key?} columns.
Every table must have at least one primary key.  Primary keys must be
sufficient to distinguish all rows from each other in the table.  All of
the system defined tables have a single primary key.@refill

@noindent
A @dfn{domain} is a category describing the allowable values to occur in
a column.  It is described by a (base) table with the fields:@refill

@example
@group
PRI domain-name
    foreign-table
    domain-integrity-rule
    type-id
    type-param
@end group
@end example

@noindent
The @dfn{type-id} field value is a symbol.  This symbol may be used by
the underlying base table implementation in storing that field.@refill

@noindent
If the @code{foreign-table} field is non-@code{#f} then that field names
a table from the catalog.  The values for that domain must match a
primary key of the table referenced by the @var{type-param} (or
@code{#f}, if allowed).  This package currently does not support
composite foreign-keys.@refill

@noindent
The types for which support is planned are:@refill
@example
@group
    atom
    symbol
    string                  [<length>]
    number                  [<base>]
    money                   <currency>
    date-time
    boolean

    foreign-key             <table-name>
    expression
    virtual                 <expression>
@end group
@end example


@node Relational Database Objects, Database Operations, Catalog Representation, Relational Infrastructure
@subsection Relational Database Objects

@noindent
This object-oriented interface is deprecated for typical database
applications; @ref{Using Databases} provides an application programmer
interface which is easier to understand and use.@refill

@defun make-relational-system base-table-implementation

Returns a procedure implementing a relational database using the
@var{base-table-implementation}.@refill

All of the operations of a base table implementation are accessed
through a procedure defined by @code{require}ing that implementation.
Similarly, all of the operations of the relational database
implementation are accessed through the procedure returned by
@code{make-relational-system}.  For instance, a new relational database
could be created from the procedure returned by
@code{make-relational-system} by:@refill

@example
(require 'alist-table)
@ftindex alist-table
(define relational-alist-system
        (make-relational-system alist-table))
(define create-alist-database
        (relational-alist-system 'create-database))
(define my-database
        (create-alist-database "mydata.db"))
@end example
@end defun

@noindent
What follows are the descriptions of the methods available from
relational system returned by a call to @code{make-relational-system}.@refill

@defop {Operation} {relational-system} create-database filename

Returns an open, nearly empty relational database associated with
@var{filename}.  The only tables defined are the system catalog and
domain table.  Calling the @code{close-database} method on this database
and possibly other operations will cause @var{filename} to be written
to.  If @var{filename} is @code{#f} a temporary, non-disk based database
will be created if such can be supported by the underlying base table
implelentation.  If the database cannot be created as specified
@code{#f} is returned.  For the fields and layout of descriptor tables,
@ref{Catalog Representation}@refill
@end defop

@defop {Operation} {relational-system} open-database filename mutable?

Returns an open relational database associated with @var{filename}.  If
@var{mutable?} is @code{#t}, this database will have methods capable of
effecting change to the database.  If @var{mutable?} is @code{#f}, only
methods for inquiring the database will be available.  Calling the
@code{close-database} (and possibly other) method on a @var{mutable?}
database will cause @var{filename} to be written to.  If the database
cannot be opened as specified @code{#f} is returned.@refill
@end defop


@node Database Operations,  , Relational Database Objects, Relational Infrastructure
@subsection Database Operations

@noindent
This object-oriented interface is deprecated for typical database
applications; @ref{Using Databases} provides an application programmer
interface which is easier to understand and use.@refill

@noindent
These are the descriptions of the methods available from an open
relational database.  A method is retrieved from a database by calling
the database with the symbol name of the operation.  For example:@refill

@example
(define my-database
        (create-alist-database "mydata.db"))
(define telephone-table-desc
        ((my-database 'create-table) 'telephone-table-desc))
@end example

@defop {Operation} {relational-database} close-database
Causes the relational database to be written to its associated file (if
any).  If the write is successful, subsequent operations to this
database will signal an error.  If the operations completed
successfully, @code{#t} is returned.  Otherwise, @code{#f} is returned.@refill
@end defop

@defop {Operation} {relational-database} write-database filename
Causes the relational database to be written to @var{filename}.  If the
write is successful, also causes the database to henceforth be
associated with @var{filename}.  Calling the @code{close-database} (and
possibly other) method on this database will cause @var{filename} to be
written to.  If @var{filename} is @code{#f} this database will be
changed to a temporary, non-disk based database if such can be supported
by the underlying base table implelentation.  If the operations
completed successfully, @code{#t} is returned.  Otherwise, @code{#f} is
returned.@refill
@end defop

@defop {Operation} {relational-database} sync-database
Causes any pending updates to the database file to be written out.  If
the operations completed successfully, @code{#t} is returned.
Otherwise, @code{#f} is returned.@refill
@end defop

@defop {Operation} {relational-database} solidify-database
Causes any pending updates to the database file to be written out.  If
the writes completed successfully, then the database is changed to be
immutable and @code{#t} is returned.  Otherwise, @code{#f} is returned.@refill
@end defop

@defop {Operation} {relational-database} table-exists? table-name
Returns @code{#t} if @var{table-name} exists in the system catalog,
otherwise returns @code{#f}.@refill
@end defop

@defop {Operation} {relational-database} open-table table-name mutable?
Returns a @dfn{methods} procedure for an existing relational table in
this database if it exists and can be opened in the mode indicated by
@var{mutable?}, otherwise returns @code{#f}.@refill
@end defop

@noindent
These methods will be present only in mutable databases.@refill

@defop {Operation} {relational-database} delete-table table-name
Removes and returns the @var{table-name} row from the system catalog if
the table or view associated with @var{table-name} gets removed from the
database, and @code{#f} otherwise.@refill
@end defop

@defop {Operation} {relational-database} create-table table-desc-name
Returns a methods procedure for a new (open) relational table for
describing the columns of a new base table in this database, otherwise
returns @code{#f}.  For the fields and layout of descriptor tables,
@xref{Catalog Representation}.@refill

@defopx {Operation} {relational-database} create-table table-name table-desc-name
Returns a methods procedure for a new (open) relational table with
columns as described by @var{table-desc-name}, otherwise returns
@code{#f}.@refill
@end defop

@defop {Operation} {relational-database} create-view ??
@defopx {Operation} {relational-database} project-table ??
@defopx {Operation} {relational-database} restrict-table ??
@defopx {Operation} {relational-database} cart-prod-tables ??
Not yet implemented.@refill
@end defop


@node Weight-Balanced Trees,  , Relational Infrastructure, Database Packages
@section Weight-Balanced Trees

@code{(require 'wt-tree)}@refill
@ftindex wt-tree

@cindex trees, balanced binary
@cindex balanced binary trees
@cindex binary trees
@cindex weight-balanced binary trees
Balanced binary trees are a useful data structure for maintaining large
sets of ordered objects or sets of associations whose keys are ordered.
MIT Scheme has an comprehensive implementation of weight-balanced binary
trees which has several advantages over the other data structures for
large aggregates:@refill

@itemize @bullet
@item
In addition to the usual element-level operations like insertion,
deletion and lookup, there is a full complement of collection-level
operations, like set intersection, set union and subset test, all of
which are implemented with good orders of growth in time and space.
This makes weight balanced trees ideal for rapid prototyping of
functionally derived specifications.@refill

@item
An element in a tree may be indexed by its position under the ordering
of the keys, and the ordinal position of an element may be determined,
both with reasonable efficiency.@refill

@item
Operations to find and remove minimum element make weight balanced trees
simple to use for priority queues.@refill

@item
The implementation is @emph{functional} rather than @emph{imperative}.
This means that operations like `inserting' an association in a tree do
not destroy the old tree, in much the same way that @code{(+ 1 x)}
modifies neither the constant 1 nor the value bound to @code{x}.  The
trees are referentially transparent thus the programmer need not worry
about copying the trees.  Referential transparency allows space
efficiency to be achieved by sharing subtrees.@refill

@end itemize

These features make weight-balanced trees suitable for a wide range of
applications, especially those that
require large numbers of sets or discrete maps.  Applications that have
a few global databases and/or concentrate on element-level operations like
insertion and lookup are probably better off using hash-tables or
red-black trees.@refill

The @emph{size} of a tree is the number of associations that it
contains.  Weight balanced binary trees are balanced to keep the sizes
of the subtrees of each node within a constant factor of each other.
This ensures logarithmic times for single-path operations (like lookup
and insertion).  A weight balanced tree takes space that is proportional
to the number of associations in the tree.  For the current
implementation, the constant of proportionality is six words per
association.@refill

@cindex binary trees, as sets
@cindex binary trees, as discrete maps
@cindex sets, using binary trees
@cindex discrete maps, using binary trees
Weight balanced trees can be used as an implementation for either
discrete sets or discrete maps (associations).  Sets are implemented by
ignoring the datum that is associated with the key.  Under this scheme
if an associations exists in the tree this indicates that the key of the
association is a member of the set.  Typically a value such as
@code{()}, @code{#t} or @code{#f} is associated with the key.@refill

Many operations can be viewed as computing a result that, depending on
whether the tree arguments are thought of as sets or maps, is known by
two different names.  An example is @code{wt-tree/member?}, which, when
regarding the tree argument as a set, computes the set membership
operation, but, when regarding the tree as a discrete map,
@code{wt-tree/member?} is the predicate testing if the map is defined at
an element in its domain.  Most names in this package have been chosen
based on interpreting the trees as sets, hence the name
@code{wt-tree/member?} rather than @code{wt-tree/defined-at?}.@refill


@cindex run-time-loadable option
@cindex option, run-time-loadable
The weight balanced tree implementation is a run-time-loadable option.
To use weight balanced trees, execute@refill

@example
(load-option 'wt-tree)
@end example
@ftindex load-option

@noindent
once before calling any of the procedures defined here.@refill


@menu
* Construction of Weight-Balanced Trees::  
* Basic Operations on Weight-Balanced Trees::  
* Advanced Operations on Weight-Balanced Trees::  
* Indexing Operations on Weight-Balanced Trees::  
@end menu

@node Construction of Weight-Balanced Trees, Basic Operations on Weight-Balanced Trees, Weight-Balanced Trees, Weight-Balanced Trees
@subsection Construction of Weight-Balanced Trees

Binary trees require there to be a total order on the keys used to
arrange the elements in the tree.  Weight balanced trees are organized
by @emph{types}, where the type is an object encapsulating the ordering
relation.  Creating a tree is a two-stage process.  First a tree type
must be created from the predicate which gives the ordering.  The tree
type is then used for making trees, either empty or singleton trees or
trees from other aggregate structures like association lists.  Once
created, a tree `knows' its type and the type is used to test
compatibility between trees in operations taking two trees.  Usually a
small number of tree types are created at the beginning of a program and
used many times throughout the program's execution.@refill

@deffn {procedure+} make-wt-tree-type key<?
This procedure creates and returns a new tree type based on the ordering
predicate @var{key<?}.
@var{Key<?} must be a total ordering, having the property that for all
key values @code{a}, @code{b} and @code{c}:@refill

@example
(key<? a a)                         @result{} #f
(and (key<? a b) (key<? b a))       @result{} #f
(if (and (key<? a b) (key<? b c))
    (key<? a c)
    #t)                             @result{} #t
@end example

@noindent
Two key values are assumed to be equal if neither is less than the other
by @var{key<?}.@refill

Each call to @code{make-wt-tree-type} returns a distinct value, and
trees are only compatible if their tree types are @code{eq?}.  A
consequence is that trees that are intended to be used in binary tree
operations must all be created with a tree type originating from the
same call to @code{make-wt-tree-type}.@refill
@end deffn

@defvr {variable+} number-wt-type
A standard tree type for trees with numeric keys.  @code{Number-wt-type}
could have been defined by@refill

@example
(define number-wt-type (make-wt-tree-type  <))
@end example
@end defvr

@defvr {variable+} string-wt-type
A standard tree type for trees with string keys.  @code{String-wt-type}
could have been defined by@refill

@example
(define string-wt-type (make-wt-tree-type  string<?))
@end example
@end defvr



@deffn {procedure+} make-wt-tree wt-tree-type
This procedure creates and returns a newly allocated weight balanced
tree.  The tree is empty, i.e. it contains no associations.
@var{Wt-tree-type} is a weight balanced tree type obtained by calling
@code{make-wt-tree-type}; the returned tree has this type.@refill
@end deffn

@deffn {procedure+} singleton-wt-tree wt-tree-type key datum
This procedure creates and returns a newly allocated weight balanced
tree.  The tree contains a single association, that of @var{datum} with
@var{key}.  @var{Wt-tree-type} is a weight balanced tree type obtained
by calling @code{make-wt-tree-type}; the returned tree has this type.@refill
@end deffn

@deffn {procedure+} alist->wt-tree tree-type alist
Returns a newly allocated weight-balanced tree that contains the same
associations as @var{alist}.  This procedure is equivalent to:@refill

@example
(lambda (type alist)
  (let ((tree (make-wt-tree type)))
    (for-each (lambda (association)
                (wt-tree/add! tree
                              (car association)
                              (cdr association)))
              alist)
    tree))
@end example
@end deffn



@node Basic Operations on Weight-Balanced Trees, Advanced Operations on Weight-Balanced Trees, Construction of Weight-Balanced Trees, Weight-Balanced Trees
@subsection Basic Operations on Weight-Balanced Trees

This section describes the basic tree operations on weight balanced
trees.  These operations are the usual tree operations for insertion,
deletion and lookup, some predicates and a procedure for determining the
number of associations in a tree.@refill

@c @deffn {procedure+} wt-tree? object
@c Returns @code{#t} if @var{object} is a weight-balanced tree, otherwise
@c returns @code{#f}.
@c @end deffn

@deffn {procedure+} wt-tree/empty? wt-tree
Returns @code{#t} if @var{wt-tree} contains no associations, otherwise
returns @code{#f}.@refill
@end deffn

@deffn {procedure+} wt-tree/size wt-tree
Returns the number of associations in @var{wt-tree}, an exact
non-negative integer.  This operation takes constant time.@refill
@end deffn


@deffn {procedure+} wt-tree/add wt-tree key datum
Returns a new tree containing all the associations in @var{wt-tree} and
the association of @var{datum} with @var{key}.  If @var{wt-tree} already
had an association for @var{key}, the new association overrides the old.
The average and worst-case times required by this operation are
proportional to the logarithm of the number of associations in
@var{wt-tree}.@refill
@end deffn

@deffn {procedure+} wt-tree/add! wt-tree key datum
Associates @var{datum} with @var{key} in @var{wt-tree} and returns an
unspecified value.  If @var{wt-tree} already has an association for
@var{key}, that association is replaced.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in @var{wt-tree}.@refill
@end deffn

@deffn {procedure+} wt-tree/member? key wt-tree
Returns @code{#t} if @var{wt-tree} contains an association for
@var{key}, otherwise returns @code{#f}.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in @var{wt-tree}.@refill
@end deffn

@deffn {procedure+} wt-tree/lookup wt-tree key default
Returns the datum associated with @var{key} in @var{wt-tree}.  If
@var{wt-tree} doesn't contain an association for @var{key},
@var{default} is returned.  The average and worst-case times required by
this operation are proportional to the logarithm of the number of
associations in @var{wt-tree}.@refill
@end deffn

@deffn {procedure+} wt-tree/delete wt-tree key
Returns a new tree containing all the associations in @var{wt-tree},
except that if @var{wt-tree} contains an association for @var{key}, it
is removed from the result.  The average and worst-case times required
by this operation are proportional to the logarithm of the number of
associations in @var{wt-tree}.@refill
@end deffn

@deffn {procedure+} wt-tree/delete! wt-tree key
If @var{wt-tree} contains an association for @var{key} the association
is removed.  Returns an unspecified value.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in @var{wt-tree}.@refill
@end deffn


@node Advanced Operations on Weight-Balanced Trees, Indexing Operations on Weight-Balanced Trees, Basic Operations on Weight-Balanced Trees, Weight-Balanced Trees
@subsection Advanced Operations on Weight-Balanced Trees

In the following the @emph{size} of a tree is the number of associations
that the tree contains, and a @emph{smaller} tree contains fewer
associations.@refill

@deffn {procedure+} wt-tree/split< wt-tree bound
Returns a new tree containing all and only the associations in
@var{wt-tree} which have a key that is less than @var{bound} in the
ordering relation of the tree type of @var{wt-tree}.  The average and
worst-case times required by this operation are proportional to the
logarithm of the size of @var{wt-tree}.@refill
@end deffn

@deffn {procedure+} wt-tree/split> wt-tree bound
Returns a new tree containing all and only the associations in
@var{wt-tree} which have a key that is greater than @var{bound} in the
ordering relation of the tree type of @var{wt-tree}.  The average and
worst-case times required by this operation are proportional to the
logarithm of size of @var{wt-tree}.@refill
@end deffn

@deffn {procedure+} wt-tree/union wt-tree-1 wt-tree-2
Returns a new tree containing all the associations from both trees.
This operation is asymmetric: when both trees have an association for
the same key, the returned tree associates the datum from @var{wt-tree-2}
with the key.  Thus if the trees are viewed as discrete maps then
@code{wt-tree/union} computes the map override of @var{wt-tree-1} by
@var{wt-tree-2}.  If the trees are viewed as sets the result is the set
union of the arguments.
The worst-case time required by this operation
is proportional to the sum of the sizes of both trees.
If the minimum key of one tree is greater than the maximum key of
the other tree then the time required is at worst proportional to
the logarithm of the size of the larger tree.@refill
@end deffn

@deffn {procedure+} wt-tree/intersection wt-tree-1 wt-tree-2
Returns a new tree containing all and only those associations from
@var{wt-tree-1} which have keys appearing as the key of an association
in @var{wt-tree-2}.  Thus the associated data in the result are those
from @var{wt-tree-1}.  If the trees are being used as sets the result is
the set intersection of the arguments.  As a discrete map operation,
@code{wt-tree/intersection} computes the domain restriction of
@var{wt-tree-1} to (the domain of) @var{wt-tree-2}.
The time required by this operation is never worse that proportional to
the sum of the sizes of the trees.@refill
@end deffn

@deffn {procedure+} wt-tree/difference wt-tree-1 wt-tree-2
Returns a new tree containing all and only those associations from
@var{wt-tree-1} which have keys that @emph{do not} appear as the key of
an association in @var{wt-tree-2}.  If the trees are viewed as sets the
result is the asymmetric set difference of the arguments.  As a discrete
map operation, it computes the domain restriction of @var{wt-tree-1} to
the complement of (the domain of) @var{wt-tree-2}.
The time required by this operation is never worse that proportional to
the sum of the sizes of the trees.@refill
@end deffn


@deffn {procedure+} wt-tree/subset? wt-tree-1 wt-tree-2
Returns @code{#t} iff the key of each association in @var{wt-tree-1} is
the key of some association in @var{wt-tree-2}, otherwise returns @code{#f}.
Viewed as a set operation, @code{wt-tree/subset?} is the improper subset
predicate.
A proper subset predicate can be constructed:@refill

@example
(define (proper-subset? s1 s2)
  (and (wt-tree/subset? s1 s2)
       (< (wt-tree/size s1) (wt-tree/size s2))))
@end example

As a discrete map operation, @code{wt-tree/subset?} is the subset
test on the domain(s) of the map(s).  In the worst-case the time
required by this operation is proportional to the size of
@var{wt-tree-1}.@refill
@end deffn


@deffn {procedure+} wt-tree/set-equal? wt-tree-1 wt-tree-2
Returns @code{#t} iff for every association in @var{wt-tree-1} there is
an association in @var{wt-tree-2} that has the same key, and @emph{vice
versa}.@refill

Viewing the arguments as sets @code{wt-tree/set-equal?} is the set
equality predicate.  As a map operation it determines if two maps are
defined on the same domain.@refill

This procedure is equivalent to@refill

@example
(lambda (wt-tree-1 wt-tree-2)
  (and (wt-tree/subset? wt-tree-1 wt-tree-2
       (wt-tree/subset? wt-tree-2 wt-tree-1)))
@end example

In the worst-case the time required by this operation is proportional to
the size of the smaller tree.@refill
@end deffn


@deffn {procedure+} wt-tree/fold combiner initial wt-tree
This procedure reduces @var{wt-tree} by combining all the associations,
using an reverse in-order traversal, so the associations are visited in
reverse order.  @var{Combiner} is a procedure of three arguments: a key,
a datum and the accumulated result so far.  Provided @var{combiner}
takes time bounded by a constant, @code{wt-tree/fold} takes time
proportional to the size of @var{wt-tree}.@refill

A sorted association list can be derived simply:@refill

@example
(wt-tree/fold  (lambda (key datum list)
                 (cons (cons key datum) list))
               '()
               @var{wt-tree}))
@end example

The data in the associations can be summed like this:@refill

@example
(wt-tree/fold  (lambda (key datum sum) (+ sum datum))
               0
               @var{wt-tree})
@end example
@end deffn

@deffn {procedure+} wt-tree/for-each action wt-tree
This procedure traverses the tree in-order, applying @var{action} to
each association.
The associations are processed in increasing order of their keys.
@var{Action} is a procedure of two arguments which take the key and
datum respectively of the association.
Provided @var{action} takes time bounded by a constant,
@code{wt-tree/for-each} takes time proportional to in the size of
@var{wt-tree}.
The example prints the tree:@refill

@example
(wt-tree/for-each (lambda (key value)
                    (display (list key value)))
                  @var{wt-tree}))
@end example
@end deffn


@node Indexing Operations on Weight-Balanced Trees,  , Advanced Operations on Weight-Balanced Trees, Weight-Balanced Trees
@subsection Indexing Operations on Weight-Balanced Trees

Weight balanced trees support operations that view the tree as sorted
sequence of associations.  Elements of the sequence can be accessed by
position, and the position of an element in the sequence can be
determined, both in logarthmic time.@refill

@deffn {procedure+} wt-tree/index wt-tree index
@deffnx {procedure+} wt-tree/index-datum wt-tree index
@deffnx {procedure+} wt-tree/index-pair wt-tree index
Returns the 0-based @var{index}th association of @var{wt-tree} in the
sorted sequence under the tree's ordering relation on the keys.
@code{wt-tree/index} returns the @var{index}th key,
@code{wt-tree/index-datum} returns the datum associated with the
@var{index}th key and @code{wt-tree/index-pair} returns a new pair
@code{(@var{key} . @var{datum})} which is the @code{cons} of the
@var{index}th key and its datum.  The average and worst-case times
required by this operation are proportional to the logarithm of the
number of associations in the tree.@refill

These operations signal an error if the tree is empty, if
@var{index}@code{<0}, or if @var{index} is greater than or equal to the
number of associations in the tree.@refill

Indexing can be used to find the median and maximum keys in the tree as
follows:@refill
@end deffn

@example
median:  (wt-tree/index @var{wt-tree} (quotient (wt-tree/size @var{wt-tree}) 2))

maximum: (wt-tree/index @var{wt-tree} (-1+ (wt-tree/size @var{wt-tree})))
@end example

@deffn {procedure+} wt-tree/rank wt-tree key
Determines the 0-based position of @var{key} in the sorted sequence of
the keys under the tree's ordering relation, or @code{#f} if the tree
has no association with for @var{key}.  This procedure returns either an
exact non-negative integer or @code{#f}.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in the tree.@refill
@end deffn

@deffn {procedure+} wt-tree/min wt-tree
@deffnx {procedure+} wt-tree/min-datum wt-tree
@deffnx {procedure+} wt-tree/min-pair wt-tree
Returns the association of @var{wt-tree} that has the least key under
the tree's ordering relation.  @code{wt-tree/min} returns the least key,
@code{wt-tree/min-datum} returns the datum associated with the least key
and @code{wt-tree/min-pair} returns a new pair @code{(key . datum)}
which is the @code{cons} of the minimum key and its datum.  The average
and worst-case times required by this operation are proportional to the
logarithm of the number of associations in the tree.@refill

These operations signal an error if the tree is empty.
They could be written@refill
@example
(define (wt-tree/min tree)        (wt-tree/index tree 0))
(define (wt-tree/min-datum tree)  (wt-tree/index-datum tree 0))
(define (wt-tree/min-pair tree)   (wt-tree/index-pair tree 0))
@end example
@end deffn

@deffn {procedure+} wt-tree/delete-min wt-tree
Returns a new tree containing all of the associations in @var{wt-tree}
except the association with the least key under the @var{wt-tree}'s
ordering relation.  An error is signalled if the tree is empty.  The
average and worst-case times required by this operation are proportional
to the logarithm of the number of associations in the tree.  This
operation is equivalent to@refill

@example
(wt-tree/delete @var{wt-tree} (wt-tree/min @var{wt-tree}))
@end example
@end deffn


@deffn {procedure+} wt-tree/delete-min! wt-tree
Removes the association with the least key under the @var{wt-tree}'s
ordering relation.  An error is signalled if the tree is empty.  The
average and worst-case times required by this operation are proportional
to the logarithm of the number of associations in the tree.  This
operation is equivalent to@refill

@example
(wt-tree/delete! @var{wt-tree} (wt-tree/min @var{wt-tree}))
@end example
@end deffn


@node Other Packages, About SLIB, Database Packages, Top
@chapter Other Packages

@menu
* Data Structures::             Various data structures.
* Sorting and Searching::       
* Procedures::                  Miscellaneous utility procedures.
* Standards Support::           Support for Scheme Standards.
* Session Support::             REPL and Debugging.
* System Interface::            'system, 'getenv, and other programs.
* Extra-SLIB Packages::         Outside the envelope.
@end menu


@node Data Structures, Sorting and Searching, Other Packages, Other Packages
@section Data Structures



@menu
* Arrays::                      'array
* Subarrays::                   'subarray
* Array Mapping::               'array-for-each
* Association Lists::           'alist
* Byte::                        'byte
* Byte/Number Conversions::     'byte-number
* MAT-File Format::             'matfile
* Portable Image Files::        'pnm
* Collections::                 'collect
* Dynamic Data Type::           'dynamic
* Hash Tables::                 'hash-table
* Object::                      'object
* Priority Queues::             'priority-queue
* Queues::                      'queue
* Records::                     'record
@end menu




@node Arrays, Subarrays, Data Structures, Data Structures
@subsection Arrays

@code{(require 'array)}@refill
@ftindex array


@defun array? obj

Returns @code{#t} if the @var{obj} is an array, and @code{#f} if not.@refill
@end defun
@noindent
@emph{Note:} Arrays are not disjoint from other Scheme types.  Strings
and vectors also satisfy @code{array?}.  A disjoint array predicate can
be written:@refill

@example
(define (strict-array? obj)
  (and (array? obj) (not (string? obj)) (not (vector? obj))))
@end example


@defun array=? array1 array2

Returns @code{#t} if @var{array1} and @var{array2} have the same rank and shape and the
corresponding elements of @var{array1} and @var{array2} are @code{equal?}.@refill

@example
(array=? (create-array '#(foo) 3 3)
         (create-array '#(foo) '(0 2) '(0 2)))
  @result{} #t
@end example
@end defun

@defun create-array prototype bound1 bound2 @dots{}


Creates and returns an array of type @var{prototype} with dimensions @var{bound1}, @var{bound2},
@dots{} and filled with elements from @var{prototype}.  @var{prototype} must be an array,
vector, or string.  The implementation-dependent type of the returned
array will be the same as the type of @var{prototype}; except if that would be a
vector or string with non-zero origin, in which case some variety of
array will be returned.@refill

If the @var{prototype} has no elements, then the initial contents of the returned
array are unspecified.  Otherwise, the returned array will be filled
with the element at the origin of @var{prototype}.@refill
@end defun
@noindent
These functions return a prototypical uniform-array enclosing the
optional argument (which must be of the correct type).  If the
uniform-array type is supported by the implementation, then it is
returned; defaulting to the next larger precision type; resorting
finally to vector.@refill


@defun ac64 z


@defunx ac64
Returns a high-precision complex uniform-array prototype.@refill
@end defun

@defun ac32 z


@defunx ac32
Returns a complex uniform-array prototype.@refill
@end defun

@defun ar64 x


@defunx ar64
Returns a high-precision real uniform-array prototype.@refill
@end defun

@defun ar32 x


@defunx ar32
Returns a real uniform-array prototype.@refill
@end defun

@defun as64 n


@defunx as64
Returns an exact signed integer uniform-array prototype with at least
64 bits of precision.@refill
@end defun

@defun as32 n


@defunx as32
Returns an exact signed integer uniform-array prototype with at least
32 bits of precision.@refill
@end defun

@defun as16 n


@defunx as16
Returns an exact signed integer uniform-array prototype with at least
16 bits of precision.@refill
@end defun

@defun as8 n


@defunx as8
Returns an exact signed integer uniform-array prototype with at least
8 bits of precision.@refill
@end defun

@defun au64 k


@defunx au64
Returns an exact non-negative integer uniform-array prototype with at
least 64 bits of precision.@refill
@end defun

@defun au32 k


@defunx au32
Returns an exact non-negative integer uniform-array prototype with at
least 32 bits of precision.@refill
@end defun

@defun au16 k


@defunx au16
Returns an exact non-negative integer uniform-array prototype with at
least 16 bits of precision.@refill
@end defun

@defun au8 k


@defunx au8
Returns an exact non-negative integer uniform-array prototype with at
least 8 bits of precision.@refill
@end defun

@defun at1 bool


@defunx at1
Returns a boolean uniform-array prototype.@refill
@end defun
@noindent
When constructing an array, @var{bound} is either an inclusive range of
indices expressed as a two element list, or an upper bound expressed as
a single integer.  So@refill

@example
(create-array '#(foo) 3 3) @equiv{} (create-array '#(foo) '(0 2) '(0 2))
@end example


@defun make-shared-array array mapper bound1 bound2 @dots{}

@code{make-shared-array} can be used to create shared subarrays of other
arrays.  The @var{mapper} is a function that translates coordinates in
the new array into coordinates in the old array.  A @var{mapper} must be
linear, and its range must stay within the bounds of the old array, but
it can be otherwise arbitrary.  A simple example:@refill

@example
(define fred (create-array '#(#f) 8 8))
(define freds-diagonal
  (make-shared-array fred (lambda (i) (list i i)) 8))
(array-set! freds-diagonal 'foo 3)
(array-ref fred 3 3)
   @result{} FOO
(define freds-center
  (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j)))
                     2 2))
(array-ref freds-center 0 0)
   @result{} FOO
@end example
@end defun

@defun array-rank obj

Returns the number of dimensions of @var{obj}.  If @var{obj} is not an array, 0 is
returned.@refill
@end defun

@defun array-shape array

Returns a list of inclusive bounds.@refill

@example
(array-shape (create-array '#() 3 5))
   @result{} ((0 2) (0 4))
@end example
@end defun

@defun array-dimensions array

@code{array-dimensions} is similar to @code{array-shape} but replaces
elements with a 0 minimum with one greater than the maximum.@refill

@example
(array-dimensions (create-array '#() 3 5))
   @result{} (3 5)
@end example
@end defun

@defun array-in-bounds? array index1 index2 @dots{}

Returns @code{#t} if its arguments would be acceptable to
@code{array-ref}.@refill
@end defun

@defun array-ref array index1 index2 @dots{}

Returns the (@var{index1}, @var{index2}, @dots{}) element of @var{array}.@refill
@end defun

@deffn {Procedure} array-set! array obj index1 index2 @dots{}

Stores @var{obj} in the (@var{index1}, @var{index2}, @dots{}) element of @var{array}.  The value returned
by @code{array-set!} is unspecified.@refill
@end deffn


@node Subarrays, Array Mapping, Arrays, Data Structures
@subsection Subarrays

@code{(require 'subarray)}@refill
@ftindex subarray


@defun subarray array select @dots{}

selects a subset of an array.  For @var{array} of rank n, there must be at least
n @var{selects} arguments.  For 0 <= @i{j} < n, @var{selects}@i{j} is either an integer, a
list of two integers within the range for the @i{j}th index, or #f.@refill

When @var{selects}@i{j} is a list of two integers, then the @i{j}th index is
restricted to that subrange in the returned array.@refill

When @var{selects}@i{j} is #f, then the full range of the @i{j}th index is
accessible in the returned array.  An elided argument is equivalent to #f.@refill

When @var{selects}@i{j} is an integer, then the rank of the returned array is
less than @var{array}, and only elements whose @i{j}th index equals @var{selects}@i{j} are
shared.@refill

@example
> (define ra '#2A((a b c) (d e f)))
#<unspecified>
> (subarray ra 0 #f)
#1A(a b c)
> (subarray ra 1 #f)
#1A(d e f)
> (subarray ra #f 1)
#1A(b e)
> (subarray ra '(0 1) #f)
#2A((a b c) (d e f))
> (subarray ra #f '(0 1))
#2A((a b) (d e))
> (subarray ra #f '(1 2))
#2A((b c) (e f))
@end example
@end defun

@defun subarray0 array select @dots{}

Behaves like @r{subarray}, but @r{align}s the returned array origin to
0 @dots{}.@refill
@end defun

@defun array-align array coord @dots{}


Returns an array shared with @var{array} but with a different origin.  The @var{coords}
are the exact integer coordinates of the new origin.  Indexes
corresponding to missing or #f coordinates are not realigned.@refill

For example:@refill
@example
(define ra2 (create-array '#(5) '(5 9) '(-4 0)))
(array-shape ra2)                       @result{} ((5 9) (-4 0))
(array-shape (array-align ra2 0 0))     @result{} ((0 4) (0 4))
(array-shape (array-align ra2 0))       @result{} ((0 4) (-4 0))
(array-shape (array-align ra2))         @result{} ((5 9) (-4 0))
(array-shape (array-align ra2 0 #f))    @result{} ((0 4) (-4 0))
(array-shape (array-align ra2 #f 0))    @result{} ((5 9) (0 4))
@end example
@end defun
  
@defun array-trim array trim @dots{}


Returns a subarray sharing contents with @var{array} except for slices removed
from either side of each dimension.  Each of the @var{trims} is an exact
integer indicating how much to trim.  A positive @var{s} trims the
data from the lower end and reduces the upper bound of the result; a
negative @var{s} trims from the upper end and increases the lower
bound.@refill

For example:@refill
@example
(array-trim '#(0 1 2 3 4) 1)  @result{} #1A(1 2 3 4) ;; shape is ((0 3))
(array-trim '#(0 1 2 3 4) -1) @result{} #1A(0 1 2 3) ;; shape is ((1 4))

(require 'array-for-each)
(define (centered-difference ra)
  (array-map - (array-trim ra 1) (array-trim ra -1)))
(define (forward-difference ra)
  (array-map - (array-trim ra 1) ra))
(define (backward-difference ra)
  (array-map - ra (array-trim ra -1)))

(centered-difference '#(0 1 3 5 9 22))
  @result{} #1A(3 4 6 17) ;;shape is ((1 4))
(backward-difference '#(0 1 3 5 9 22))
  @result{} #1A(1 2 2 4 13) ;; shape is ((1 5))
(forward-difference '#(0 1 3 5 9 22))
  @result{} #(1 2 2 4 13)  ;; shape is ((0 4))
@end example
@end defun


@node Array Mapping, Association Lists, Subarrays, Data Structures
@subsection Array Mapping

@code{(require 'array-for-each)}@refill
@ftindex array-for-each


@deffn {Procedure} array-map! array0 proc array1 @dots{}

@var{array1}, @dots{} must have the same number of dimensions as
@var{array0} and have a range for each index which includes the range
for the corresponding index in @var{array0}.  @var{proc} is applied to
each tuple of elements of @var{array1} @dots{} and the result is stored
as the corresponding element in @var{array0}.  The value returned is
unspecified.  The order of application is unspecified.@refill
@end deffn

@defun array-map prototype proc array1 array2 @dots{}

@var{array2}, @dots{} must have the same number of dimensions as
@var{array1} and have a range for each index which includes the
range for the corresponding index in @var{array1}.  @var{proc} is
applied to each tuple of elements of @var{array1}, @var{array2},
@dots{} and the result is stored as the corresponding element in a
new array of type @var{prototype}.  The new array is returned.  The
order of application is unspecified.@refill
@end defun

@defun array-for-each proc array0 @dots{}

@var{proc} is applied to each tuple of elements of @var{array0} @dots{}
in row-major order.  The value returned is unspecified.@refill
@end defun

@defun array-indexes array

Returns an array of lists of indexes for @var{array} such that, if
@var{li} is a list of indexes for which @var{array} is defined,
(equal?  @var{li} (apply array-ref (array-indexes @var{array})
@var{li})).@refill
@end defun

@deffn {Procedure} array-index-map! array proc

applies @var{proc} to the indices of each element of @var{array} in
turn, storing the result in the corresponding element.  The value
returned and the order of application are unspecified.@refill

One can implement @var{array-indexes} as@refill
@example
(define (array-indexes array)
    (let ((ra (apply create-array '#() (array-shape array))))
      (array-index-map! ra (lambda x x))
      ra))
@end example
Another example:@refill
@example
(define (apl:index-generator n)
    (let ((v (make-vector n 1)))
      (array-index-map! v (lambda (i) i))
      v))
@end example
@end deffn

@deffn {Procedure} array-copy! source destination

Copies every element from vector or array @var{source} to the
corresponding element of @var{destination}.  @var{destination} must
have the same rank as @var{source}, and be at least as large in each
dimension.  The order of copying is unspecified.@refill
@end deffn


@node Association Lists, Byte, Array Mapping, Data Structures
@subsection Association Lists

@code{(require 'alist)}@refill
@ftindex alist

Alist functions provide utilities for treating a list of key-value pairs
as an associative database.  These functions take an equality predicate,
@var{pred}, as an argument.  This predicate should be repeatable,
symmetric, and transitive.@refill

Alist functions can be used with a secondary index method such as hash
tables for improved performance.@refill


@defun predicate->asso pred

Returns an @dfn{association function} (like @code{assq}, @code{assv}, or@refill
@cindex association function
@code{assoc}) corresponding to @var{pred}.  The returned function
returns a key-value pair whose key is @code{pred}-equal to its first
argument or @code{#f} if no key in the alist is @var{pred}-equal to the
first argument.@refill
@end defun

@defun alist-inquirer pred

Returns a procedure of 2 arguments, @var{alist} and @var{key}, which
returns the value associated with @var{key} in @var{alist} or @code{#f} if
@var{key} does not appear in @var{alist}.@refill
@end defun

@defun alist-associator pred

Returns a procedure of 3 arguments, @var{alist}, @var{key}, and
@var{value}, which returns an alist with @var{key} and @var{value}
associated.  Any previous value associated with @var{key} will be
lost.  This returned procedure may or may not have side effects on its
@var{alist} argument.  An example of correct usage is:@refill

@lisp
(define put (alist-associator string-ci=?))
(define alist '())
(set! alist (put alist "Foo" 9))
@end lisp
@end defun

@defun alist-remover pred

Returns a procedure of 2 arguments, @var{alist} and @var{key}, which
returns an alist with an association whose @var{key} is key removed.
This returned procedure may or may not have side effects on its
@var{alist} argument.  An example of correct usage is:@refill

@lisp
(define rem (alist-remover string-ci=?))
(set! alist (rem alist "foo"))
@end lisp
@end defun

@defun alist-map proc alist

Returns a new association list formed by mapping @var{proc} over the
keys and values of @var{alist}.   @var{proc} must be a function of 2
arguments which returns the new value part.@refill
@end defun

@defun alist-for-each proc alist

Applies @var{proc} to each pair of keys and values of @var{alist}.
@var{proc} must be a function of 2 arguments.  The returned value is
unspecified.@refill
@end defun


@node Byte, Byte/Number Conversions, Association Lists, Data Structures
@subsection Byte

@code{(require 'byte)}@refill
@ftindex byte

@noindent
Some algorithms are expressed in terms of arrays of small integers.
Using Scheme strings to implement these arrays is not portable vis-a-vis
the correspondence between integers and characters and non-ascii
character sets.  These functions abstract the notion of a @dfn{byte}.@refill
@cindex byte
@cindex byte


@defun byte-ref bytes k

@var{k} must be a valid index of @var{bytes}.  @code{byte-ref} returns byte @var{k} of @var{bytes} using
zero-origin indexing.@refill
@end defun

@deffn {Procedure} byte-set! bytes k byte

@var{k} must be a valid index of @var{bytes}, and @var{byte} must be a small
nonnegative integer.  @code{byte-set!} stores @var{byte} in element @var{k} of @var{bytes} and
returns an unspecified value.  @refill@c <!>
@end deffn

@defun make-bytes k byte


@defunx make-bytes k
@code{make-bytes} returns a newly allocated byte-array of length @var{k}.  If @var{byte} is
given, then all elements of the byte-array are initialized to @var{byte},
otherwise the contents of the byte-array are unspecified.@refill
@end defun

@defun bytes-length bytes

@code{bytes-length} returns length of byte-array @var{bytes}.@refill
@end defun

@defun bytes byte @dots{}

Returns a newly allocated byte-array composed of the small
nonnegative arguments.@refill
@end defun

@defun bytes->list bytes

@code{bytes->list} returns a newly allocated list of the bytes that make up the
given byte-array.@refill
@end defun

@defun list->bytes bytes

@code{list->bytes} returns a newly allocated byte-array formed from the small
nonnegative integers in the list @var{bytes}.@refill
@end defun
@noindent
@code{Bytes->list} and @code{list->bytes} are inverses so far as
@code{equal?} is concerned.@refill
@findex equal?


@defun bytes-copy bytes

Returns a newly allocated copy of the given @var{bytes}.@refill
@end defun

@deffn {Procedure} bytes-reverse! bytes

Reverses the order of byte-array @var{bytes}.@refill
@end deffn

@defun bytes-reverse bytes

Returns a newly allocated bytes-array consisting of the elements of
@var{bytes} in reverse order.@refill
@end defun
@noindent
@cindex binary
Input and output of bytes should be with ports opened in @dfn{binary}@refill
@cindex binary
mode (@pxref{Input/Output}).  Calling @code{open-file} with @r{'rb} or@refill
@findex open-file
@r{'wb} modes argument will return a binary port if the Scheme
implementation supports it.@refill


@defun write-byte byte port


@defunx write-byte byte
Writes the byte @var{byte} (not an external representation of the byte) to
the given @var{port} and returns an unspecified value.  The @var{port} argument may
be omitted, in which case it defaults to the value returned by
@code{current-output-port}.@refill
@findex current-output-port
@end defun

@defun read-byte port


@defunx read-byte
Returns the next byte available from the input @var{port}, updating the @var{port}
to point to the following byte.  If no more bytes are available, an
end-of-file object is returned.  @var{port} may be omitted, in which case it
defaults to the value returned by @code{current-input-port}.@refill
@findex current-input-port
@end defun
@noindent
When reading and writing binary numbers with @code{read-bytes} and
@code{write-bytes}, the sign of the length argument determines the
endianness (order) of bytes.  Positive treats them as big-endian,
the first byte input or output is highest order.  Negative treats
them as little-endian, the first byte input or output is the lowest
order.@refill

@noindent
Once read in, SLIB treats byte sequences as big-endian.  The
multi-byte sequences produced and used by number conversion routines
@pxref{Byte/Number Conversions} are always big-endian.@refill


@defun read-bytes n port


@defunx read-bytes n
@code{read-bytes} returns a newly allocated bytes-array filled with
@code{(abs @var{n})} bytes read from @var{port}.  If @var{n} is positive, then
the first byte read is stored at index 0; otherwise the last byte
read is stored at index 0.  Note that the length of the returned
string will be less than @code{(abs @var{n})} if @var{port} reaches
end-of-file.@refill

@var{port} may be omitted, in which case it defaults to the value returned
by @code{current-input-port}.@refill
@end defun

@defun write-bytes bytes n port


@defunx write-bytes bytes n
@code{write-bytes} writes @code{(abs @var{n})} bytes to output-port @var{port}.  If @var{n} is
positive, then the first byte written is index 0 of @var{bytes}; otherwise
the last byte written is index 0 of @var{bytes}.  @code{write-bytes} returns an unspecified
value.@refill

@var{port} may be omitted, in which case it defaults to the value returned
by @code{current-output-port}.@refill
@end defun
@noindent
@code{substring-read!} and @code{substring-write} provide
lower-level procedures for reading and writing blocks of bytes.  The
relative size of @var{start} and @var{end} determines the order of
writing.@refill


@deffn {Procedure} substring-read! string start end port


@deffnx {Procedure} substring-read! string start end
Fills @var{string} with up to @code{(abs (- @var{start} @var{end}))} bytes
read from @var{port}.  The first byte read is stored at index @var{string}.
@code{substring-read!} returns the number of bytes read.@refill

@var{port} may be omitted, in which case it defaults to the value returned
by @code{current-input-port}.@refill
@end deffn

@defun substring-write string start end port


@defunx substring-write string start end
@code{substring-write} writes @code{(abs (- @var{start} @var{end}))} bytes to
output-port @var{port}.  The first byte written is index @var{start} of @var{string}.  @code{substring-write}
returns the number of bytes written.@refill

@var{port} may be omitted, in which case it defaults to the value returned
by @code{current-output-port}.@refill
@end defun


@node Byte/Number Conversions, MAT-File Format, Byte, Data Structures
@subsection Byte/Number Conversions

@code{(require 'byte-number)}@refill
@ftindex byte-number

@noindent
The multi-byte sequences produced and used by numeric conversion
routines are always big-endian.  Endianness can be changed during
reading and writing bytes using @code{read-bytes} and
@code{write-bytes} @xref{Byte, read-bytes}.@refill

@noindent
The sign of the length argument to bytes/integer conversion
procedures determines the signedness of the number.@refill


@defun bytes->integer bytes n

Converts the first @code{(abs @var{n})} bytes of big-endian @var{bytes} array
to an integer.  If @var{n} is negative then the integer coded by the
bytes are treated as two's-complement (can be negative).@refill

@example
(bytes->integer (bytes   0   0   0  15) -4)   @result{}          15
(bytes->integer (bytes   0   0   0  15)  4)   @result{}          15
(bytes->integer (bytes 255 255 255 255) -4)   @result{}          -1
(bytes->integer (bytes 255 255 255 255)  4)   @result{}  4294967295
(bytes->integer (bytes 128   0   0   0) -4)   @result{} -2147483648
(bytes->integer (bytes 128   0   0   0)  4)   @result{}  2147483648
@end example
@end defun

@defun integer->bytes n len

Converts the integer @var{n} to a byte-array of @code{(abs @var{n})}
bytes.  If @var{n} and @var{len} are both negative, then the bytes in the
returned array are coded two's-complement.@refill

@example
(bytes->list (integer->bytes          15 -4))   @result{} (0 0 0 15)
(bytes->list (integer->bytes          15  4))   @result{} (0 0 0 15)
(bytes->list (integer->bytes          -1 -4))   @result{} (255 255 255 255)
(bytes->list (integer->bytes  4294967295  4))   @result{} (255 255 255 255)
(bytes->list (integer->bytes -2147483648 -4))   @result{} (128 0 0 0)
(bytes->list (integer->bytes  2147483648  4))   @result{} (128 0 0 0)
@end example
@end defun

@defun bytes->ieee-float bytes

@var{bytes} must be a 4-element byte-array.  @code{bytes->ieee-float} calculates and returns the
value of @var{bytes} interpreted as a big-endian IEEE 4-byte (32-bit) number.@refill
@end defun
@example
(bytes->ieee-float (bytes #x40    0 0 0))  @result{}  2.0
(bytes->ieee-float (bytes #x40 #xd0 0 0))  @result{}  6.5
(bytes->ieee-float (bytes #xc0 #xd0 0 0))  @result{} -6.5

(bytes->ieee-float (bytes    0 #x80 0 0))  @result{} 11.754943508222875e-39
(bytes->ieee-float (bytes    0 #x40 0 0))  @result{}  5.877471754111437e-39
(bytes->ieee-float (bytes    0    0 0 1))  @result{}  1.401298464324817e-45

(bytes->ieee-float (bytes #xff #x80 0 0))  @result{} -1/0
(bytes->ieee-float (bytes #x7f #x80 0 0))  @result{}  1/0
(bytes->ieee-float (bytes #x7f #x80 0 1))  @result{}  0/0
@end example


@defun bytes->ieee-double bytes

@var{bytes} must be a 8-element byte-array.  @code{bytes->ieee-double} calculates and returns the
value of @var{bytes} interpreted as a big-endian IEEE 8-byte (64-bit) number.@refill
@end defun
@example
(bytes->ieee-double (bytes    0    0 0 0 0 0 0 0))  @result{}  0.0
(bytes->ieee-double (bytes #x40    0 0 0 0 0 0 0))  @result{}  2
(bytes->ieee-double (bytes #x40 #x1A 0 0 0 0 0 0))  @result{}  6.5
(bytes->ieee-double (bytes #xC0 #x1A 0 0 0 0 0 0))  @result{} -6.5

(bytes->ieee-double (bytes 0 8 0 0 0 0 0 0)) @result{} 11.125369292536006e-309
(bytes->ieee-double (bytes 0 4 0 0 0 0 0 0)) @result{}  5.562684646268003e-309
(bytes->ieee-double (bytes 0 0 0 0 0 0 0 1)) @result{}  4.0e-324

(bytes->ieee-double (bytes #xFF #xF0 0 0 0 0 0 0))  @result{} -1/0
(bytes->ieee-double (bytes #x7F #xF0 0 0 0 0 0 0))  @result{}  1/0
(bytes->ieee-double (bytes #x7F #xF8 0 0 0 0 0 0))  @result{}  0/0
@end example


@defun ieee-float->bytes x

Returns a 4-element byte-array encoding the IEEE single-precision
floating-point of @var{x}.@refill
@end defun
@example
(bytes->list (ieee-float->bytes  2.0))                    @result{} (64    0 0 0)
(bytes->list (ieee-float->bytes  6.5))                    @result{} (64  208 0 0)
(bytes->list (ieee-float->bytes -6.5))                    @result{} (192 208 0 0)

(bytes->list (ieee-float->bytes 11.754943508222875e-39))  @result{} (  0 128 0 0)
(bytes->list (ieee-float->bytes  5.877471754111438e-39))  @result{} (  0  64 0 0)
(bytes->list (ieee-float->bytes  1.401298464324817e-45))  @result{} (  0   0 0 1)

(bytes->list (ieee-float->bytes -1/0))                    @result{} (255 128 0 0)
(bytes->list (ieee-float->bytes  1/0))                    @result{} (127 128 0 0)
(bytes->list (ieee-float->bytes  0/0))                    @result{} (127 128 0 1)
@end example


@defun ieee-double->bytes x

Returns a 8-element byte-array encoding the IEEE double-precision
floating-point of @var{x}.@refill
@end defun
@example
(bytes->list (ieee-double->bytes  2.0)) @result{} (64    0 0 0 0 0 0 0)
(bytes->list (ieee-double->bytes  6.5)) @result{} (64   26 0 0 0 0 0 0)
(bytes->list (ieee-double->bytes -6.5)) @result{} (192  26 0 0 0 0 0 0)

(bytes->list (ieee-double->bytes 11.125369292536006e-309))
                                        @result{} (  0   8 0 0 0 0 0 0)
(bytes->list (ieee-double->bytes  5.562684646268003e-309))
                                        @result{} (  0   4 0 0 0 0 0 0)
(bytes->list (ieee-double->bytes  4.0e-324))
                                        @result{} (  0   0 0 0 0 0 0 1)

(bytes->list (ieee-double->bytes -1/0)) @result{} (255 240 0 0 0 0 0 0)
(bytes->list (ieee-double->bytes  1/0)) @result{} (127 240 0 0 0 0 0 0)
(bytes->list (ieee-double->bytes  0/0)) @result{} (127 248 0 0 0 0 0 0)
@end example

@subsubheading Byte Collation Order

@noindent
The @code{string<?} ordering of big-endian byte-array
representations of fixed and IEEE floating-point numbers agrees with
the numerical ordering only when those numbers are non-negative.@refill

@noindent
Straighforward modification of these formats can extend the
byte-collating order to work for their entire ranges.  This
agreement enables the full range of numbers as keys in
@dfn{indexed-sequential-access-method} databases.@refill
@cindex indexed-sequential-access-method


@deffn {Procedure} integer-byte-collate! byte-vector

Modifies sign bit of @var{byte-vector} so that @code{string<?} ordering of
two's-complement byte-vectors matches numerical order.  @code{integer-byte-collate!} returns
@var{byte-vector} and is its own functional inverse.@refill
@end deffn

@defun integer-byte-collate byte-vector

Returns copy of @var{byte-vector} with sign bit modified so that @code{string<?}
ordering of two's-complement byte-vectors matches numerical order.
@code{integer-byte-collate} is its own functional inverse.@refill
@end defun

@deffn {Procedure} ieee-byte-collate! byte-vector

Modifies @var{byte-vector} so that @code{string<?} ordering of IEEE floating-point
byte-vectors matches numerical order.  @code{ieee-byte-collate!} returns @var{byte-vector}.@refill
@end deffn

@deffn {Procedure} ieee-byte-decollate! byte-vector

Given @var{byte-vector} modified by @code{IEEE-byte-collate!}, reverses the @var{byte-vector}
modifications.@refill
@end deffn

@defun ieee-byte-collate byte-vector

Returns copy of @var{byte-vector} encoded so that @code{string<?} ordering of IEEE
floating-point byte-vectors matches numerical order.@refill
@end defun

@defun ieee-byte-decollate byte-vector

Given @var{byte-vector} returned by @code{IEEE-byte-collate}, reverses the @var{byte-vector}
modifications.@refill
@end defun


@node MAT-File Format, Portable Image Files, Byte/Number Conversions, Data Structures
@subsection MAT-File Format

@code{(require 'matfile)}@refill
@ftindex matfile
@ftindex matlab

@uref{http://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf}

@noindent
This package reads MAT-File Format version 4 (MATLAB) binary data
files.  MAT-files written from big-endian or little-endian computers
having IEEE format numbers are currently supported.  Support for files
written from VAX or Cray machines could also be added.@refill

@noindent
The numeric and text matrix types handled; support for @dfn{sparse}@refill
@cindex sparse
matrices awaits a sample file.@refill


@defun matfile:read filename
@var{filename} should be a string naming an existing file containing a
MATLAB Version 4 MAT-File.  The @code{matfile:read} procedure reads matrices from the
file and returns a list of the results; a list of the name string and
array for each matrix.@refill
@end defun

@defun matfile:load filename
@var{filename} should be a string naming an existing file containing a
MATLAB Version 4 MAT-File.  The @code{matfile:load} procedure reads matrices from the
file and defines the @code{string-ci->symbol} for each matrix to its
corresponding array.  @code{matfile:load} returns a list of the symbols defined.@refill
@end defun


@node Portable Image Files, Collections, MAT-File Format, Data Structures
@subsection Portable Image Files

@code{(require 'pnm)}@refill
@ftindex pnm


@defun pnm:type-dimensions path

The string @var{path} must name a @dfn{portable bitmap graphics} file.@refill
@cindex portable bitmap graphics
@code{pnm:type-dimensions} returns a list of 4 items:@refill
@enumerate
@item
A symbol describing the type of the file named by @var{path}.@refill
@item
The image width in pixels.@refill
@item
The image height in pixels.@refill
@item
The maximum value of pixels assume in the file.@refill
@end enumerate

The current set of file-type symbols is:@refill
@table @asis
@item pbm
@itemx pbm-raw
@cindex pbm
@cindex pbm-raw
Black-and-White image; pixel values are 0 or 1.@refill
@item pgm
@itemx pgm-raw
@cindex pgm
@cindex pgm-raw
Gray (monochrome) image; pixel values are from 0 to @var{maxval}
specified in file header.@refill
@item ppm
@itemx ppm-raw
@cindex ppm
@cindex ppm-raw
RGB (full color) image; red, green, and blue interleaved pixel values
are from 0 to @var{maxval}@refill
@end table
@end defun

@defun pnm:image-file->array path array


Reads the @dfn{portable bitmap graphics} file named by @var{path} into@refill
@cindex portable bitmap graphics
@var{array}.  @var{array} must be the correct size and type for
@var{path}.  @var{array} is returned.@refill


@defunx pnm:image-file->array path

@code{pnm:image-file->array} creates and returns an array with the
@dfn{portable bitmap graphics} file named by @var{path} read into it.@refill
@cindex portable bitmap graphics
@end defun

@defun pnm:array-write type array maxval path comment @dots{}


Writes the contents of @var{array} to a @var{type} image file named @var{path}.  The file
will have pixel values between 0 and @var{maxval}, which must be compatible
with @var{type}.  For @samp{pbm} files, @var{maxval} must be @samp{1}.
@var{comment}s are included in the file header.@refill
@end defun


@node Collections, Dynamic Data Type, Portable Image Files, Data Structures
@subsection Collections

@c Much of the documentation in this section was written by Dave Love
@c (d.love@dl.ac.uk) -- don't blame Ken Dickey for its faults.
@c but we can blame him for not writing it!

@code{(require 'collect)}@refill
@ftindex collect

@noindent
Routines for managing collections.  Collections are aggregate data
structures supporting iteration over their elements, similar to the
Dylan(TM) language, but with a different interface.  They have
@dfn{elements} indexed by corresponding @dfn{keys}, although the keys
may be implicit (as with lists).@refill

@noindent
New types of collections may be defined as YASOS objects (@pxref{Yasos}).
They must support the following operations:@refill

@itemize @bullet
@item
@code{(collection? @var{self})} (always returns @code{#t});@refill

@item
@code{(size @var{self})} returns the number of elements in the collection;@refill

@item
@code{(print @var{self} @var{port})} is a specialized print operation
for the collection which prints a suitable representation on the given
@var{port} or returns it as a string if @var{port} is @code{#t};@refill

@item
@findex gen-elts
@code{(gen-elts @var{self})} returns a thunk which on successive
invocations yields elements of @var{self} in order or gives an error if
it is invoked more than @code{(size @var{self})} times;@refill

@item
@findex gen-keys
@code{(gen-keys @var{self})} is like @code{gen-elts}, but yields the
collection's keys in order.@refill
@end itemize

@noindent
They might support specialized @code{for-each-key} and
@code{for-each-elt} operations.@refill



@defun collection? obj
A predicate, true initially of lists, vectors and strings.  New sorts of
collections must answer @code{#t} to @code{collection?}.@refill
@end defun

@deffn {Procedure} map-elts proc collection1 @dots{}
@deffnx {Procedure} do-elts proc collection1 @dots{}
@var{proc} is a procedure taking as many arguments as there are
@var{collections} (at least one).  The @var{collections} are iterated
over in their natural order and @var{proc} is applied to the elements
yielded by each iteration in turn.  The order in which the arguments are
supplied corresponds to te order in which the @var{collections} appear.
@code{do-elts} is used when only side-effects of @var{proc} are of
interest and its return value is unspecified.  @code{map-elts} returns a
collection (actually a vector) of the results of the applications of
@var{proc}.@refill

Example:@refill
@lisp
(map-elts + (list 1 2 3) (vector 1 2 3))
   @result{} #(2 4 6)
@end lisp
@end deffn

@deffn {Procedure} map-keys proc collection1 @dots{}
@deffnx {Procedure} do-keys proc collection1 @dots{}
These are analogous to @code{map-elts} and @code{do-elts}, but each
iteration is over the @var{collections}' @emph{keys} rather than their
elements.@refill

Example:@refill
@lisp
(map-keys + (list 1 2 3) (vector 1 2 3))
   @result{} #(0 2 4)
@end lisp
@end deffn

@deffn {Procedure} for-each-key collection proc
@deffnx {Procedure} for-each-elt collection proc
These are like @code{do-keys} and @code{do-elts} but only for a single
collection; they are potentially more efficient.@refill
@end deffn

@defun reduce proc seed collection1 @dots{}
A generalization of the list-based @code{reduce-init}
(@pxref{Lists as sequences}) to collections which will shadow the
list-based version if @code{(require 'collect)} follows@refill
@ftindex collect
@code{(require 'common-list-functions)} (@pxref{Common List
Functions}).@refill
@ftindex common-list-functions

Examples:@refill
@lisp
(reduce + 0 (vector 1 2 3))
   @result{} 6
(reduce union '() '((a b c) (b c d) (d a)))
   @result{} (c b d a).
@end lisp
@end defun

@defun any? pred collection1 @dots{}
A generalization of the list-based @code{some} (@pxref{Lists as
sequences}) to collections.@refill

Example:@refill
@lisp
(any? odd? (list 2 3 4 5))
   @result{} #t
@end lisp
@end defun

@defun every? pred collection1 @dots{}
A generalization of the list-based @code{every}
(@pxref{Lists as sequences}) to collections.@refill

Example:@refill
@lisp
(every? collection? '((1 2) #(1 2)))
   @result{} #t
@end lisp
@end defun

@defun empty? collection
Returns @code{#t} iff there are no elements in @var{collection}.@refill

@code{(empty? @var{collection}) @equiv{} (zero? (size @var{collection}))}@refill
@end defun

@defun size collection
Returns the number of elements in @var{collection}.@refill
@end defun

@defun Setter list-ref
See @ref{Setters} for a definition of @dfn{setter}.  N.B.
@code{(setter list-ref)} doesn't work properly for element 0 of a
list.@refill
@end defun

Here is a sample collection: @code{simple-table} which is also a
@code{table}.@refill
@lisp
(define-predicate TABLE?)
(define-operation (LOOKUP table key failure-object))
(define-operation (ASSOCIATE! table key value)) ;; returns key
(define-operation (REMOVE! table key))          ;; returns value

(define (MAKE-SIMPLE-TABLE)
  (let ( (table (list)) )
    (object
     ;; table behaviors
     ((TABLE? self) #t)
     ((SIZE self) (size table))
     ((PRINT self port) (format port "#<SIMPLE-TABLE>"))
     ((LOOKUP self key failure-object)
      (cond
       ((assq key table) => cdr)
       (else failure-object)
       ))
     ((ASSOCIATE! self key value)
      (cond
       ((assq key table)
        => (lambda (bucket) (set-cdr! bucket value) key))
       (else
        (set! table (cons (cons key value) table))
        key)
       ))
     ((REMOVE! self key);; returns old value
      (cond
       ((null? table) (slib:error "TABLE:REMOVE! Key not found: " key))
       ((eq? key (caar table))
        (let ( (value (cdar table)) )
          (set! table (cdr table))
          value)
        )
       (else
        (let loop ( (last table) (this (cdr table)) )
          (cond
           ((null? this)
            (slib:error "TABLE:REMOVE! Key not found: " key))
           ((eq? key (caar this))
            (let ( (value (cdar this)) )
              (set-cdr! last (cdr this))
              value)
            )
           (else
            (loop (cdr last) (cdr this)))
           ) ) )
       ))
@group
     ;; collection behaviors
     ((COLLECTION? self) #t)
     ((GEN-KEYS self) (collect:list-gen-elts (map car table)))
     ((GEN-ELTS self) (collect:list-gen-elts (map cdr table)))
     ((FOR-EACH-KEY self proc)
      (for-each (lambda (bucket) (proc (car bucket))) table)
      )
     ((FOR-EACH-ELT self proc)
      (for-each (lambda (bucket) (proc (cdr bucket))) table)
      ) ) ) )
@end group
@end lisp





@node Dynamic Data Type, Hash Tables, Collections, Data Structures
@subsection Dynamic Data Type

@code{(require 'dynamic)}@refill
@ftindex dynamic

@defun make-dynamic obj
Create and returns a new @dfn{dynamic} whose global value is @var{obj}.@refill
@end defun

@defun dynamic? obj
Returns true if and only if @var{obj} is a dynamic.  No object
satisfying @code{dynamic?} satisfies any of the other standard type
predicates.@refill
@end defun

@defun dynamic-ref dyn
Return the value of the given dynamic in the current dynamic
environment.@refill
@end defun

@deffn {Procedure} dynamic-set! dyn obj
Change the value of the given dynamic to @var{obj} in the current
dynamic environment.  The returned value is unspecified.@refill
@end deffn

@defun call-with-dynamic-binding dyn obj thunk
Invoke and return the value of the given thunk in a new, nested dynamic
environment in which the given dynamic has been bound to a new location
whose initial contents are the value @var{obj}.  This dynamic
environment has precisely the same extent as the invocation of the thunk
and is thus captured by continuations created within that invocation and
re-established by those continuations when they are invoked.@refill
@end defun

The @code{dynamic-bind} macro is not implemented.@refill




@node Hash Tables, Object, Dynamic Data Type, Data Structures
@subsection Hash Tables

@code{(require 'hash-table)}@refill
@ftindex hash-table


@defun predicate->hash pred

Returns a hash function (like @code{hashq}, @code{hashv}, or
@code{hash}) corresponding to the equality predicate @var{pred}.
@var{pred} should be @code{eq?}, @code{eqv?}, @code{equal?}, @code{=},
@code{char=?}, @code{char-ci=?}, @code{string=?}, or
@code{string-ci=?}.@refill
@end defun
@noindent
A hash table is a vector of association lists.@refill


@defun make-hash-table k

Returns a vector of @var{k} empty (association) lists.@refill
@end defun
@noindent
Hash table functions provide utilities for an associative database.
These functions take an equality predicate, @var{pred}, as an argument.
@var{pred} should be @code{eq?}, @code{eqv?}, @code{equal?}, @code{=},
@code{char=?}, @code{char-ci=?}, @code{string=?}, or
@code{string-ci=?}.@refill


@defun predicate->hash-asso pred

Returns a hash association function of 2 arguments, @var{key} and
@var{hashtab}, corresponding to @var{pred}.  The returned function
returns a key-value pair whose key is @var{pred}-equal to its first
argument or @code{#f} if no key in @var{hashtab} is @var{pred}-equal to
the first argument.@refill
@end defun

@defun hash-inquirer pred

Returns a procedure of 2 arguments, @var{hashtab} and @var{key}, which
returns the value associated with @var{key} in @var{hashtab} or
@code{#f} if @var{key} does not appear in @var{hashtab}.@refill
@end defun

@defun hash-associator pred

Returns a procedure of 3 arguments, @var{hashtab}, @var{key}, and
@var{value}, which modifies @var{hashtab} so that @var{key} and
@var{value} associated.  Any previous value associated with @var{key}
will be lost.@refill
@end defun

@defun hash-remover pred

Returns a procedure of 2 arguments, @var{hashtab} and @var{key}, which
modifies @var{hashtab} so that the association whose key is @var{key} is
removed.@refill
@end defun

@defun hash-map proc hash-table

Returns a new hash table formed by mapping @var{proc} over the
keys and values of @var{hash-table}.  @var{proc} must be a function of 2
arguments which returns the new value part.@refill
@end defun

@defun hash-for-each proc hash-table

Applies @var{proc} to each pair of keys and values of @var{hash-table}.
@var{proc} must be a function of 2 arguments.  The returned value is
unspecified.@refill
@end defun

@defun hash-rehasher pred

@code{hash-rehasher} accepts a hash table predicate and returns a function of two
arguments @var{hashtab} and @var{new-k} which is specialized for
that predicate.@refill

This function is used for nondestrutively resizing a hash table.
@var{hashtab} should be an existing hash-table using @var{pred}, @var{new-k}
is the size of a new hash table to be returned.  The new hash table
will have all of the associations of the old hash table.@refill
@end defun



@node Object, Priority Queues, Hash Tables, Data Structures
@subsection Macroless Object System


@code{(require 'object)}@refill
@ftindex object

This is the Macroless Object System written by Wade Humeniuk
(whumeniu@@datap.ca).  Conceptual Tributes: @ref{Yasos}, MacScheme's
%object, CLOS, Lack of R4RS macros.@refill

@subsection Concepts
@table @asis

@item OBJECT
An object is an ordered association-list (by @code{eq?}) of methods
(procedures).  Methods can be added (@code{make-method!}), deleted
(@code{unmake-method!}) and retrieved (@code{get-method}).  Objects may
inherit methods from other objects.  The object binds to the environment
it was created in, allowing closures to be used to hide private
procedures and data.@refill

@item GENERIC-METHOD
A generic-method associates (in terms of @code{eq?}) object's method.
This allows scheme function style to be used for objects.  The calling
scheme for using a generic method is @code{(generic-method object param1
param2 ...)}.@refill

@item METHOD
A method is a procedure that exists in the object.  To use a method
get-method must be called to look-up the method.  Generic methods
implement the get-method functionality.  Methods may be added to an
object associated with any scheme obj in terms of eq?@refill

@item GENERIC-PREDICATE
A generic method that returns a boolean value for any scheme obj.@refill

@item PREDICATE
A object's method asscociated with a generic-predicate. Returns
@code{#t}.@refill
@end table

@subsection Procedures

@defun make-object ancestor @dots{}
Returns an object.  Current object implementation is a tagged vector.
@var{ancestor}s are optional and must be objects in terms of object?.
@var{ancestor}s methods are included in the object.  Multiple
@var{ancestor}s might associate the same generic-method with a method.
In this case the method of the @var{ancestor} first appearing in the
list is the one returned by @code{get-method}.@refill
@end defun

@defun object? obj
Returns boolean value whether @var{obj} was created by make-object.@refill
@end defun

@defun make-generic-method exception-procedure
Returns a procedure which be associated with an object's methods.  If
@var{exception-procedure} is specified then it is used to process
non-objects.@refill
@end defun

@defun make-generic-predicate
Returns a boolean procedure for any scheme object.@refill
@end defun

@defun make-method! object generic-method method
Associates @var{method} to the @var{generic-method} in the object.  The
@var{method} overrides any previous association with the
@var{generic-method} within the object.  Using @code{unmake-method!}
will restore the object's previous association with the
@var{generic-method}.  @var{method} must be a procedure.@refill
@end defun

@defun make-predicate! object generic-preciate
Makes a predicate method associated with the @var{generic-predicate}.@refill
@end defun

@defun unmake-method! object generic-method
Removes an object's association with a @var{generic-method} .@refill
@end defun

@defun get-method object generic-method
Returns the object's method associated (if any) with the
@var{generic-method}.  If no associated method exists an error is
flagged.@refill
@end defun

@subsection Examples

@example
(require 'object)
@ftindex object

(define instantiate (make-generic-method))

(define (make-instance-object . ancestors)
  (define self (apply make-object
                      (map (lambda (obj) (instantiate obj)) ancestors)))
  (make-method! self instantiate (lambda (self) self))
  self)

(define who (make-generic-method))
(define imigrate! (make-generic-method))
(define emigrate! (make-generic-method))
(define describe (make-generic-method))
(define name (make-generic-method))
(define address (make-generic-method))
(define members (make-generic-method))

(define society
  (let ()
    (define self (make-instance-object))
    (define population '())
    (make-method! self imigrate!
                  (lambda (new-person)
                    (if (not (eq? new-person self))
                        (set! population (cons new-person population)))))
    (make-method! self emigrate!
                  (lambda (person)
                    (if (not (eq? person self))
                        (set! population
                              (comlist:remove-if (lambda (member)
                                                   (eq? member person))
                                                 population)))))
    (make-method! self describe
                  (lambda (self)
                    (map (lambda (person) (describe person)) population)))
    (make-method! self who
                  (lambda (self) (map (lambda (person) (name person))
                                      population)))
    (make-method! self members (lambda (self) population))
    self))

(define (make-person %name %address)
  (define self (make-instance-object society))
  (make-method! self name (lambda (self) %name))
  (make-method! self address (lambda (self) %address))
  (make-method! self who (lambda (self) (name self)))
  (make-method! self instantiate
                (lambda (self)
                  (make-person (string-append (name self) "-son-of")
                               %address)))
  (make-method! self describe
                (lambda (self) (list (name self) (address self))))
  (imigrate! self)
  self)
@end example

@subsubsection Inverter Documentation
Inheritance:@refill
@lisp
        <inverter>::(<number> <description>)
@end lisp
Generic-methods@refill
@lisp
        <inverter>::value      @result{} <number>::value
        <inverter>::set-value! @result{} <number>::set-value!
        <inverter>::describe   @result{} <description>::describe
        <inverter>::help
        <inverter>::invert
        <inverter>::inverter?
@end lisp

@subsubsection Number Documention
Inheritance@refill
@lisp
        <number>::()
@end lisp
Slots@refill
@lisp
        <number>::<x>
@end lisp
Generic Methods@refill
@lisp
        <number>::value
        <number>::set-value!
@end lisp

@subsubsection Inverter code
@example
(require 'object)
@ftindex object

(define value (make-generic-method (lambda (val) val)))
(define set-value! (make-generic-method))
(define invert (make-generic-method
                (lambda (val)
                  (if (number? val)
                      (/ 1 val)
                      (error "Method not supported:" val)))))
(define noop (make-generic-method))
(define inverter? (make-generic-predicate))
(define describe (make-generic-method))
(define help (make-generic-method))

(define (make-number x)
  (define self (make-object))
  (make-method! self value (lambda (this) x))
  (make-method! self set-value!
                (lambda (this new-value) (set! x new-value)))
  self)

(define (make-description str)
  (define self (make-object))
  (make-method! self describe (lambda (this) str))
  (make-method! self help (lambda (this) "Help not available"))
  self)

(define (make-inverter)
  (let* ((self (make-object
                (make-number 1)
                (make-description "A number which can be inverted")))
         (<value> (get-method self value)))
    (make-method! self invert (lambda (self) (/ 1 (<value> self))))
    (make-predicate! self inverter?)
    (unmake-method! self help)
    (make-method! self help
                  (lambda (self)
                    (display "Inverter Methods:") (newline)
                    (display "  (value inverter) ==> n") (newline)))
    self))

;;;; Try it out

(define invert! (make-generic-method))

(define x (make-inverter))

(make-method! x invert! (lambda (x) (set-value! x (/ 1 (value x)))))

(value x)                       @result{} 1
(set-value! x 33)               @result{} undefined
(invert! x)                     @result{} undefined
(value x)                       @result{} 1/33

(unmake-method! x invert!)      @result{} undefined

(invert! x)                     @error{}  ERROR: Method not supported: x
@end example


@node Priority Queues, Queues, Object, Data Structures
@subsection Priority Queues

@code{(require 'priority-queue)}@refill
@ftindex priority-queue

@noindent
This algorithm for priority queues is due to
@cite{Introduction to Algorithms}
by T. Cormen, C. Leiserson, R. Rivest.
1989 MIT Press.@refill


@defun make-heap pred<?

Returns a binary heap suitable which can be used for priority queue
operations.@refill
@end defun

@defun heap-length heap

Returns the number of elements in @var{heap}.@refill
@end defun

@deffn {Procedure} heap-insert! heap item

Inserts @var{item} into @var{heap}.  @var{item} can be inserted multiple
times.  The value returned is unspecified.@refill
@end deffn

@deffn {Procedure} heap-extract-max! heap

Returns the item which is larger than all others according to the
@var{pred<?} argument to @code{make-heap}.  If there are no items in
@var{heap}, an error is signaled.@refill
@end deffn


@node Queues, Records, Priority Queues, Data Structures
@subsection Queues

@code{(require 'queue)}@refill
@ftindex queue

A @dfn{queue} is a list where elements can be added to both the front@refill
@cindex queue
and rear, and removed from the front (i.e., they are what are often
called @dfn{dequeues}).  A queue may also be used like a stack.@refill
@cindex dequeues


@defun make-queue

Returns a new, empty queue.@refill
@end defun

@defun queue? obj

Returns @code{#t} if @var{obj} is a queue.@refill
@end defun

@defun queue-empty? q

Returns @code{#t} if the queue @var{q} is empty.@refill
@end defun

@deffn {Procedure} queue-push! q datum

Adds @var{datum} to the front of queue @var{q}.@refill
@end deffn

@deffn {Procedure} enqueue! q datum

Adds @var{datum} to the rear of queue @var{q}.@refill
@end deffn

@deffn {Procedure} dequeue! q

@deffnx {Procedure} queue-pop! q
Both of these procedures remove and return the datum at the front of
the queue.  @code{queue-pop!} is used to suggest that the queue is
being used like a stack.@refill
@end deffn
All of the following functions raise an error if the queue @var{q}
is empty.@refill


@deffn {Procedure} dequeue-all! q

Removes and returns (the list) of all contents of queue @var{q}.@refill
@end deffn

@defun queue-front q

Returns the datum at the front of the queue @var{q}.@refill
@end defun

@defun queue-rear q

Returns the datum at the rear of the queue @var{q}.@refill
@end defun



@node Records,  , Queues, Data Structures
@subsection Records

@code{(require 'record)}@refill
@ftindex record

The Record package provides a facility for user to define their own
record data types.@refill

@defun make-record-type type-name field-names
Returns a @dfn{record-type descriptor}, a value representing a new data
type disjoint from all others.  The @var{type-name} argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type).  The @var{field-names}
argument is a list of symbols naming the @dfn{fields} of a record of the
new type.  It is an error if the list contains any duplicates.  It is
unspecified how record-type descriptors are represented.@refill
@end defun

@c @defun make-record-sub-type type-name field-names rtd
@c Returns a @dfn{record-type descriptor}, a value representing a new data
@c type, disjoint from all others.  The @var{type-name} argument must be a
@c string.  The @var{field-names} argument is a list of symbols naming the
@c additional @dfn{fields} to be appended to @var{field-names} of
@c @var{rtd}.  It is an error if the combined list contains any
@c duplicates.
@c
@c Record-modifiers and record-accessors for @var{rtd} work for the new
@c record-sub-type as well.  But record-modifiers and record-accessors for
@c the new record-sub-type will not neccessarily work for @var{rtd}.
@c @end defun

@defun record-constructor rtd [field-names]
Returns a procedure for constructing new members of the type represented
by @var{rtd}.  The returned procedure accepts exactly as many arguments
as there are symbols in the given list, @var{field-names}; these are
used, in order, as the initial values of those fields in a new record,
which is returned by the constructor procedure.  The values of any
fields not named in that list are unspecified.  The @var{field-names}
argument defaults to the list of field names in the call to
@code{make-record-type} that created the type represented by @var{rtd};
if the @var{field-names} argument is provided, it is an error if it
contains any duplicates or any symbols not in the default list.@refill
@end defun

@defun record-predicate rtd
Returns a procedure for testing membership in the type represented by
@var{rtd}.  The returned procedure accepts exactly one argument and
returns a true value if the argument is a member of the indicated record
type; it returns a false value otherwise.@refill
@end defun

@c @defun record-sub-predicate rtd
@c Returns a procedure for testing membership in the type represented by
@c @var{rtd} or its parents.  The returned procedure accepts exactly one
@c argument and returns a true value if the argument is a member of the
@c indicated record type or its parents; it returns a false value
@c otherwise.
@c @end defun

@defun record-accessor rtd field-name
Returns a procedure for reading the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
@var{field-name} in that record.  The symbol @var{field-name} must be a
member of the list of field-names in the call to @code{make-record-type}
that created the type represented by @var{rtd}.@refill
@end defun


@defun record-modifier rtd field-name
Returns a procedure for writing the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly two arguments: first, a record of the appropriate type,
and second, an arbitrary Scheme value; it modifies the field named by
the symbol @var{field-name} in that record to contain the given value.
The returned value of the modifier procedure is unspecified.  The symbol
@var{field-name} must be a member of the list of field-names in the call
to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end defun

In May of 1996, as a product of discussion on the @code{rrrs-authors}
mailing list, I rewrote @file{record.scm} to portably implement type
disjointness for record data types.@refill

As long as an implementation's procedures are opaque and the
@code{record} code is loaded before other programs, this will give
disjoint record types which are unforgeable and incorruptible by R4RS
procedures.@refill

As a consequence, the procedures @code{record?},
@code{record-type-descriptor}, @code{record-type-name}.and
@code{record-type-field-names} are no longer supported.@refill

@ignore
@defun record? obj
Returns a true value if @var{obj} is a record of any type and a false
value otherwise.  Note that @code{record?} may be true of any Scheme
value; of course, if it returns true for some particular value, then
@code{record-type-descriptor} is applicable to that value and returns an
appropriate descriptor.@refill
@end defun

@defun record-type-descriptor record
Returns a record-type descriptor representing the type of the given
record.  That is, for example, if the returned descriptor were passed to
@code{record-predicate}, the resulting predicate would return a true
value when passed the given record.  Note that it is not necessarily the
case that the returned descriptor is the one that was passed to
@code{record-constructor} in the call that created the constructor
procedure that created the given record.@refill
@end defun

@defun record-type-name rtd
Returns the type-name associated with the type represented by rtd.  The
returned value is @code{eqv?} to the @var{type-name} argument given in
the call to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end defun

@defun record-type-field-names rtd
Returns a list of the symbols naming the fields in members of the type
represented by @var{rtd}.  The returned value is @code{equal?} to the
field-names argument given in the call to @code{make-record-type} that
created the type represented by @var{rtd}.@refill
@end defun
@end ignore



@node Sorting and Searching, Procedures, Data Structures, Other Packages
@section Sorting and Searching

@menu
* Common List Functions::       'common-list-functions
* Tree Operations::             'tree
* Chapter Ordering::            'chapter-order
* Sorting::                     'sort
* Topological Sort::            Keep your socks on.
* Hashing::                     'hash
* Space-Filling Curves::        'hilbert and 'sierpinski
* Soundex::                     Dimension Reduction of Last Names
* String Search::               Also Search from a Port.
* Sequence Comparison::         'diff and longest-common-subsequence
@end menu



@node Common List Functions, Tree Operations, Sorting and Searching, Sorting and Searching
@subsection Common List Functions

@code{(require 'common-list-functions)}@refill
@ftindex common-list-functions

The procedures below follow the Common LISP equivalents apart from
optional arguments in some cases.@refill

@menu
* List construction::           
* Lists as sets::               
* Lists as sequences::          
* Destructive list operations::  
* Non-List functions::          
@end menu


@node List construction, Lists as sets, Common List Functions, Common List Functions
@subsubsection List construction

@defun make-list k
@defunx make-list k init
@code{make-list} creates and returns a list of @var{k} elements.  If
@var{init} is included, all elements in the list are initialized to
@var{init}.@refill

Example:@refill
@lisp
(make-list 3)
   @result{} (#<unspecified> #<unspecified> #<unspecified>)
(make-list 5 'foo)
   @result{} (foo foo foo foo foo)
@end lisp
@end defun


@defun list* obj1 obj2 @dots{}
Works like @code{list} except that the cdr of the last pair is the last
argument unless there is only one argument, when the result is just that
argument.  Sometimes called @code{cons*}.  E.g.:@refill

@lisp
(list* 1)
   @result{} 1
(list* 1 2 3)
   @result{} (1 2 . 3)
(list* 1 2 '(3 4))
   @result{} (1 2 3 4)
(list* @var{args} '())
   @equiv{} (list @var{args})
@end lisp
@end defun

@defun copy-list lst
@code{copy-list} makes a copy of @var{lst} using new pairs and returns
it. Only the top level of the list is copied, i.e., pairs forming
elements of the copied list remain @code{eq?} to the corresponding
elements of the original; the copy is, however, not @code{eq?} to the
original, but is @code{equal?} to it.@refill

Example:@refill
@lisp
(copy-list '(foo foo foo))
   @result{} (foo foo foo)
(define q '(foo bar baz bang))
(define p q)
(eq? p q)
   @result{} #t
(define r (copy-list q))
(eq? q r)
   @result{} #f
(equal? q r)
   @result{} #t
(define bar '(bar))
(eq? bar (car (copy-list (list bar 'foo))))
@result{} #t
   @end lisp
@end defun






@node Lists as sets, Lists as sequences, List construction, Common List Functions
@subsubsection Lists as sets

@code{eqv?} is used to test for membership by procedures which treat
lists as sets.

@defun adjoin e l
@code{adjoin} returns the adjoint of the element @var{e} and the list
@var{l}.  That is, if @var{e} is in @var{l}, @code{adjoin} returns
@var{l}, otherwise, it returns @code{(cons @var{e} @var{l})}.

Example:
@lisp
(adjoin 'baz '(bar baz bang))
   @result{} (bar baz bang)
(adjoin 'foo '(bar baz bang))
   @result{} (foo bar baz bang)
@end lisp
@end defun

@defun union l1 l2
@code{union} returns a list of all elements that are in @var{l1} or
@var{l2}.  Duplicates between @var{l1} and @var{l2} are culled.
Duplicates within @var{l1} or within @var{l2} may or may not be
removed.@refill

Example:@refill
@lisp
(union '(1 2 3 4) '(5 6 7 8))
   @result{} (1 2 3 4 5 6 7 8)
(union '(0 1 2 3 4) '(3 4 5 6))
   @result{} (5 6 0 1 2 3 4)
@end lisp
@end defun

@defun intersection l1 l2
@code{intersection} returns a list of all elements that are in both
@var{l1} and @var{l2}.@refill

Example:@refill
@lisp
(intersection '(1 2 3 4) '(3 4 5 6))
   @result{} (3 4)
(intersection '(1 2 3 4) '(5 6 7 8))
   @result{} ()
@end lisp
@end defun

@defun set-difference l1 l2
@code{set-difference} returns a list of all elements that are in
@var{l1} but not in @var{l2}.@refill

Example:@refill
@lisp
(set-difference '(1 2 3 4) '(3 4 5 6))
   @result{} (1 2)
(set-difference '(1 2 3 4) '(1 2 3 4 5 6))
   @result{} ()
@end lisp
@end defun

@defun subset? list1 list2
Returns @code{#t} if every element of @var{list1} is @code{eqv?} an
element of @var{list2}; otherwise returns @code{#f}.@refill

Example:@refill
@lisp
(subset? '(1 2 3 4) '(3 4 5 6))
   @result{} #f
(subset? '(1 2 3 4) '(6 5 4 3 2 1 0))
   @result{} #t
@end lisp
@end defun

@defun member-if pred lst
@code{member-if} returns the list headed by the first element of
@var{lst} to satisfy @code{(@var{pred} @var{element})}.
@code{Member-if} returns @code{#f} if @var{pred} returns @code{#f} for
every @var{element} in @var{lst}.@refill

Example:@refill
@lisp
(member-if vector? '(a 2 b 4))
   @result{} #f
(member-if number? '(a 2 b 4))
   @result{} (2 b 4)
@end lisp
@end defun

@defun some pred lst1 lst2 @dots{}
@var{pred} is a boolean function of as many arguments as there are list
arguments to @code{some} i.e., @var{lst} plus any optional arguments.
@var{pred} is applied to successive elements of the list arguments in
order.  @code{some} returns @code{#t} as soon as one of these
applications returns @code{#t}, and is @code{#f} if none returns
@code{#t}.  All the lists should have the same length.@refill


Example:@refill
@lisp
(some odd? '(1 2 3 4))
   @result{} #t

(some odd? '(2 4 6 8))
   @result{} #f

(some > '(1 3) '(2 4))
   @result{} #f
@end lisp
@end defun

@defun every pred lst1 lst2 @dots{}
@code{every} is analogous to @code{some} except it returns @code{#t} if
every application of @var{pred} is @code{#t} and @code{#f}
otherwise.@refill

Example:@refill
@lisp
(every even? '(1 2 3 4))
   @result{} #f

(every even? '(2 4 6 8))
   @result{} #t

(every > '(2 3) '(1 4))
   @result{} #f
@end lisp
@end defun

@defun notany pred lst1 @dots{}
@code{notany} is analogous to @code{some} but returns @code{#t} if no
application of @var{pred} returns @code{#t} or @code{#f} as soon as any
one does.@refill
@end defun

@defun notevery pred lst1 @dots{}
@code{notevery} is analogous to @code{some} but returns @code{#t} as soon
as an application of @var{pred} returns @code{#f}, and @code{#f}
otherwise.@refill

Example:@refill
@lisp
(notevery even? '(1 2 3 4))
   @result{} #t

(notevery even? '(2 4 6 8))
   @result{} #f
@end lisp
@end defun


@defun list-of?? predicate
Returns a predicate which returns true if its argument is a list every
element of which satisfies @var{predicate}.@refill

@defunx list-of?? predicate low-bound high-bound
@var{low-bound} and @var{high-bound} are non-negative integers.
@code{list-of??} returns a predicate which returns true if its argument
is a list of length between @var{low-bound} and @var{high-bound}
(inclusive); every element of which satisfies @var{predicate}.@refill

@defunx list-of?? predicate bound
@var{bound} is an integer.  If @var{bound} is negative, @code{list-of??}
returns a predicate which returns true if its argument is a list of
length greater than @code{(- @var{bound})}; every element of which
satisfies @var{predicate}.  Otherwise, @code{list-of??}  returns a
predicate which returns true if its argument is a list of length less
than or equal to @var{bound}; every element of which satisfies
@var{predicate}.@refill
@end defun


@defun find-if pred lst
@code{find-if} searches for the first @var{element} in @var{lst} such
that @code{(@var{pred} @var{element})} returns @code{#t}.  If it finds
any such @var{element} in @var{lst}, @var{element} is returned.
Otherwise, @code{#f} is returned.@refill

Example:@refill
@lisp
(find-if number? '(foo 1 bar 2))
   @result{} 1

(find-if number? '(foo bar baz bang))
   @result{} #f

(find-if symbol? '(1 2 foo bar))
   @result{} foo
@end lisp
@end defun

@defun remove elt lst
@code{remove} removes all occurrences of @var{elt} from @var{lst} using
@code{eqv?} to test for equality and returns everything that's left.
N.B.: other implementations (Chez, Scheme->C and T, at least) use
@code{equal?} as the equality test.@refill

Example:@refill
@lisp
(remove 1 '(1 2 1 3 1 4 1 5))
   @result{} (2 3 4 5)

(remove 'foo '(bar baz bang))
   @result{} (bar baz bang)
@end lisp
@end defun

@defun remove-if pred lst
@code{remove-if} removes all @var{element}s from @var{lst} where
@code{(@var{pred} @var{element})} is @code{#t} and returns everything
that's left.@refill

Example:@refill
@lisp
(remove-if number? '(1 2 3 4))
   @result{} ()

(remove-if even? '(1 2 3 4 5 6 7 8))
   @result{} (1 3 5 7)
@end lisp
@end defun

@defun remove-if-not pred lst
@code{remove-if-not} removes all @var{element}s from @var{lst} for which
@code{(@var{pred} @var{element})} is @code{#f} and returns everything that's
left.@refill

Example:@refill
@lisp
(remove-if-not number? '(foo bar baz))
   @result{} ()
(remove-if-not odd? '(1 2 3 4 5 6 7 8))
   @result{} (1 3 5 7)
@end lisp
@end defun

@defun has-duplicates? lst
returns @code{#t} if 2 members of @var{lst} are @code{equal?}, @code{#f}
otherwise.@refill

Example:@refill
@lisp
(has-duplicates? '(1 2 3 4))
   @result{} #f

(has-duplicates? '(2 4 3 4))
   @result{} #t
@end lisp
@end defun

The procedure @code{remove-duplicates} uses @code{member} (rather than
@code{memv}).@refill

@defun remove-duplicates lst
returns a copy of @var{lst} with its duplicate members removed.
Elements are considered duplicate if they are @code{equal?}.@refill

Example:@refill
@lisp
(remove-duplicates '(1 2 3 4))
   @result{} (1 2 3 4)

(remove-duplicates '(2 4 3 4))
   @result{} (2 4 3)
@end lisp
@end defun


@node Lists as sequences, Destructive list operations, Lists as sets, Common List Functions
@subsubsection Lists as sequences

@defun position obj lst
@code{position} returns the 0-based position of @var{obj} in @var{lst},
or @code{#f} if @var{obj} does not occur in @var{lst}.@refill

Example:@refill
@lisp
(position 'foo '(foo bar baz bang))
   @result{} 0
(position 'baz '(foo bar baz bang))
   @result{} 2
(position 'oops '(foo bar baz bang))
   @result{} #f
@end lisp
@end defun

@defun reduce p lst
@code{reduce} combines all the elements of a sequence using a binary
operation (the combination is left-associative).  For example, using
@code{+}, one can add up all the elements.  @code{reduce} allows you to
apply a function which accepts only two arguments to more than 2
objects.  Functional programmers usually refer to this as @dfn{foldl}.
@code{collect:reduce} (@pxref{Collections}) provides a version of
@code{collect} generalized to collections.@refill

Example:@refill
@lisp
(reduce + '(1 2 3 4))
   @result{} 10
(define (bad-sum . l) (reduce + l))
(bad-sum 1 2 3 4)
   @equiv{} (reduce + (1 2 3 4))
   @equiv{} (+ (+ (+ 1 2) 3) 4)
@result{} 10
(bad-sum)
   @equiv{} (reduce + ())
   @result{} ()
(reduce string-append '("hello" "cruel" "world"))
   @equiv{} (string-append (string-append "hello" "cruel") "world")
   @result{} "hellocruelworld"
(reduce anything '())
   @result{} ()
(reduce anything '(x))
   @result{} x
@end lisp

What follows is a rather non-standard implementation of @code{reverse}
in terms of @code{reduce} and a combinator elsewhere called
@dfn{C}.@refill

@lisp
;;; Contributed by Jussi Piitulainen (jpiitula @@ ling.helsinki.fi)

(define commute
  (lambda (f)
    (lambda (x y)
      (f y x))))

(define reverse
  (lambda (args)
    (reduce-init (commute cons) '() args)))
@end lisp
@end defun

@defun reduce-init p init lst
@code{reduce-init} is the same as reduce, except that it implicitly
inserts @var{init} at the start of the list.  @code{reduce-init} is
preferred if you want to handle the null list, the one-element, and
lists with two or more elements consistently.  It is common to use the
operator's idempotent as the initializer.  Functional programmers
usually call this @dfn{foldl}.@refill

Example:@refill
@lisp
(define (sum . l) (reduce-init + 0 l))
(sum 1 2 3 4)
   @equiv{} (reduce-init + 0 (1 2 3 4))
   @equiv{} (+ (+ (+ (+ 0 1) 2) 3) 4)
   @result{} 10
(sum)
   @equiv{} (reduce-init + 0 '())
   @result{} 0

(reduce-init string-append "@@" '("hello" "cruel" "world"))
@equiv{}
(string-append (string-append (string-append "@@" "hello")
                               "cruel")
               "world")
@result{} "@@hellocruelworld"
@end lisp

Given a differentiation of 2 arguments, @code{diff}, the following will
differentiate by any number of variables.@refill
@lisp
(define (diff* exp . vars)
  (reduce-init diff exp vars))
@end lisp

Example:@refill
@lisp
;;; Real-world example:  Insertion sort using reduce-init.

(define (insert l item)
  (if (null? l)
      (list item)
      (if (< (car l) item)
          (cons (car l) (insert (cdr l) item))
          (cons item l))))
(define (insertion-sort l) (reduce-init insert '() l))

(insertion-sort '(3 1 4 1 5)
   @equiv{} (reduce-init insert () (3 1 4 1 5))
   @equiv{} (insert (insert (insert (insert (insert () 3) 1) 4) 1) 5)
   @equiv{} (insert (insert (insert (insert (3)) 1) 4) 1) 5)
   @equiv{} (insert (insert (insert (1 3) 4) 1) 5)
   @equiv{} (insert (insert (1 3 4) 1) 5)
   @equiv{} (insert (1 1 3 4) 5)
   @result{} (1 1 3 4 5)
   @end lisp
@end defun

@defun last lst n
@code{last} returns the last @var{n} elements of @var{lst}.  @var{n}
must be a non-negative integer.

Example:
@lisp
(last '(foo bar baz bang) 2)
   @result{} (baz bang)
(last '(1 2 3) 0)
   @result{} 0
@end lisp
@end defun

@defun butlast lst n
@code{butlast} returns all but the last @var{n} elements of
@var{lst}.@refill

Example:@refill
@lisp
(butlast '(a b c d) 3)
   @result{} (a)
(butlast '(a b c d) 4)
   @result{} ()
@end lisp
@end defun

@noindent
@code{last} and @code{butlast} split a list into two parts when given
identical arugments.@refill
@example
(last '(a b c d e) 2)
   @result{} (d e)
(butlast '(a b c d e) 2)
   @result{} (a b c)
@end example

@defun nthcdr n lst
@code{nthcdr} takes @var{n} @code{cdr}s of @var{lst} and returns the
result.  Thus @code{(nthcdr 3 @var{lst})} @equiv{} @code{(cdddr
@var{lst})}@refill

Example:@refill
@lisp
(nthcdr 2 '(a b c d))
   @result{} (c d)
(nthcdr 0 '(a b c d))
   @result{} (a b c d)
@end lisp
@end defun

@defun butnthcdr n lst
@code{butnthcdr} returns all but the nthcdr @var{n} elements of
@var{lst}.@refill

Example:@refill
@lisp
(butnthcdr 3 '(a b c d))
   @result{} (a b c)
(butnthcdr 4 '(a b c d))
   @result{} (a b c d)
@end lisp
@end defun

@noindent
@code{nthcdr} and @code{butnthcdr} split a list into two parts when
given identical arugments.@refill
@example
(nthcdr 2 '(a b c d e))
   @result{} (c d e)
(butnthcdr 2 '(a b c d e))
   @result{} (a b)
@end example



@node Destructive list operations, Non-List functions, Lists as sequences, Common List Functions
@subsubsection Destructive list operations

These procedures may mutate the list they operate on, but any such
mutation is undefined.@refill

@deffn {Procedure} nconc args
@code{nconc} destructively concatenates its arguments.  (Compare this
with @code{append}, which copies arguments rather than destroying them.)
Sometimes called @code{append!} (@pxref{Rev2 Procedures}).@refill

Example:  You want to find the subsets of a set.  Here's the obvious way:@refill

@lisp
(define (subsets set)
  (if (null? set)
      '(())
      (append (map (lambda (sub) (cons (car set) sub))
                   (subsets (cdr set)))
              (subsets (cdr set)))))
@end lisp
But that does way more consing than you need.  Instead, you could
replace the @code{append} with @code{nconc}, since you don't have any
need for all the intermediate results.@refill

Example:@refill
@lisp
(define x '(a b c))
(define y '(d e f))
(nconc x y)
   @result{} (a b c d e f)
x
   @result{} (a b c d e f)
@end lisp

@code{nconc} is the same as @code{append!} in @file{sc2.scm}.@refill
@end deffn

@deffn {Procedure} nreverse lst
@code{nreverse} reverses the order of elements in @var{lst} by mutating
@code{cdr}s of the list.  Sometimes called @code{reverse!}.@refill

Example:@refill
@lisp
(define foo '(a b c))
(nreverse foo)
   @result{} (c b a)
foo
   @result{} (a)
@end lisp

Some people have been confused about how to use @code{nreverse},
thinking that it doesn't return a value.  It needs to be pointed out
that@refill

@lisp
(set! lst (nreverse lst))
@end lisp
@noindent
is the proper usage, not@refill
@lisp
(nreverse lst)
@end lisp
The example should suffice to show why this is the case.@refill
@end deffn

@deffn {Procedure} delete elt lst
@deffnx {Procedure} delete-if pred lst
@deffnx {Procedure} delete-if-not pred lst
Destructive versions of @code{remove} @code{remove-if}, and
@code{remove-if-not}.@refill

Example:@refill
@lisp
(define lst (list 'foo 'bar 'baz 'bang))
(delete 'foo lst)
   @result{} (bar baz bang)
lst
   @result{} (foo bar baz bang)

(define lst (list 1 2 3 4 5 6 7 8 9))
(delete-if odd? lst)
   @result{} (2 4 6 8)
lst
   @result{} (1 2 4 6 8)
@end lisp

Some people have been confused about how to use @code{delete},
@code{delete-if}, and @code{delete-if}, thinking that they don't return
a value.  It needs to be pointed out that@refill

@lisp
(set! lst (delete el lst))
@end lisp
@noindent
is the proper usage, not@refill
@lisp
(delete el lst)
@end lisp
The examples should suffice to show why this is the case.@refill
@end deffn



@node Non-List functions,  , Destructive list operations, Common List Functions
@subsubsection Non-List functions

@defun and? arg1 @dots{}
@code{and?} checks to see if all its arguments are true.  If they are,
@code{and?} returns @code{#t}, otherwise, @code{#f}.  (In contrast to
@code{and}, this is a function, so all arguments are always evaluated
and in an unspecified order.)@refill

Example:@refill
@lisp
(and? 1 2 3)
   @result{} #t
(and #f 1 2)
   @result{} #f
@end lisp
@end defun

@defun or? arg1 @dots{}
@code{or?} checks to see if any of its arguments are true.  If any is
true, @code{or?} returns @code{#t}, and @code{#f} otherwise.  (To
@code{or} as @code{and?} is to @code{and}.)@refill

Example:@refill
@lisp
(or? 1 2 #f)
   @result{} #t
(or? #f #f #f)
   @result{} #f
@end lisp
@end defun

@defun atom? object
Returns @code{#t} if @var{object} is not a pair and @code{#f} if it is
pair.  (Called @code{atom} in Common LISP.)@refill
@lisp
(atom? 1)
   @result{} #t
(atom? '(1 2))
   @result{} #f
(atom? #(1 2))   ; dubious!
   @result{} #t
@end lisp
@end defun


@node Tree Operations, Chapter Ordering, Common List Functions, Sorting and Searching
@subsection Tree operations

@code{(require 'tree)}@refill
@ftindex tree

These are operations that treat lists a representations of trees.@refill


@defun subst new old tree
@defunx substq new old tree
@defunx substv new old tree


@defunx subst new old tree equ?
@code{subst} makes a copy of @var{tree}, substituting @var{new} for
every subtree or leaf of @var{tree} which is @code{equal?} to @var{old}
and returns a modified tree.  The original @var{tree} is unchanged, but
may share parts with the result.@refill

@code{substq} and @code{substv} are similar, but test against @var{old}
using @code{eq?} and @code{eqv?} respectively.  If @code{subst} is
called with a fourth argument, @var{equ?} is the equality predicate.@refill

Examples:@refill
@lisp
(substq 'tempest 'hurricane '(shakespeare wrote (the hurricane)))
   @result{} (shakespeare wrote (the tempest))
(substq 'foo '() '(shakespeare wrote (twelfth night)))
   @result{} (shakespeare wrote (twelfth night . foo) . foo)
(subst '(a . cons) '(old . pair)
       '((old . spice) ((old . shoes) old . pair) (old . pair)))
   @result{} ((old . spice) ((old . shoes) a . cons) (a . cons))
@end lisp
@end defun

@defun copy-tree tree

Makes a copy of the nested list structure @var{tree} using new pairs and
returns it.  All levels are copied, so that none of the pairs in the
tree are @code{eq?} to the original ones -- only the leaves are.@refill

Example:@refill
@lisp
(define bar '(bar))
(copy-tree (list bar 'foo))
   @result{} ((bar) foo)
(eq? bar (car (copy-tree (list bar 'foo))))
   @result{} #f
@end lisp
@end defun


@node Chapter Ordering, Sorting, Tree Operations, Sorting and Searching
@subsection Chapter Ordering

@code{(require 'chapter-order)}@refill
@ftindex chapter-order

The @samp{chap:} functions deal with strings which are ordered like
chapter numbers (or letters) in a book.  Each section of the string
consists of consecutive numeric or consecutive aphabetic characters of
like case.@refill


@defun chap:string<? string1 string2

Returns #t if the first non-matching run of alphabetic upper-case or
the first non-matching run of alphabetic lower-case or the first
non-matching run of numeric characters of @var{string1} is
@code{string<?} than the corresponding non-matching run of
characters of @var{string2}.@refill

@example
(chap:string<? "a.9" "a.10")                    @result{} #t
(chap:string<? "4c" "4aa")                      @result{} #t
(chap:string<? "Revised^@{3.99@}" "Revised^@{4@}")  @result{} #t
@end example
@end defun

@defun chap:string>? string1 string2
@defunx chap:string<=? string1 string2
@defunx chap:string>=? string1 string2

Implement the corresponding chapter-order predicates.@refill
@end defun

@defun chap:next-string string

Returns the next string in the @emph{chapter order}.  If @var{string}
has no alphabetic or numeric characters,
@code{(string-append @var{string} "0")} is returnd.  The argument to
chap:next-string will always be @code{chap:string<?} than the result.@refill

@example
(chap:next-string "a.9")                @result{} "a.10"
(chap:next-string "4c")                 @result{} "4d"
(chap:next-string "4z")                 @result{} "4aa"
(chap:next-string "Revised^@{4@}")        @result{} "Revised^@{5@}"

@end example
@end defun


@node Sorting, Topological Sort, Chapter Ordering, Sorting and Searching
@subsection Sorting

@code{(require 'sort)}@refill
@ftindex sort

Many Scheme systems provide some kind of sorting functions.  They do
not, however, always provide the @emph{same} sorting functions, and
those that I have had the opportunity to test provided inefficient ones
(a common blunder is to use quicksort which does not perform well).@refill

Because @code{sort} and @code{sort!} are not in the standard, there is
very little agreement about what these functions look like.  For
example, Dybvig says that Chez Scheme provides@refill
@lisp
(merge predicate list1 list2)
(merge! predicate list1 list2)
(sort predicate list)
(sort! predicate list)
@end lisp
@noindent
while MIT Scheme 7.1, following Common LISP, offers unstable@refill
@lisp
(sort list predicate)
@end lisp
@noindent
TI PC Scheme offers@refill
@lisp
(sort! list/vector predicate?)
@end lisp
@noindent
and Elk offers@refill
@lisp
(sort list/vector predicate?)
(sort! list/vector predicate?)
@end lisp

Here is a comprehensive catalogue of the variations I have found.@refill

@enumerate
@item
Both @code{sort} and @code{sort!} may be provided.@refill
@item
@code{sort} may be provided without @code{sort!}.@refill
@item
@code{sort!} may be provided without @code{sort}.@refill
@item
Neither may be provided.@refill
@item
The sequence argument may be either a list or a vector.@refill
@item
The sequence argument may only be a list.@refill
@item
The sequence argument may only be a vector.@refill
@item
The comparison function may be expected to behave like @code{<}.@refill
@item
The comparison function may be expected to behave like @code{<=}.@refill
@item
The interface may be @code{(sort predicate? sequence)}.@refill
@item
The interface may be @code{(sort sequence predicate?)}.@refill
@item
The interface may be @code{(sort sequence &optional (predicate? <))}.@refill
@item
The sort may be stable.@refill
@item
The sort may be unstable.@refill
@end enumerate

All of this variation really does not help anybody.  A nice simple merge
sort is both stable and fast (quite a lot faster than @emph{quick} sort).@refill

I am providing this source code with no restrictions at all on its use
(but please retain D.H.D.Warren's credit for the original idea).  You
may have to rename some of these functions in order to use them in a
system which already provides incompatible or inferior sorts.  For each
of the functions, only the top-level define needs to be edited to do
that.@refill

I could have given these functions names which would not clash with any
Scheme that I know of, but I would like to encourage implementors to
converge on a single interface, and this may serve as a hint.  The
argument order for all functions has been chosen to be as close to
Common LISP as made sense, in order to avoid NIH-itis.@refill

Each of the five functions has a required @emph{last} parameter which is
a comparison function.  A comparison function @code{f} is a function of
2 arguments which acts like @code{<}.  For example,@refill

@lisp
(not (f x x))
(and (f x y) (f y z)) @equiv{} (f x z)
@end lisp

The standard functions @code{<}, @code{>}, @code{char<?}, @code{char>?},
@code{char-ci<?}, @code{char-ci>?}, @code{string<?}, @code{string>?},
@code{string-ci<?}, and @code{string-ci>?} are suitable for use as
comparison functions.  Think of @code{(less? x y)} as saying when
@code{x} must @emph{not} precede @code{y}.@refill

@defun sorted? sequence less?
Returns @code{#t} when the sequence argument is in non-decreasing order
according to @var{less?} (that is, there is no adjacent pair @code{@dots{} x
y @dots{}} for which @code{(less? y x)}).@refill

Returns @code{#f} when the sequence contains at least one out-of-order
pair.  It is an error if the sequence is not a list, vector, or
string.@refill
@end defun

@defun merge list1 list2 less?
This merges two lists, producing a completely new list as result.  I
gave serious consideration to producing a Common-LISP-compatible
version.  However, Common LISP's @code{sort} is our @code{sort!} (well,
in fact Common LISP's @code{stable-sort} is our @code{sort!}, merge sort
is @emph{fast} as well as stable!) so adapting CL code to Scheme takes a
bit of work anyway.  I did, however, appeal to CL to determine the
@emph{order} of the arguments.@refill
@end defun

@deffn {Procedure} merge! list1 list2 less?
Merges two lists, re-using the pairs of @var{list1} and @var{list2} to
build the result.  If the code is compiled, and @var{less?} constructs
no new pairs, no pairs at all will be allocated.  The first pair of the
result will be either the first pair of @var{list1} or the first pair of
@var{list2}, but you can't predict which.@refill

The code of @code{merge} and @code{merge!} could have been quite a bit
simpler, but they have been coded to reduce the amount of work done per
iteration.  (For example, we only have one @code{null?} test per
iteration.)@refill

@end deffn

@defun sort sequence less?
Accepts either a list, vector, or string; and returns a new sequence
which is sorted.  The new sequence is the same type as the input.
Always @code{(sorted? (sort sequence less?) less?)}.  The original
sequence is not altered in any way.  The new sequence shares its
@emph{elements} with the old one; no elements are copied.@refill
@end defun

@deffn {Procedure} sort! sequence less?
Returns its sorted result in the original boxes.  If the original
sequence is a list, no new storage is allocated at all.  If the
original sequence is a vector or string, the sorted elements are put
back in the same vector or string.@refill

Some people have been confused about how to use @code{sort!}, thinking
that it doesn't return a value.  It needs to be pointed out that@refill
@lisp
(set! slist (sort! slist <))
@end lisp
@noindent
is the proper usage, not@refill
@lisp
(sort! slist <)
@end lisp
@end deffn

Note that these functions do @emph{not} accept a CL-style @samp{:key}
argument.  A simple device for obtaining the same expressiveness is to
define@refill

@lisp
(define (keyed less? key)
  (lambda (x y) (less? (key x) (key y))))
@end lisp
@noindent
and then, when you would have written@refill
@lisp
(sort a-sequence #'my-less :key #'my-key)
@end lisp
@noindent
in Common LISP, just write@refill
@lisp
(sort! a-sequence (keyed my-less? my-key))
@end lisp
@noindent
in Scheme.@refill

@node Topological Sort, Hashing, Sorting, Sorting and Searching
@subsection Topological Sort

@code{(require 'topological-sort)} or @code{(require 'tsort)}@refill
@ftindex topological-sort
@ftindex tsort

@noindent
The algorithm is inspired by Cormen, Leiserson and Rivest (1990)
@cite{Introduction to Algorithms}, chapter 23.@refill


@defun tsort dag pred

@defunx topological-sort dag pred
where@refill
@table @var
@item dag
is a list of sublists.  The car of each sublist is a vertex.  The cdr is
the adjacency list of that vertex, i.e. a list of all vertices to which
there exists an edge from the car vertex.@refill
@item pred
is one of @code{eq?}, @code{eqv?}, @code{equal?}, @code{=},
@code{char=?}, @code{char-ci=?}, @code{string=?}, or @code{string-ci=?}.@refill
@end table

Sort the directed acyclic graph @var{dag} so that for every edge from
vertex @var{u} to @var{v}, @var{u} will come before @var{v} in the
resulting list of vertices.@refill

Time complexity: O (|V| + |E|)@refill

Example (from Cormen):@refill
@quotation
Prof. Bumstead topologically sorts his clothing when getting
dressed.  The first argument to @code{tsort} describes which
garments he needs to put on before others.  (For example,
Prof Bumstead needs to put on his shirt before he puts on his
tie or his belt.)  @code{tsort} gives the correct order of dressing:@refill
@end quotation

@example
(require 'tsort)
@ftindex tsort
(tsort '((shirt tie belt)
         (tie jacket)
         (belt jacket)
         (watch)
         (pants shoes belt)
         (undershorts pants shoes)
         (socks shoes))
       eq?)
@result{}
(socks undershorts pants shoes watch shirt belt tie jacket)
@end example
@end defun


@node Hashing, Space-Filling Curves, Topological Sort, Sorting and Searching
@subsection Hashing

@code{(require 'hash)}@refill
@ftindex hash

These hashing functions are for use in quickly classifying objects.
Hash tables use these functions.@refill

@defun hashq obj k
@defunx hashv obj k
@defunx hash obj k
Returns an exact non-negative integer less than @var{k}.  For each
non-negative integer less than @var{k} there are arguments @var{obj} for
which the hashing functions applied to @var{obj} and @var{k} returns
that integer.@refill

For @code{hashq}, @code{(eq? obj1 obj2)} implies @code{(= (hashq obj1 k)
(hashq obj2))}.@refill

For @code{hashv}, @code{(eqv? obj1 obj2)} implies @code{(= (hashv obj1 k)
(hashv obj2))}.@refill

For @code{hash}, @code{(equal? obj1 obj2)} implies @code{(= (hash obj1 k)
(hash obj2))}.@refill

@code{hash}, @code{hashv}, and @code{hashq} return in time bounded by a
constant.  Notice that items having the same @code{hash} implies the
items have the same @code{hashv} implies the items have the same
@code{hashq}.@refill
@end defun


@node Space-Filling Curves, Soundex, Hashing, Sorting and Searching
@subsection Space-Filling Curves

@menu
* Peano-Hilbert Space-Filling Curve::  
* Sierpinski Curve::            
@end menu

@node Peano-Hilbert Space-Filling Curve, Sierpinski Curve, Space-Filling Curves, Space-Filling Curves
@subsubsection Peano-Hilbert Space-Filling Curve

@code{(require 'hilbert-fill)}@refill
@ftindex hilbert-fill

@noindent
@cindex Peano
@cindex Hilbert
@cindex Space-Filling
The @dfn{Peano-Hilbert Space-Filling Curve} is a one-to-one mapping@refill
@cindex Peano-Hilbert Space-Filling Curve
between a unit line segment and an @var{n}-dimensional unit cube.@refill

@noindent
The integer procedures map the non-negative integers to an
arbitrarily large @var{n}-dimensional cube with its corner at the
origin and all coordinates are non-negative.@refill

@noindent
For any exact nonnegative integers @var{scalar} and @var{rank},@refill

@example
(= @var{scalar} (hilbert-coordinates->integer
           (integer->hilbert-coordinates @var{scalar} @var{rank})))
                                       @result{} #t
@end example


@defun integer->hilbert-coordinates scalar rank

Returns a list of @var{rank} integer coordinates corresponding to exact
non-negative integer @var{scalar}.  The lists returned by @code{integer->hilbert-coordinates} for @var{scalar} arguments
0 and 1 will differ in the first element.@refill
@end defun

@defun hilbert-coordinates->integer coords

Returns an exact non-negative integer corresponding to @var{coords}, a list
of non-negative integer coordinates.@refill
@end defun


@node Sierpinski Curve,  , Peano-Hilbert Space-Filling Curve, Space-Filling Curves
@subsubsection Sierpinski Curve

@code{(require 'sierpinski)}@refill
@ftindex sierpinski

@defun make-sierpinski-indexer max-coordinate
Returns a procedure (eg hash-function) of 2 numeric arguments which
preserves @emph{nearness} in its mapping from NxN to N.@refill

@var{max-coordinate} is the maximum coordinate (a positive integer) of a
population of points.  The returned procedures is a function that takes
the x and y coordinates of a point, (non-negative integers) and returns
an integer corresponding to the relative position of that point along a
Sierpinski curve.  (You can think of this as computing a (pseudo-)
inverse of the Sierpinski spacefilling curve.)@refill

Example use: Make an indexer (hash-function) for integer points lying in
square of integer grid points [0,99]x[0,99]:@refill
@example
(define space-key (make-sierpinski-indexer 100))
@end example
Now let's compute the index of some points:@refill
@example
(space-key 24 78)               @result{} 9206
(space-key 23 80)               @result{} 9172
@end example

Note that locations (24, 78) and (23, 80) are near in index and
therefore, because the Sierpinski spacefilling curve is continuous, we
know they must also be near in the plane.  Nearness in the plane does
not, however, necessarily correspond to nearness in index, although it
@emph{tends} to be so.@refill

Example applications:@refill
@itemize @bullet

@item
Sort points by Sierpinski index to get heuristic solution to
@emph{travelling salesman problem}.  For details of performance,
see L. Platzman and J. Bartholdi, "Spacefilling curves and the
Euclidean travelling salesman problem", JACM 36(4):719--737
(October 1989) and references therein.@refill

@item
Use Sierpinski index as key by which to store 2-dimensional data
in a 1-dimensional data structure (such as a table).  Then
locations that are near each other in 2-d space will tend to
be near each other in 1-d data structure; and locations that
are near in 1-d data structure will be near in 2-d space.  This
can significantly speed retrieval from secondary storage because
contiguous regions in the plane will tend to correspond to
contiguous regions in secondary storage.  (This is a standard
technique for managing CAD/CAM or geographic data.)@refill

@end itemize
@end defun


@node Soundex, String Search, Space-Filling Curves, Sorting and Searching
@subsection Soundex

@code{(require 'soundex)}@refill
@ftindex soundex

@defun soundex name
Computes the @emph{soundex} hash of @var{name}.  Returns a string of an
initial letter and up to three digits between 0 and 6.  Soundex
supposedly has the property that names that sound similar in normal
English pronunciation tend to map to the same key.@refill

Soundex was a classic algorithm used for manual filing of personal
records before the advent of computers.  It performs adequately for
English names but has trouble with other languages.@refill

See Knuth, Vol. 3 @cite{Sorting and searching}, pp 391--2@refill

To manage unusual inputs, @code{soundex} omits all non-alphabetic
characters.  Consequently, in this implementation:@refill

@example
(soundex <string of blanks>)    @result{} ""
(soundex "")                    @result{} ""
@end example

Examples from Knuth:@refill

@example
(map soundex '("Euler" "Gauss" "Hilbert" "Knuth"
                       "Lloyd" "Lukasiewicz"))
        @result{} ("E460" "G200" "H416" "K530" "L300" "L222")

(map soundex '("Ellery" "Ghosh" "Heilbronn" "Kant"
                        "Ladd" "Lissajous"))
        @result{} ("E460" "G200" "H416" "K530" "L300" "L222")
@end example

Some cases in which the algorithm fails (Knuth):@refill

@example
(map soundex '("Rogers" "Rodgers"))     @result{} ("R262" "R326")

(map soundex '("Sinclair" "St. Clair")) @result{} ("S524" "S324")

(map soundex '("Tchebysheff" "Chebyshev")) @result{} ("T212" "C121")
@end example
@end defun


@node String Search, Sequence Comparison, Soundex, Sorting and Searching
@subsection String Search

@code{(require 'string-search)}@refill
@ftindex string-search

@deffn {Procedure} string-index string char
@deffnx {Procedure} string-index-ci string char
Returns the index of the first occurence of @var{char} within
@var{string}, or @code{#f} if the @var{string} does not contain a
character @var{char}.@refill
@end deffn

@deffn {Procedure} string-reverse-index string char
@deffnx {Procedure} string-reverse-index-ci string char
Returns the index of the last occurence of @var{char} within
@var{string}, or @code{#f} if the @var{string} does not contain a
character @var{char}.@refill
@end deffn

@deffn {Procedure} substring? pattern string
@deffnx {Procedure} substring-ci? pattern string
Searches @var{string} to see if some substring of @var{string} is equal
to @var{pattern}.  @code{substring?} returns the index of the first
character of the first substring of @var{string} that is equal to
@var{pattern}; or @code{#f} if @var{string} does not contain
@var{pattern}.@refill

@example
(substring? "rat" "pirate") @result{}  2
(substring? "rat" "outrage") @result{}  #f
(substring? "" any-string) @result{}  0
@end example
@end deffn

@deffn {Procedure} find-string-from-port? str in-port max-no-chars
Looks for a string @var{str} within the first @var{max-no-chars} chars
of the input port @var{in-port}.@refill

@deffnx {Procedure} find-string-from-port? str in-port
When called with two arguments, the search span is limited by the end of
the input stream.@refill

@deffnx {Procedure} find-string-from-port? str in-port char
Searches up to the first occurrence of character @var{char} in
@var{str}.@refill

@deffnx {Procedure} find-string-from-port? str in-port proc
Searches up to the first occurrence of the procedure @var{proc}
returning non-false when called with a character (from @var{in-port})
argument.@refill

When the @var{str} is found, @code{find-string-from-port?} returns the
number of characters it has read from the port, and the port is set to
read the first char after that (that is, after the @var{str}) The
function returns @code{#f} when the @var{str} isn't found.@refill

@code{find-string-from-port?} reads the port @emph{strictly}
sequentially, and does not perform any buffering.  So
@code{find-string-from-port?} can be used even if the @var{in-port} is
open to a pipe or other communication channel.@refill
@end deffn

@defun string-subst txt old1 new1 @dots{}
Returns a copy of string @var{txt} with all occurrences of string
@var{old1} in @var{txt} replaced with @var{new1}; then @var{old2}
replaced with @var{new2} @dots{}.  Matches are found from the left.
Matches do not overlap.@refill
@end defun

@defun count-newlines str
Returns the number of @samp{#\newline} characters in string @var{str}.@refill
@end defun


@node Sequence Comparison,  , String Search, Sorting and Searching
@subsection Sequence Comparison

@code{(require 'diff)}@refill
@ftindex diff
@cindex Sequence Comparison

@noindent
@code{diff:edit-length} implements the algorithm:@refill

@ifinfo
@example
S. Wu, E. Myers, U. Manber, and W. Miller,
   "An O(NP) Sequence Comparison Algorithm,"
   Information Processing Letters 35, 6 (1990), 317-323.
   @url{http://www.cs.arizona.edu/people/gene/vita.html}
@end example
@end ifinfo
@ifset html
S. Wu, <A HREF="http://www.cs.arizona.edu/people/gene/vita.html">
E. Myers,</A> U. Manber, and W. Miller,
<A HREF="http://www.cs.arizona.edu/people/gene/PAPERS/np_diff.ps">
"An O(NP) Sequence Comparison Algorithm,"</A>
Information Processing Letters 35, 6 (1990), 317-323.@refill
@end ifset

@noindent
The values returned by @code{diff:edit-length} can be used to gauge
the degree of match between two sequences.@refill

@noindent
Surprisingly, "An O(NP) Sequence Comparison Algorithm" does not
derive the edit sequence; only the sequence length.  Developing this
linear-space sub-quadratic-time algorithm for computing the edit
sequence required hundreds of hours of work.  I have submitted a
paper describing the algorithm to the Journal of Computational
Biology.@refill

@noindent
If the items being sequenced are text lines, then the computed
edit-list is equivalent to the output of the @dfn{diff} utility@refill
@cindex diff
program.  If the items being sequenced are words, then it is like the
lesser known @dfn{spiff} program.@refill
@cindex spiff


@defun diff:longest-common-subsequence array1 array2 =? p-lim


@defunx diff:longest-common-subsequence array1 array2 =?
@var{array1} and @var{array2} are one-dimensional arrays.  The procedure @var{=?} is used
to compare sequence tokens for equality.@refill

The non-negative integer @var{p-lim}, if provided, is maximum number of
deletions of the shorter sequence to allow.  @code{diff:longest-common-subsequence} will return @code{#f}
if more deletions would be necessary.@refill

@code{diff:longest-common-subsequence} returns a one-dimensional array of length @code{(quotient (- (+
len1 len2) (diff:edit-length @var{array1} @var{array2})) 2)} holding the longest sequence
common to both @var{array}s.@refill
@end defun

@defun diff:edits array1 array2 =? p-lim


@defunx diff:edits array1 array2 =?
@var{array1} and @var{array2} are one-dimensional arrays.  The procedure @var{=?} is used
to compare sequence tokens for equality.@refill

The non-negative integer @var{p-lim}, if provided, is maximum number of
deletions of the shorter sequence to allow.  @code{diff:edits} will return @code{#f}
if more deletions would be necessary.@refill

@code{diff:edits} returns a vector of length @code{(diff:edit-length @var{array1} @var{array2})} composed
of a shortest sequence of edits transformaing @var{array1} to @var{array2}.@refill

Each edit is an integer:@refill
@table @asis
@item @var{k} > 0
Inserts @code{(array-ref @var{array1} (+ -1 @var{j}))} into the sequence.@refill
@item @var{k} < 0
Deletes @code{(array-ref @var{array2} (- -1 @var{k}))} from the sequence.@refill
@end table
@end defun

@defun diff:edit-length array1 array2 =? p-lim


@defunx diff:edit-length array1 array2 =?
@var{array1} and @var{array2} are one-dimensional arrays.  The procedure @var{=?} is used
to compare sequence tokens for equality.@refill

The non-negative integer @var{p-lim}, if provided, is maximum number of
deletions of the shorter sequence to allow.  @code{diff:edit-length} will return @code{#f}
if more deletions would be necessary.@refill

@code{diff:edit-length} returns the length of the shortest sequence of edits transformaing
@var{array1} to @var{array2}.@refill
@end defun
@example
(diff:longest-common-subsequence "fghiejcklm" "fgehijkpqrlm" eqv?)
@result{} "fghijklm"

(diff:edit-length "fghiejcklm" "fgehijkpqrlm" eqv?)
@result{} 6

(diff:edits "fghiejcklm" "fgehijkpqrlm" eqv?)
@result{} #As32(3 -5 -7 8 9 10)
       ; e  c  h p q  r
@end example



@node Procedures, Standards Support, Sorting and Searching, Other Packages
@section Procedures

Anything that doesn't fall neatly into any of the other categories winds
up here.@refill

@menu
* Type Coercion::               'coerce
* String-Case::                 'string-case
* String Ports::                'string-port
* Line I/O::                    'line-i/o
* Multi-Processing::            'process
* Metric Units::                Portable manifest types for numeric values.
@end menu


@node Type Coercion, String-Case, Procedures, Procedures
@subsection Type Coercion
@code{(require 'coerce)}@refill
@ftindex coerce


@defun type-of obj

Returns a symbol name for the type of @var{obj}.@refill
@end defun

@defun coerce obj result-type

Converts and returns @var{obj} of type @code{char}, @code{number},
@code{string}, @code{symbol}, @code{list}, or @code{vector} to
@var{result-type} (which must be one of these symbols).@refill
@end defun


@node String-Case, String Ports, Type Coercion, Procedures
@subsection String-Case

@code{(require 'string-case)}@refill
@ftindex string-case

@deffn {Procedure} string-upcase str
@deffnx {Procedure} string-downcase str
@deffnx {Procedure} string-capitalize str
The obvious string conversion routines.  These are non-destructive.@refill
@end deffn

@defun string-upcase! str
@defunx string-downcase! str
@defunx string-capitalize! str
The destructive versions of the functions above.@refill
@end defun

@defun string-ci->symbol str
Converts string @var{str} to a symbol having the same case as if the
symbol had been @code{read}.@refill
@end defun

@defun symbol-append obj1 @dots{}
Converts @var{obj1} @dots{} to strings, appends them, and converts to a
symbol which is returned.  Strings and numbers are converted to read's
symbol case; the case of symbol characters is not changed.  #f is
converted to the empty string (symbol).@refill
@end defun

@defun StudlyCapsExpand str delimiter
@defunx StudlyCapsExpand str
@var{delimiter} must be a string or character.  If absent,
@var{delimiter} defaults to @samp{-}.  @code{StudlyCapsExpand} returns a
copy of @var{str} where @var{delimiter} is inserted between each
lower-case character immediately followed by an upper-case character;
and between two upper-case characters immediately followed by a
lower-case character.@refill

@example
(StudlyCapsExpand "aX" " ")   @result{} "a X"
(StudlyCapsExpand "aX" "..")  @result{} "a..X"
(StudlyCapsExpand "AX")       @result{} "AX"
(StudlyCapsExpand "Ax")       @result{} "Ax"
(StudlyCapsExpand "AXLE")     @result{} "AXLE"
(StudlyCapsExpand "aAXACz")   @result{} "a-AXA-Cz"
(StudlyCapsExpand "AaXACz")   @result{} "Aa-XA-Cz"
(StudlyCapsExpand "AAaXACz")  @result{} "A-Aa-XA-Cz"
(StudlyCapsExpand "AAaXAC")   @result{} "A-Aa-XAC"
@end example

@end defun



@node String Ports, Line I/O, String-Case, Procedures
@subsection String Ports

@code{(require 'string-port)}@refill
@ftindex string-port

@deffn {Procedure} call-with-output-string proc
@var{proc} must be a procedure of one argument.  This procedure calls
@var{proc} with one argument: a (newly created) output port.  When the
function returns, the string composed of the characters written into the
port is returned.@refill
@end deffn

@deffn {Procedure} call-with-input-string string proc
@var{proc} must be a procedure of one argument.  This procedure calls
@var{proc} with one argument: an (newly created) input port from which
@var{string}'s contents may be read.  When @var{proc} returns, the port
is closed and the value yielded by the procedure @var{proc} is
returned.@refill
@end deffn


@node Line I/O, Multi-Processing, String Ports, Procedures
@subsection Line I/O

@code{(require 'line-i/o)}@refill
@ftindex line-i


@defun read-line


@defunx read-line port
Returns a string of the characters up to, but not including a
newline or end of file, updating @var{port} to point to the
character following the newline.  If no characters are available, an
end of file object is returned.  The @var{port} argument may be
omitted, in which case it defaults to the value returned by
@code{current-input-port}.@refill
@end defun

@deffn {Procedure} read-line! string


@deffnx {Procedure} read-line! string port
Fills @var{string} with characters up to, but not including a newline or end
of file, updating the @var{port} to point to the last character read
or following the newline if it was read.  If no characters are
available, an end of file object is returned.  If a newline or end
of file was found, the number of characters read is returned.
Otherwise, @code{#f} is returned.  The @var{port} argument may be
omitted, in which case it defaults to the value returned by
@code{current-input-port}.@refill
@end deffn

@defun write-line string


@defunx write-line string port
Writes @var{string} followed by a newline to the given @var{port} and returns
an unspecified value.  The @var{Port} argument may be omitted, in
which case it defaults to the value returned by
@code{current-input-port}.@refill
@end defun

@defun system->line command tmp


@defunx system->line command
@var{command} must be a string.  The string @var{tmp}, if supplied, is a path to use as
a temporary file.  @code{system->line} calls @code{system} with @var{command} as argument,
redirecting stdout to file @var{tmp}.  @code{system->line} returns a string containing the
first line of output from @var{tmp}.@refill
@end defun


@node Multi-Processing, Metric Units, Line I/O, Procedures
@subsection Multi-Processing

@code{(require 'process)}@refill
@ftindex process

This module implements asynchronous (non-polled) time-sliced
multi-processing in the SCM Scheme implementation using procedures
@code{alarm} and @code{alarm-interrupt}.@refill
@cindex alarm
@cindex alarm-interrupt
Until this is ported to another implementation, consider it an example
of writing schedulers in Scheme.@refill

@deffn {Procedure} add-process! proc
Adds proc, which must be a procedure (or continuation) capable of
accepting accepting one argument, to the @code{process:queue}.  The
value returned is unspecified.  The argument to @var{proc} should be
ignored.  If @var{proc} returns, the process is killed.@refill
@end deffn

@deffn {Procedure} process:schedule!
Saves the current process on @code{process:queue} and runs the next
process from @code{process:queue}.  The value returned is
unspecified.@refill
@end deffn

@deffn {Procedure} kill-process!
Kills the current process and runs the next process from
@code{process:queue}.  If there are no more processes on
@code{process:queue}, @code{(slib:exit)} is called (@pxref{System}).@refill
@end deffn


@node Metric Units,  , Multi-Processing, Procedures
@subsection Metric Units

@code{(require 'metric-units)}@refill
@ftindex metric-units

@url{http://swissnet.ai.mit.edu/~jaffer/MIXF.html}@refill

@dfn{Metric Interchange Format} is a character string encoding for
numerical values and units which:@refill

@itemize @bullet
@item
is unambiguous in all locales;@refill

@item
uses only [TOG] "Portable Character Set" characters matching "Basic
Latin" characters in Plane 0 of the Universal Character Set [UCS];@refill

@item
is transparent to [UTF-7] and [UTF-8] UCS transformation formats;@refill

@item
is human readable and writable;@refill

@item
is machine readable and writable;@refill

@item
incorporates SI prefixes and units;@refill

@item
incorporates [ISO 6093] numbers; and@refill

@item
incorporates [IEC 60027-2] binary prefixes.@refill
@end itemize

In the expression for the value of a quantity, the unit symbol is placed
after the numerical value.  A dot (PERIOD, @samp{.}) is placed between
the numerical value and the unit symbol.@refill

Within a compound unit, each of the base and derived symbols can
optionally have an attached SI prefix.@refill

Unit symbols formed from other unit symbols by multiplication are
indicated by means of a dot (PERIOD, @samp{.}) placed between them.@refill

Unit symbols formed from other unit symbols by division are indicated by
means of a SOLIDUS (@samp{/}) or negative exponents.  The SOLIDUS must
not be repeated in the same compound unit unless contained within a
parenthesized subexpression.@refill

The grouping formed by a prefix symbol attached to a unit symbol
constitutes a new inseparable symbol (forming a multiple or submultiple
of the unit concerned) which can be raised to a positive or negative
power and which can be combined with other unit symbols to form compound
unit symbols.@refill

The grouping formed by surrounding compound unit symbols with
parentheses (@samp{(} and @samp{)}) constitutes a new inseparable symbol
which can be raised to a positive or negative power and which can be
combined with other unit symbols to form compound unit symbols.@refill

Compound prefix symbols, that is, prefix symbols formed by the
juxtaposition of two or more prefix symbols, are not permitted.@refill

Prefix symbols are not used with the time-related unit symbols min
(minute), h (hour), d (day).  No prefix symbol may be used with dB
(decibel).  Only submultiple prefix symbols may be used with the unit
symbols L (liter), Np (neper), o (degree), oC (degree Celsius), rad
(radian), and sr (steradian).  Submultiple prefix symbols may not be
used with the unit symbols t (metric ton), r (revolution), or Bd (baud).@refill

A unit exponent follows the unit, separated by a CIRCUMFLEX (@samp{^}).
Exponents may be positive or negative.  Fractional exponents must be
parenthesized.@refill

@subsubsection SI Prefixes
@example
       Factor     Name    Symbol  |  Factor     Name    Symbol
       ======     ====    ======  |  ======     ====    ======
        1e24      yotta      Y    |   1e-1      deci       d
        1e21      zetta      Z    |   1e-2      centi      c
        1e18      exa        E    |   1e-3      milli      m
        1e15      peta       P    |   1e-6      micro      u
        1e12      tera       T    |   1e-9      nano       n
        1e9       giga       G    |   1e-12     pico       p
        1e6       mega       M    |   1e-15     femto      f
        1e3       kilo       k    |   1e-18     atto       a
        1e2       hecto      h    |   1e-21     zepto      z
        1e1       deka       da   |   1e-24     yocto      y
@end example

@subsubsection Binary Prefixes

These binary prefixes are valid only with the units B (byte) and bit.
However, decimal prefixes can also be used with bit; and decimal
multiple (not submultiple) prefixes can also be used with B (byte).@refill

@example
                Factor       (power-of-2)  Name  Symbol
                ======       ============  ====  ======
       1.152921504606846976e18  (2^60)     exbi    Ei
          1.125899906842624e15  (2^50)     pebi    Pi
             1.099511627776e12  (2^40)     tebi    Ti
                1.073741824e9   (2^30)     gibi    Gi
                   1.048576e6   (2^20)     mebi    Mi
                      1.024e3   (2^10)     kibi    Ki
@end example

@subsubsection Unit Symbols

@example
    Type of Quantity      Name          Symbol   Equivalent
    ================      ====          ======   ==========
time                      second           s
time                      minute           min = 60.s
time                      hour             h   = 60.min
time                      day              d   = 24.h
frequency                 hertz            Hz    s^-1
signaling rate            baud             Bd    s^-1
length                    meter            m
volume                    liter            L     dm^3
plane angle               radian           rad
solid angle               steradian        sr    rad^2
plane angle               revolution     * r   = 6.283185307179586.rad
plane angle               degree         * o   = 2.777777777777778e-3.r
information capacity      bit              bit
information capacity      byte, octet      B   = 8.bit
mass                      gram             g
mass                      ton              t     Mg
mass              unified atomic mass unit u   = 1.66053873e-27.kg
amount of substance       mole             mol
catalytic activity        katal            kat   mol/s
thermodynamic temperature kelvin           K
centigrade temperature    degree Celsius   oC
luminous intensity        candela          cd
luminous flux             lumen            lm    cd.sr
illuminance               lux              lx    lm/m^2
force                     newton           N     m.kg.s^-2
pressure, stress          pascal           Pa    N/m^2
energy, work, heat        joule            J     N.m
energy                    electronvolt     eV  = 1.602176462e-19.J
power, radiant flux       watt             W     J/s
logarithm of power ratio  neper            Np
logarithm of power ratio  decibel        * dB  = 0.1151293.Np
electric current          ampere           A
electric charge           coulomb          C     s.A
electric potential, EMF   volt             V     W/A
capacitance               farad            F     C/V
electric resistance       ohm              Ohm   V/A
electric conductance      siemens          S     A/V
magnetic flux             weber            Wb    V.s
magnetic flux density     tesla            T     Wb/m^2
inductance                henry            H     Wb/A
radionuclide activity     becquerel        Bq    s^-1
absorbed dose energy      gray             Gy    m^2.s^-2
dose equivalent           sievert          Sv    m^2.s^-2
@end example

* The formulas are:@refill

@itemize @bullet
@item
r/rad = 8 * atan(1)@refill
@item
o/r = 1 / 360@refill
@item
db/Np = ln(10) / 20@refill
@end itemize

@defun si:conversion-factor to-unit from-unit
If the strings @var{from-unit} and @var{to-unit} express valid unit
expressions for quantities of the same unit-dimensions, then the value
returned by @code{si:conversion-factor} will be such that multiplying a
numerical value expressed in @var{from-unit}s by the returned conversion
factor yields the numerical value expressed in @var{to-unit}s.@refill

Otherwise, @code{si:conversion-factor} returns:@refill

@table @asis
@item -3
if neither @var{from-unit} nor @var{to-unit} is a syntactically valid
unit.@refill
@item -2
if @var{from-unit} is not a syntactically valid unit.@refill
@item -1
if @var{to-unit} is not a syntactically valid unit.@refill
@item 0
if linear conversion (by a factor) is not possible.@refill
@end table

@end defun

@example
(si:conversion-factor "km/s" "m/s" ) @result{} 0.001     
(si:conversion-factor "N"    "m/s" ) @result{} 0         
(si:conversion-factor "moC"  "oC"  ) @result{} 1000      
(si:conversion-factor "mK"   "oC"  ) @result{} 0         
(si:conversion-factor "rad"  "o"   ) @result{} 0.0174533 
(si:conversion-factor "K"    "o"   ) @result{} 0         
(si:conversion-factor "K"    "K"   ) @result{} 1         
(si:conversion-factor "oK"   "oK"  ) @result{} -3        
(si:conversion-factor ""     "s/s" ) @result{} 1         
(si:conversion-factor "km/h" "mph" ) @result{} -2        
@end example


@node Standards Support, Session Support, Procedures, Other Packages
@section Standards Support



@menu
* RnRS::                        Revised Reports on Scheme
* With-File::                   'with-file
* Transcripts::                 'transcript
* Rev2 Procedures::             'rev2-procedures
* Rev4 Optional Procedures::    'rev4-optional-procedures
* Multi-argument / and -::      'multiarg/and-
* Multi-argument Apply::        'multiarg-apply
* Rationalize::                 'rationalize
* Promises::                    'delay
* Dynamic-Wind::                'dynamic-wind
* Eval::                        'eval
* Values::                      'values
* SRFI::                        'http://srfi.schemers.org/srfi-0/srfi-0.html
@end menu

@node RnRS, With-File, Standards Support, Standards Support
@subsection RnRS

@noindent
The @code{r2rs}, @code{r3rs}, @code{r4rs}, and @code{r5rs} features
attempt to provide procedures and macros to bring a Scheme
implementation to the desired version of Scheme.@refill

@deftp {Feature} r2rs
@ftindex r2rs
Requires features implementing procedures and optional procedures
specified by @cite{Revised^2 Report on the Algorithmic Language Scheme};
namely @code{rev3-procedures} and @code{rev2-procedures}.@refill
@end deftp

@deftp {Feature} r3rs
@ftindex r3rs
Requires features implementing procedures and optional procedures
specified by @cite{Revised^3 Report on the Algorithmic Language Scheme};
namely @code{rev3-procedures}.@refill

@emph{Note:} SLIB already mandates the @code{r3rs} procedures which can
be portably implemented in @code{r4rs} implementations.@refill
@end deftp

@deftp {Feature} r4rs
@ftindex r4rs
Requires features implementing procedures and optional procedures
specified by @cite{Revised^4 Report on the Algorithmic Language Scheme};
namely @code{rev4-optional-procedures}.@refill
@end deftp

@deftp {Feature} r5rs
@ftindex r5rs
Requires features implementing procedures and optional procedures
specified by @cite{Revised^5 Report on the Algorithmic Language Scheme};
namely @code{values}, @code{macro}, and @code{eval}.@refill
@end deftp


@node With-File, Transcripts, RnRS, Standards Support
@subsection With-File

@code{(require 'with-file)}@refill
@ftindex with-file

@defun with-input-from-file file thunk
@defunx with-output-to-file file thunk
Description found in R4RS.@refill
@end defun

@node Transcripts, Rev2 Procedures, With-File, Standards Support
@subsection Transcripts

@code{(require 'transcript)}@refill
@ftindex transcript

@defun transcript-on filename
@defunx transcript-off filename
Redefines @code{read-char}, @code{read}, @code{write-char},
@code{write}, @code{display}, and @code{newline}.@refill
@end defun





@node Rev2 Procedures, Rev4 Optional Procedures, Transcripts, Standards Support
@subsection Rev2 Procedures

@code{(require 'rev2-procedures)}@refill
@ftindex rev2-procedures

The procedures below were specified in the @cite{Revised^2 Report on
Scheme}.  @strong{N.B.}: The symbols @code{1+} and @code{-1+} are not
@cite{R4RS} syntax.  Scheme->C, for instance, chokes on this
module.@refill

@deffn {Procedure} substring-move-left! string1 start1 end1 string2 start2
@deffnx {Procedure} substring-move-right! string1 start1 end1 string2 start2
@var{string1} and @var{string2} must be a strings, and @var{start1},
@var{start2} and @var{end1} must be exact integers satisfying@refill

@display
0 <= @var{start1} <= @var{end1} <= (string-length @var{string1})
0 <= @var{start2} <= @var{end1} - @var{start1} + @var{start2} <= (string-length @var{string2})
@end display

@code{substring-move-left!} and @code{substring-move-right!} store
characters of @var{string1} beginning with index @var{start1}
(inclusive) and ending with index @var{end1} (exclusive) into
@var{string2} beginning with index @var{start2} (inclusive).@refill

@code{substring-move-left!} stores characters in time order of
increasing indices.  @code{substring-move-right!} stores characters in
time order of increasing indeces.@refill
@end deffn

@deffn {Procedure} substring-fill! string start end char
Fills the elements @var{start}--@var{end} of @var{string} with the
character @var{char}.@refill
@end deffn

@defun string-null? str
@equiv{} @code{(= 0 (string-length @var{str}))}@refill
@end defun

@deffn {Procedure} append! pair1 @dots{}
Destructively appends its arguments.  Equivalent to @code{nconc}.@refill
@end deffn

@defun 1+ n
Adds 1 to @var{n}.@refill
@end defun

@defun -1+ n
Subtracts 1 from @var{n}.@refill
@end defun

@defun <?
@defunx <=?
@defunx =?
@defunx >?
@defunx >=?
These are equivalent to the procedures of the same name but without the
trailing @samp{?}.@refill
@end defun



@node Rev4 Optional Procedures, Multi-argument / and -, Rev2 Procedures, Standards Support
@subsection Rev4 Optional Procedures

@code{(require 'rev4-optional-procedures)}@refill
@ftindex rev4-optional-procedures

For the specification of these optional procedures,
@xref{Standard procedures, , ,r4rs, Revised(4) Scheme}.@refill

@defun list-tail l p
@end defun

@defun string->list s
@end defun

@defun list->string l
@end defun

@defun string-copy
@end defun

@deffn {Procedure} string-fill! s obj
@end deffn

@defun list->vector l
@end defun

@defun vector->list s
@end defun

@deffn {Procedure} vector-fill! s obj
@end deffn





@node Multi-argument / and -, Multi-argument Apply, Rev4 Optional Procedures, Standards Support
@subsection Multi-argument / and -

@code{(require 'multiarg/and-)}@refill
@ftindex multiarg

For the specification of these optional forms, @xref{Numerical
operations, , ,r4rs, Revised(4) Scheme}.@refill

@defun / dividend divisor1 @dots{}
@end defun

@defun - minuend subtrahend1 @dots{}
@end defun





@node Multi-argument Apply, Rationalize, Multi-argument / and -, Standards Support
@subsection Multi-argument Apply

@code{(require 'multiarg-apply)}@refill
@ftindex multiarg-apply

@noindent
For the specification of this optional form,
@xref{Control features, , ,r4rs, Revised(4) Scheme}.@refill

@defun apply proc arg1 @dots{}
@end defun



@node Rationalize, Promises, Multi-argument Apply, Standards Support
@subsection Rationalize

@code{(require 'rationalize)}@refill
@ftindex rationalize


@defun rationalize x e

Computes the correct result for exact arguments (provided the
implementation supports exact rational numbers of unlimited precision);
and produces a reasonable answer for inexact arguments when inexact
arithmetic is implemented using floating-point.@refill

@end defun
@code{Rationalize} has limited use in implementations lacking exact
(non-integer) rational numbers.  The following procedures return a list
of the numerator and denominator.@refill


@defun find-ratio x e

@code{find-ratio} returns the list of the @emph{simplest}
numerator and denominator whose quotient differs from @var{x} by no more
than @var{e}.@refill

@format
@t{(find-ratio 3/97 .0001)             @result{} (3 97)
(find-ratio 3/97 .001)              @result{} (1 32)
}
@end format
@end defun

@defun find-ratio-between x y

@code{find-ratio-between} returns the list of the @emph{simplest}
numerator and denominator between @var{x} and @var{y}.@refill

@format
@t{(find-ratio-between 2/7 3/5)        @result{} (1 2)
(find-ratio-between -3/5 -2/7)      @result{} (-1 2)
}
@end format
@end defun



@node Promises, Dynamic-Wind, Rationalize, Standards Support
@subsection Promises

@code{(require 'promise)}@refill
@ftindex promise

@defun make-promise proc
@end defun

@defun force promise
@end defun

@code{(require 'delay)} provides @code{force} and @code{delay}:@refill

@defmac delay obj
Change occurrences of @code{(delay @var{expression})} to@refill

@example
(make-promise (lambda () @var{expression}))
@end example

@end defmac

(@pxref{Control features, , ,r4rs, Revised(4) Scheme}).@refill


@node Dynamic-Wind, Eval, Promises, Standards Support
@subsection Dynamic-Wind

@code{(require 'dynamic-wind)}@refill
@ftindex dynamic-wind

This facility is a generalization of Common LISP @code{unwind-protect},
designed to take into account the fact that continuations produced by
@code{call-with-current-continuation} may be reentered.@refill

@deffn {Procedure} dynamic-wind thunk1 thunk2 thunk3
The arguments @var{thunk1}, @var{thunk2}, and @var{thunk3} must all be
procedures of no arguments (thunks).@refill

@code{dynamic-wind} calls @var{thunk1}, @var{thunk2}, and then
@var{thunk3}.  The value returned by @var{thunk2} is returned as the
result of @code{dynamic-wind}.  @var{thunk3} is also called just before
control leaves the dynamic context of @var{thunk2} by calling a
continuation created outside that context.  Furthermore, @var{thunk1} is
called before reentering the dynamic context of @var{thunk2} by calling
a continuation created inside that context.  (Control is inside the
context of @var{thunk2} if @var{thunk2} is on the current return stack).@refill

@strong{Warning:} There is no provision for dealing with errors or
interrupts.  If an error or interrupt occurs while using
@code{dynamic-wind}, the dynamic environment will be that in effect at
the time of the error or interrupt.@refill
@end deffn


@node Eval, Values, Dynamic-Wind, Standards Support
@subsection Eval

@code{(require 'eval)}@refill
@ftindex eval

@defun eval expression environment-specifier

Evaluates @var{expression} in the specified environment and returns its
value.  @var{Expression} must be a valid Scheme expression represented
as data, and @var{environment-specifier} must be a value returned by one
of the three procedures described below.  Implementations may extend
@code{eval} to allow non-expression programs (definitions) as the first
argument and to allow other values as environments, with the restriction
that @code{eval} is not allowed to create new bindings in the
environments associated with @code{null-environment} or
@code{scheme-report-environment}.@refill

@lisp
(eval '(* 7 3) (scheme-report-environment 5))
                                                   @result{}  21

(let ((f (eval '(lambda (f x) (f x x))
               (null-environment))))
  (f + 10))
                                                   @result{}  20
@end lisp
@end defun

@defun scheme-report-environment version
@defunx null-environment version
@defunx null-environment

@var{Version} must be an exact non-negative integer @var{n}
corresponding to a version of one of the Revised^@var{n} Reports on
Scheme.  @code{Scheme-report-environment} returns a specifier for an
environment that contains the set of bindings specified in the
corresponding report that the implementation supports.
@code{Null-environment} returns a specifier for an environment that
contains only the (syntactic) bindings for all the syntactic keywords
defined in the given version of the report.@refill

Not all versions may be available in all implementations at all times.
However, an implementation that conforms to version @var{n} of the
Revised^@var{n} Reports on Scheme must accept version @var{n}.  An error
is signalled if the specified version is not available.@refill

The effect of assigning (through the use of @code{eval}) a variable
bound in a @code{scheme-report-environment} (for example @code{car}) is
unspecified. Thus the environments specified by
@code{scheme-report-environment} may be immutable.@refill

@end defun

@defun interaction-environment

This optional procedure returns a specifier for the environment that
contains implementation-defined bindings, typically a superset of those
listed in the report.  The intent is that this procedure will return the
environment in which the implementation would evaluate expressions
dynamically typed by the user.@refill
@end defun

@noindent
Here are some more @code{eval} examples:@refill

@example
(require 'eval)
@result{} #<unspecified>
(define car 'volvo)
@result{} #<unspecified>
car
@result{} volvo
(eval 'car (interaction-environment))
@result{} volvo
(eval 'car (scheme-report-environment 5))
@result{} #<primitive-procedure car>
(eval '(eval 'car (interaction-environment))
      (scheme-report-environment 5))
@result{} volvo
(eval '(eval '(set! car 'buick) (interaction-environment))
      (scheme-report-environment 5))
@result{} #<unspecified>
car
@result{} buick
(eval 'car (scheme-report-environment 5))
@result{} #<primitive-procedure car>
(eval '(eval 'car (interaction-environment))
      (scheme-report-environment 5))
@result{} buick
@end example


@node Values, SRFI, Eval, Standards Support
@subsection Values

@code{(require 'values)}@refill
@ftindex values

@defun values obj @dots{}
@code{values} takes any number of arguments, and passes (returns) them
to its continuation.@refill
@end defun


@defun call-with-values thunk proc
@var{thunk} must be a procedure of no arguments, and @var{proc} must be
a procedure.  @code{call-with-values} calls @var{thunk} with a
continuation that, when passed some values, calls @var{proc} with those
values as arguments.@refill

Except for continuations created by the @code{call-with-values}
procedure, all continuations take exactly one value, as now; the effect
of passing no value or more than one value to continuations that were
not created by the @code{call-with-values} procedure is
unspecified.@refill
@end defun

@node SRFI,  , Values, Standards Support
@subsection SRFI

@code{(require 'srfi)}@refill
@ftindex srfi

@noindent Implements @dfn{Scheme Request For Implementation} (SRFI) as
@cindex Scheme Request For Implementation
described at @url{http://srfi.schemers.org/}@refill

@noindent The Copyright terms of each SRFI states:
@quotation
"However, this document itself may not be modified in any way, ..."@refill
@end quotation

@noindent Therefore, the specification of SRFI constructs must not be
quoted without including the complete SRFI document containing
discussion and a sample implementation program.@refill


@defmac cond-expand <clause1> <clause2> @dots{}


@emph{Syntax:}
Each @r{<clause>} should be of the form@refill

@format
@t{(@r{<feature>} @r{<expression1>} @dots{})}
@end format

where @r{<feature>} is a boolean expression composed of symbols and
`and', `or', and `not' of boolean expressions.  The last @r{<clause>}
may be an "else clause," which has the form@refill

@format
@t{(else @r{<expression1>} @r{<expression2>} @dots{})@r{.}}
@end format

The first clause whose feature expression is satisfied is expanded.
If no feature expression is satisfied and there is no else clause, an
error is signaled.@refill

SLIB @code{cond-expand} is an extension of SRFI-0,
@url{http://srfi.schemers.org/srfi-0/srfi-0.html}.@refill
@end defmac

@menu
* SRFI-1::                      list-processing
* SRFI-2::                      guarded LET* special form
* SRFI-8::                      Binding to multiple values
* SRFI-9::                      Defining Record Types
@end menu

@node SRFI-1, SRFI-2, SRFI, SRFI
@subsubsection SRFI-1

@code{(require 'srfi-1)}@refill
@ftindex srfi-1

@noindent
Implements the @dfn{SRFI-1} @dfn{list-processing library} as described@refill
@cindex SRFI-1
@cindex list-processing library
at @url{http://srfi.schemers.org/srfi-1/srfi-1.html}@refill

@subheading Constructors


@defun xcons d a
@code{(define (xcons d a) (cons a d))}.@refill
@end defun

@defun list-tabulate len proc
Returns a list of length @var{len}.  Element @var{i} is @code{(@var{proc}
@var{i})} for 0 <= @var{i} < @var{len}.@refill
@end defun

@defun cons* obj1 obj2

@end defun

@defun list-copy flist

@end defun

@defun iota count start step


@defunx iota count start

@defunx iota count
Returns a list of @var{count} numbers: (@var{start}, @var{start}+@var{step}, @dots{},  @var{start}+(@var{count}-1)*@var{step}).@refill
@end defun

@defun circular-list obj1 obj2 @dots{}

Returns a circular list of @var{obj1}, @var{obj2}, @dots{}.@refill
@end defun
@subheading Predicates


@defun proper-list? obj

@end defun

@defun circular-list? x

@end defun

@defun dotted-list? obj

@end defun

@defun null-list? obj

@end defun

@defun not-pair? obj

@end defun

@defun list= =pred list @dots{}

@end defun
@subheading Selectors


@defun first pair

@end defun

@defun second pair

@end defun

@defun third pair

@end defun

@defun fourth pair

@end defun

@defun fifth pair
@defunx sixth obj
@defunx seventh obj
@defunx eighth obj
@defunx ninth obj
@defunx tenth obj

@end defun

@defun car+cdr pair

@end defun

@defun drop lst k
@defunx take lst k

@end defun

@deffn {Procedure} take! lst k

@end deffn

@defun take-right lst k

@end defun

@defun drop-right lst k

@end defun

@deffn {Procedure} drop-right! lst k

@end deffn

@defun split-at lst k

@end defun

@deffn {Procedure} split-at! lst k

@end deffn

@defun last lst

(car (last-pair lst))@refill
@end defun
@subheading Miscellaneous


@defun length+ obj

@end defun

@defun concatenate lists
@defunx concatenate! lists

@end defun

@deffn {Procedure} reverse! lst

@end deffn

@defun append-reverse rev-head tail
@defunx append-reverse! rev-head tail

@end defun

@defun zip list1 list2 @dots{}

@end defun

@defun unzip1 lst
@defunx unzip2 lst
@defunx unzip3 lst
@defunx unzip4 lst
@defunx unzip5 lst

@end defun

@defun count pred list1 list2 @dots{}

@end defun
@subheading Fold and Unfold


@deffn {Procedure} map! f list1 clist2 @dots{}

@end deffn

@defun pair-for-each f clist1 clist2 @dots{}

@end defun
@subheading Filtering and Partitioning


@defun filter pred lis

@end defun

@deffn {Procedure} filter! pred l

@end deffn

@defun partition pred list

@end defun
@subheading Searching


@defun find pred list

@end defun

@defun find-tail pred list

@end defun

@defun remove pred l

@end defun

@deffn {Procedure} remove! pred l

@end deffn

@defun any pred clist1 clist2 @dots{}

@end defun

@defun list-index pred clist1 clist2 @dots{}

@end defun

@defun span pred list

@end defun

@defun member obj list pred


@defunx member obj list

@code{member} returns the first sublist of @var{list} whose car is @var{obj}, where the sublists
of @var{list} are the non-empty lists returned by @t{(list-tail @var{list} @var{k})}
for @var{k} less than the length of @var{list}.  If @var{obj} does not occur in @var{list},
then @t{#f} (not the empty list) is returned.  The procedure @var{pred} is
used for testing equality.  If @var{pred} is not provided, @samp{equal?} is
used.@refill
@end defun
@subheading Deleting

@subheading Association lists


@defun assoc obj alist pred


@defunx assoc obj alist

@var{alist} (for "association list") must be a list of pairs.  These
procedures find the first pair in @var{alist} whose car field is @var{obj}, and
returns that pair.  If no pair in @var{alist} has @var{obj} as its car, then @t{#f}
(not the empty list) is returned.  The procedure @var{pred} is used for
testing equality.  If @var{pred} is not provided, @samp{equal?} is used.@refill
@end defun
@subheading Set operations


@node SRFI-2, SRFI-8, SRFI-1, SRFI
@subsubsection SRFI-2

@code{(require 'srfi-2)}@refill
@ftindex srfi-2


@defmac and-let* claws body @dots{}

@url{http://srfi.schemers.org/srfi-2/srfi-2.html}@refill
@end defmac

@node SRFI-8, SRFI-9, SRFI-2, SRFI
@subsubsection SRFI-8

@code{(require 'srfi-8)}@refill
@ftindex srfi-8


@defspec receive formals expression body @dots{}

@url{http://srfi.schemers.org/srfi-8/srfi-8.html}@refill
@end defspec

@node SRFI-9,  , SRFI-8, SRFI
@subsubsection SRFI-9

@code{(require 'srfi-9)}@refill
@ftindex srfi-9

@url{http://srfi.schemers.org/srfi-9/srfi-9.html}@refill

@defspec define-record-type <type-name> (<constructor-name> <field-tag> ...) <predicate-name> <field spec> ...

Where@refill
@lisp
<field-spec> @equiv{} (<field-tag> <accessor-name>)
             @equiv{} (<field-tag> <accessor-name> <modifier-name>)

@end lisp

@code{define-record-type} is a syntax wrapper for the SLIB
@code{record} module.@refill
@end defspec


@node Session Support, System Interface, Standards Support, Other Packages
@section Session Support

@menu
* Repl::                        Macros at top-level
* Quick Print::                 Loop-safe Output
* Debug::                       To err is human ...
* Breakpoints::                 Pause execution
* Trace::                       'trace
@end menu


@node Repl, Quick Print, Session Support, Session Support
@subsection Repl

@code{(require 'repl)}@refill
@ftindex repl

Here is a read-eval-print-loop which, given an eval, evaluates forms.@refill

@deffn {Procedure} repl:top-level repl:eval
@code{read}s, @code{repl:eval}s and @code{write}s expressions from
@code{(current-input-port)} to @code{(current-output-port)} until an
end-of-file is encountered.  @code{load}, @code{slib:eval},
@code{slib:error}, and @code{repl:quit} dynamically bound during
@code{repl:top-level}.@refill
@end deffn

@deffn {Procedure} repl:quit
Exits from the invocation of @code{repl:top-level}.@refill
@end deffn

The @code{repl:} procedures establish, as much as is possible to do
portably, a top level environment supporting macros.
@code{repl:top-level} uses @code{dynamic-wind} to catch error conditions
and interrupts.  If your implementation supports this you are all set.@refill

Otherwise, if there is some way your implementation can catch error
conditions and interrupts, then have them call @code{slib:error}.  It
will display its arguments and reenter @code{repl:top-level}.
@code{slib:error} dynamically bound by @code{repl:top-level}.@refill

To have your top level loop always use macros, add any interrupt
catching lines and the following lines to your Scheme init file:@refill
@lisp
(require 'macro)
@ftindex macro
(require 'repl)
@ftindex repl
(repl:top-level macro:eval)
@end lisp

@node Quick Print, Debug, Repl, Session Support
@subsection Quick Print

@code{(require 'qp)}@refill
@ftindex qp

@noindent
When displaying error messages and warnings, it is paramount that the
output generated for circular lists and large data structures be
limited.  This section supplies a procedure to do this.  It could be
much improved.@refill

@quotation
Notice that the neccessity for truncating output eliminates
Common-Lisp's @ref{Format} from consideration; even when variables
@code{*print-level*} and @code{*print-level*} are set, huge strings and
bit-vectors are @emph{not} limited.@refill
@end quotation

@deffn {Procedure} qp arg1 @dots{}
@deffnx {Procedure} qpn arg1 @dots{}
@deffnx {Procedure} qpr arg1 @dots{}
@code{qp} writes its arguments, separated by spaces, to
@code{(current-output-port)}.  @code{qp} compresses printing by
substituting @samp{...} for substructure it does not have sufficient
room to print.  @code{qpn} is like @code{qp} but outputs a newline
before returning.  @code{qpr} is like @code{qpn} except that it returns
its last argument.@refill
@end deffn

@defvar *qp-width*
@var{*qp-width*} is the largest number of characters that @code{qp}
should use.  If @var{*qp-width*} is #f, then all items will be
@code{write}n.  If @var{*qp-width*} is 0, then all items except
procedures will be @code{write}n; procedures will be indicated by
@samp{#[proc]}.@refill
@end defvar

@node Debug, Breakpoints, Quick Print, Session Support
@subsection Debug

@code{(require 'debug)}@refill
@ftindex debug

@noindent
Requiring @code{debug} automatically requires @code{trace} and
@code{break}.@refill

@noindent
An application with its own datatypes may want to substitute its own
printer for @code{qp}.  This example shows how to do this:@refill

@example
(define qpn (lambda args) @dots{})
(provide 'qp)
(require 'debug)
@ftindex debug
@end example

@deffn {Procedure} trace-all file @dots{}
Traces (@pxref{Trace}) all procedures @code{define}d at top-level in
@file{file} @dots{}.@refill

@deffnx {Procedure} track-all file @dots{}
Tracks (@pxref{Trace}) all procedures @code{define}d at top-level in
@file{file} @dots{}.@refill

@deffnx {Procedure} stack-all file @dots{}
Stacks (@pxref{Trace}) all procedures @code{define}d at top-level in
@file{file} @dots{}.@refill
@end deffn

@deffn {Procedure} break-all file @dots{}
Breakpoints (@pxref{Breakpoints}) all procedures @code{define}d at
top-level in @file{file} @dots{}.@refill
@end deffn

@node Breakpoints, Trace, Debug, Session Support
@subsection Breakpoints

@code{(require 'break)}@refill
@ftindex break

@defun init-debug
If your Scheme implementation does not support @code{break} or
@code{abort}, a message will appear when you @code{(require 'break)} or@refill
@ftindex break
@code{(require 'debug)} telling you to type @code{(init-debug)}.  This@refill
@ftindex debug
is in order to establish a top-level continuation.  Typing
@code{(init-debug)} at top level sets up a continuation for
@code{break}.@refill
@end defun

@defun breakpoint arg1 @dots{}
Returns from the top level continuation and pushes the continuation from
which it was called on a continuation stack.@refill
@end defun

@defun continue
Pops the topmost continuation off of the continuation stack and returns
an unspecified value to it.@refill

@defunx continue arg1 @dots{}
Pops the topmost continuation off of the continuation stack and returns
@var{arg1} @dots{} to it.@refill
@end defun

@defmac break proc1 @dots{}
Redefines the top-level named procedures given as arguments so that
@code{breakpoint} is called before calling @var{proc1} @dots{}.@refill
@defmacx break
With no arguments, makes sure that all the currently broken identifiers
are broken (even if those identifiers have been redefined) and returns a
list of the broken identifiers.@refill
@end defmac

@defmac unbreak proc1 @dots{}
Turns breakpoints off for its arguments.@refill
@defmacx unbreak
With no arguments, unbreaks all currently broken identifiers and returns
a list of these formerly broken identifiers.@refill
@end defmac

These are @emph{procedures} for breaking.  If defmacros are not natively
supported by your implementation, these might be more convenient to use.@refill

@defun breakf proc
@defunx breakf proc name
To break, type@refill
@lisp
(set! @var{symbol} (breakf @var{symbol}))
@end lisp
@noindent
or@refill
@lisp
(set! @var{symbol} (breakf @var{symbol} '@var{symbol}))
@end lisp
@noindent
or@refill
@lisp
(define @var{symbol} (breakf @var{function}))
@end lisp
@noindent
or@refill
@lisp
(define @var{symbol} (breakf @var{function} '@var{symbol}))
@end lisp
@end defun

@defun unbreakf proc
To unbreak, type@refill
@lisp
(set! @var{symbol} (unbreakf @var{symbol}))
@end lisp
@end defun

@node Trace,  , Breakpoints, Session Support
@subsection Tracing

@code{(require 'trace)}@refill
@ftindex trace

@noindent
This feature provides three ways to monitor procedure invocations:@refill

@table @asis
@item stack
Pushes the procedure-name when the procedure is called; pops when it
returns.@refill
@item track
Pushes the procedure-name and arguments when the procedure is called;
pops when it returns.@refill
@item trace
Pushes the procedure-name and prints @samp{CALL @var{procedure-name}
@var{arg1} @dots{}} when the procdure is called; pops and prints
@samp{RETN @var{procedure-name} @var{value}} when the procedure returns.@refill
@end table

@defvar debug:max-count
If a traced procedure calls itself or untraced procedures which call it,
stack, track, and trace will limit the number of stack pushes to
@var{debug:max-count}.@refill
@end defvar

@defun print-call-stack
@defunx print-call-stack port
Prints the call-stack to @var{port} or the current-error-port.@refill
@end defun


@defmac trace proc1 @dots{}
Traces the top-level named procedures given as arguments.@refill
@defmacx trace
With no arguments, makes sure that all the currently traced identifiers
are traced (even if those identifiers have been redefined) and returns a
list of the traced identifiers.@refill
@end defmac

@defmac track proc1 @dots{}
Traces the top-level named procedures given as arguments.@refill
@defmacx track
With no arguments, makes sure that all the currently tracked identifiers
are tracked (even if those identifiers have been redefined) and returns
a list of the tracked identifiers.@refill
@end defmac

@defmac stack proc1 @dots{}
Traces the top-level named procedures given as arguments.@refill
@defmacx stack
With no arguments, makes sure that all the currently stacked identifiers
are stacked (even if those identifiers have been redefined) and returns
a list of the stacked identifiers.@refill
@end defmac

@defmac untrace proc1 @dots{}
Turns tracing, tracking, and  off for its arguments.@refill
@defmacx untrace
With no arguments, untraces all currently traced identifiers and returns
a list of these formerly traced identifiers.@refill
@end defmac

@defmac untrack proc1 @dots{}
Turns tracing, tracking, and  off for its arguments.@refill
@defmacx untrack
With no arguments, untracks all currently tracked identifiers and returns
a list of these formerly tracked identifiers.@refill
@end defmac

@defmac unstack proc1 @dots{}
Turns tracing, stacking, and  off for its arguments.@refill
@defmacx unstack
With no arguments, unstacks all currently stacked identifiers and returns
a list of these formerly stacked identifiers.@refill
@end defmac

These are @emph{procedures} for tracing.  If defmacros are not natively
supported by your implementation, these might be more convenient to use.@refill

@defun tracef proc
@defunx tracef proc name
@defunx trackf proc
@defunx trackf proc name
@defunx stackf proc
@defunx stackf proc name
To trace, type@refill
@lisp
(set! @var{symbol} (tracef @var{symbol}))
@end lisp
@noindent
or@refill
@lisp
(set! @var{symbol} (tracef @var{symbol} '@var{symbol}))
@end lisp
@noindent
or@refill
@lisp
(define @var{symbol} (tracef @var{function}))
@end lisp
@noindent
or@refill
@lisp
(define @var{symbol} (tracef @var{function} '@var{symbol}))
@end lisp
@end defun

@defun untracef proc
Removes tracing, tracking, or stacking for @var{proc}.
To untrace, type@refill
@lisp
(set! @var{symbol} (untracef @var{symbol}))
@end lisp
@end defun


@node System Interface, Extra-SLIB Packages, Session Support, Other Packages
@section System Interface

@noindent
If @code{(provided? 'getenv)}:@refill

@defun getenv name
Looks up @var{name}, a string, in the program environment.  If @var{name} is
found a string of its value is returned.  Otherwise, @code{#f} is returned.@refill
@end defun

@noindent
If @code{(provided? 'system)}:@refill

@defun system command-string
Executes the @var{command-string} on the computer and returns the
integer status code.@refill
@end defun


@menu
* Directories::                 
* Transactions::                
* CVS::                         
@end menu

@node Directories, Transactions, System Interface, System Interface
@subsection Directories

@code{(require 'directory)}@refill
@ftindex directory


@defun current-directory

@code{current-directory} returns a string containing the absolute file
name representing the current working directory.  If this string
cannot be obtained, #f is returned.@refill

If @code{current-directory} cannot be supported by the platform, then #f is returned.@refill
@end defun

@defun make-directory name

Creates a sub-directory @var{name} of the current-directory.  If
successful, @code{make-directory} returns #t; otherwise #f.@refill
@end defun

@defun directory-for-each proc directory

@var{proc} must be a procedure taking one argument.
@samp{Directory-For-Each} applies @var{proc} to the (string) name of
each file in @var{directory}.  The dynamic order in which @var{proc} is
applied to the filenames is unspecified.  The value returned by
@samp{directory-for-each} is unspecified.@refill


@defunx directory-for-each proc directory pred
Applies @var{proc} only to those filenames for which the procedure
@var{pred} returns a non-false value.@refill


@defunx directory-for-each proc directory match
Applies @var{proc} only to those filenames for which
@code{(filename:match?? @var{match})} would return a non-false value
(@pxref{Filenames, , , slib, SLIB}).@refill

@example
(require 'directory)
(directory-for-each print "." "[A-Z]*.scm")
@print{}
"Bev2slib.scm"
"Template.scm"
@end example
@end defun


@node Transactions, CVS, Directories, System Interface
@subsection Transactions

@noindent
If @code{system} is provided by the Scheme implementation, the
@dfn{transact} package provides functions for file-locking and
file-replacement transactions.@refill

@code{(require 'transact)}@refill
@ftindex transact

@subsubheading File Locking

@noindent
Unix file-locking is focussed on write permissions for segments of a
existing file.  While this might be employed for (binary) database
access, it is not used for everyday contention (between users) for
text files.@refill

@noindent
Microsoft has several file-locking protocols.  Their model denies
write access to a file if any reader has it open.  This is too
restrictive.  Write access is denied even when the reader has
reached end-of-file.  And tracking read access (which is much more
common than write access) causes havoc when remote hosts crash or
disconnect.@refill

@noindent
It is bizarre that the concept of multi-user contention for
modifying files has not been adequately addressed by either of the
large operating system development efforts.  There is further irony
that both camps support contention detection and resolution only
through weak conventions of some their document editing programs.@refill

@noindent
@cindex file-lock
The @dfn{file-lock} procedures implement a transaction method for file@refill
@cindex file-lock
replacement compatible with the methods used by the GNU @dfn{emacs}@refill
@cindex emacs
text editor on Unix systems and the Microsoft @dfn{Word} editor.@refill
@cindex Word
@cindex emacs

@noindent
@cindex certificate
Both protocols employ what I term a @dfn{certificate} containing the@refill
@cindex certificate
user, hostname, time, and (on Unix) process-id.
Intent to replace @var{file} is indicated by adding to @var{file}'s
directory a certificate object whose name is derived from
@var{file}.@refill

@noindent
The Microsoft Word certificate is contained in a 162 byte file named
for the visited @var{file} with a @samp{~$} prefix.
Emacs/Unix creates a symbolic link to a certificate named for the
visited @var{file} prefixed with @samp{.#}.
Because Unix systems can import Microsoft file systems, these
routines maintain and check both Emacs and Word certificates.@refill


@defun file-lock-owner path

Returns the string @samp{@var{user}@@@var{hostname}} associated with
the lock owner of file @var{path} if locked; and #f otherwise.@refill
@end defun

@deffn {Procedure} file-lock! path email


@deffnx {Procedure} file-lock! path

@var{path} must be a string naming the file to be locked.  If supplied, @var{email}
must be a string formatted as @samp{@var{user}@@@var{hostname}}.  If
absent, @var{email} defaults to the value returned by @code{user-email-address}.@refill

If @var{path} is already locked, then @code{file-lock!} returns @samp{#f}.  If @var{path} is
unlocked, then @code{file-lock!} returns the certificate string associated with the
new lock for file @var{path}.@refill
@end deffn

@deffn {Procedure} file-unlock! path certificate

@var{path} must be a string naming the file to be unlocked.  @var{certificate} must be the
string returned by @code{file-lock!} for @var{path}.@refill

If @var{path} is locked with @var{certificate}, then @code{file-unlock!} removes the locks and returns
@samp{#t}.  Otherwise, @code{file-unlock!} leaves the file system unaltered and returns
@samp{#f}.@refill
@end deffn
@subsubheading File Transactions


@defun emacs:backup-name path backup-style

@var{path} must be a string.  @var{backup-style} must be a symbol.  Depending on @var{backup-style}, @code{emacs:backup-name}
returns:@refill
@table @r
@item none
#f@refill
@item simple
the string "@var{path}~"@refill
@item numbered
the string "@var{path}.~@var{n}~", where @var{n} is one greater than the
highest number appearing in a filename matching "@var{path}.~*~".  @var{n}
defauls to 1 when no filename matches.@refill
@item existing
the string "@var{path}.~@var{n}~" if a numbered backup already exists in
this directory; otherwise. "@var{path}~"@refill
@item orig
the string "@var{path}.orig"@refill
@item bak
the string "@var{path}.bak"@refill
@end table
@end defun

@defun transact-file-replacement proc path backup-style certificate


@defunx transact-file-replacement proc path backup-style

@defunx transact-file-replacement proc path

@var{path} must be a string naming an existing file.  @var{backup-style} is one of the
symbols @r{none}, @r{simple}, @r{numbered}, @r{existing}, @r{orig},
@r{bak} or @r{#f}; with meanings described above; or a string naming
the location of a backup file.  @var{backup-style} defaults to @r{#f}.  If supplied,
@var{certificate} is the certificate with which @var{path} is locked.@refill

@var{proc} must be a procedure taking two string arguments:@refill
@itemize @bullet
@item
@var{path}, the original filename (to be read); and@refill
@item
a temporary file-name.@refill
@end itemize

If @var{path} is locked by other than @var{certificate}, or if @var{certificate} is supplied and @var{path} is not
locked, then @code{transact-file-replacement} returns #f.  If @var{certificate} is not supplied, then, @code{transact-file-replacement} creates
temporary (Emacs and Word) locks for @var{path} during the transaction.  The
lock status of @var{path} will be restored before @code{transact-file-replacement} returns.@refill

@code{transact-file-replacement} calls @var{proc} with @var{path} (which should not be modified) and a temporary
file path to be written.
If @var{proc} returns any value other than @r{#t}, then the file named by @var{path}
is not altered and @code{transact-file-replacement} returns @r{#f}.
Otherwise, @code{emacs:backup-name} is called with @var{path} and @var{backup-style}.  If it
returns a string, then @var{path} is renamed to it.@refill

Finally, the temporary file is renamed @var{path}.
@code{transact-file-replacement} returns #t if @var{path} was successfully replaced; and #f otherwise.@refill
@end defun
@subsubheading Identification


@defun user-email-address

@code{user-email-address} returns a string of the form @samp{username@r{@@}hostname}.  If
this e-mail address cannot be obtained, #f is returned.@refill
@end defun


@node CVS,  , Transactions, System Interface
@subsection CVS

@code{(require 'cvs)}@refill
@ftindex cvs


@defun cvs-files directory/
Returns a list of the local pathnames (with prefix @var{directory/}) of all
CVS controlled files in @var{directory/} and in @var{directory/}'s subdirectories.@refill
@end defun

@defun cvs-directories directory/
Returns a list of all of @var{directory/} and all @var{directory/}'s CVS controlled
subdirectories.@refill
@end defun

@defun cvs-root path/
Returns the (string) contents of @var{path/}CVS/Root;
or @code{(getenv "CVSROOT")} if Root doesn't exist.@refill
@end defun

@defun cvs-repository directory/
Returns the (string) contents of @var{directory/}CVS/Root appended
with @var{directory/}CVS/Repository; or #f if @var{directory/}CVS/Repository
doesn't exist.@refill
@end defun

@deffn {Procedure} cvs-set-root! new-root directory/

Writes @var{new-root} to file CVS/Root of @var{directory/} and all its subdirectories.@refill
@end deffn

@defun cvs-vet directory/

Signals an error if CVS/Repository or CVS/Root files in @var{directory/} or any
subdirectory do not match.@refill
@end defun


@node Extra-SLIB Packages,  , System Interface, Other Packages
@section Extra-SLIB Packages

Several Scheme packages have been written using SLIB.  There are several
reasons why a package might not be included in the SLIB distribution:@refill
@itemize @bullet
@item
Because it requires special hardware or software which is not universal.@refill
@item
Because it is large and of limited interest to most Scheme users.@refill
@item
Because it has copying terms different enough from the other SLIB
packages that its inclusion would cause confusion.@refill
@item
Because it is an application program, rather than a library module.@refill
@item
Because I have been too busy to integrate it.@refill
@end itemize

Once an optional package is installed (and an entry added to
@code{*catalog*}, the @code{require} mechanism allows it to be called up
and used as easily as any other SLIB package.  Some optional packages
(for which @code{*catalog*} already has entries) available from SLIB
sites are:@refill

@table @asis
@item SLIB-PSD
is a portable debugger for Scheme (requires emacs editor).@refill

@ifset html
<A HREF="http://swissnet.ai.mit.edu/ftpdir/scm/slib-psd1-3.tar.gz">@refill
@end ifset
http://swissnet.ai.mit.edu/ftpdir/scm/slib-psd1-3.tar.gz@refill
@ifset html
</A>@refill
@end ifset

swissnet.ai.mit.edu:/pub/scm/slib-psd1-3.tar.gz@refill

ftp.maths.tcd.ie:pub/bosullvn/jacal/slib-psd1-3.tar.gz@refill

ftp.cs.indiana.edu:/pub/scheme-repository/utl/slib-psd1-3.tar.gz@refill
@sp 1

With PSD, you can run a Scheme program in an Emacs buffer, set
breakpoints, single step evaluation and access and modify the program's
variables. It works by instrumenting the original source code, so it
should run with any R4RS compliant Scheme. It has been tested with SCM,
Elk 1.5, and the sci interpreter in the Scheme->C system, but should
work with other Schemes with a minimal amount of porting, if at
all. Includes documentation and user's manual.  Written by Pertti
Kellom\"aki, pk @@ cs.tut.fi.  The Lisp Pointers article describing PSD
(Lisp Pointers VI(1):15-23, January-March 1993) is available as@refill
@ifset html
<A HREF="http://www.cs.tut.fi/staff/pk/scheme/psd/article/article.html">@refill
@end ifset
http://www.cs.tut.fi/staff/pk/scheme/psd/article/article.html@refill
@ifset html
</A>@refill
@end ifset
@sp 1

@item SCHELOG
is an embedding of Prolog in Scheme.@*
@ifset html
<A HREF="http://www.ccs.neu.edu/~dorai/schelog/schelog.html">@refill
@end ifset
http://www.ccs.neu.edu/~dorai/schelog/schelog.html@refill
@ifset html
</A>@refill
@end ifset
@sp 1

@item JFILTER
is a Scheme program which converts text among the JIS, EUC, and
Shift-JIS Japanese character sets.@*
@ifset html
<A HREF="http://www.sci.toyama-u.ac.jp/~iwao/Scheme/Jfilter/index.html">@refill
@end ifset
http://www.sci.toyama-u.ac.jp/~iwao/Scheme/Jfilter/index.html@refill
@ifset html
</A>@refill
@end ifset
@end table


@node About SLIB, Index, Other Packages, Top
@chapter About SLIB

@ifinfo
@noindent
More people than I can name have contributed to SLIB.  Thanks to all of
you!@refill

@quotation
SLIB @value{SLIBVERSION}, released @value{SLIBDATE}.@*
Aubrey Jaffer <agj @@ alum.mit.edu>@*
@i{Hyperactive Software} -- The Maniac Inside!@*
@url{http://swissnet.ai.mit.edu/~jaffer/SLIB.html}
@end quotation
@end ifinfo

@menu
* Installation::                How to install SLIB on your system.
* Porting::                     SLIB to new platforms.
* Coding Guidelines::           How to write modules for SLIB.
* Copyrights::                  Intellectual propery issues.
* About this manual::           
@end menu


@node Installation, Porting, About SLIB, About SLIB
@section Installation

@ifset html
<A NAME="Installation">@refill
@end ifset
@ifset html
</A>@refill
@end ifset

@cindex install
@cindex installation
There are four parts to installation:@refill

@itemize @bullet
@item
Unpack the SLIB distribution.@refill
@item
Configure the Scheme implementation(s) to locate the SLIB directory.@refill
@item
Arrange for Scheme implementation to load its SLIB initialization file.@refill
@item
Build the SLIB catalog for the Scheme implementation.@refill
@end itemize

@subsection Unpacking the SLIB Distribution

If the SLIB distribution is a Linux RPM, it will create the SLIB
directory @file{/usr/share/slib}.@refill

If the SLIB distribution is a ZIP file, unzip the distribution to create
the SLIB directory.  Locate this @file{slib} directory either in your
home directory (if only you will use this SLIB installation); or put it
in a location where libraries reside on your system.  On unix systems
this might be @file{/usr/share/slib}, @file{/usr/local/lib/slib}, or
@file{/usr/lib/slib}.  If you know where SLIB should go on other
platforms, please inform agj @@ alum.mit.edu.@refill

@subsection Configure Scheme Implementation to Locate SLIB

If the Scheme implementation supports @code{getenv}, then the value of
the shell environment variable @var{SCHEME_LIBRARY_PATH} will be used
for @code{(library-vicinity)} if it is defined.  Currently, Chez, Elk,
MITScheme, scheme->c, VSCM, and SCM support @code{getenv}.  Scheme48
supports @code{getenv} but does not use it for determining
@code{library-vicinity}.  (That is done from the Makefile.)@refill

The @code{(library-vicinity)} can also be specified from the SLIB
initialization file or by implementation-specific means.@refill

@subsection Loading SLIB Initialization File

Check the manifest in @file{README} to find a configuration file for
your Scheme implementation.  Initialization files for most IEEE P1178
compliant Scheme Implementations are included with this distribution.@refill

You should check the definitions of @code{software-type},
@code{scheme-implementation-version},@refill
@iftex
@*
@end iftex
@code{implementation-vicinity},
and @code{library-vicinity} in the initialization file.  There are
comments in the file for how to configure it.@refill

Once this is done, modify the startup file for your Scheme
implementation to @code{load} this initialization file.@refill

@subsection Build New SLIB Catalog for Implementation

When SLIB is first used from an implementation, a file named
@file{slibcat} is written to the @code{implementation-vicinity} for that
implementation.  Because users may lack permission to write in
@code{implementation-vicinity}, it is good practice to build the new
catalog when installing SLIB.@refill

To build (or rebuild) the catalog, start the Scheme implementation (with
SLIB), then:@refill

@example
(require 'new-catalog)
@end example

The catalog also supports color-name dictionaries.  With an
SLIB-installed scheme implementation, type:@refill
@example
(require 'color-names)
(make-slib-color-name-db)
(require 'new-catalog)
(slib:exit)
@end example

@subsection Implementation-specific Instructions

Multiple implementations of Scheme can all use the same SLIB directory.
Simply configure each implementation's initialization file as outlined
above.@refill

@deftp Implementation SCM
The SCM implementation does not require any initialization file as SLIB
support is already built into SCM.  See the documentation with SCM for
installation instructions.@refill
@end deftp

@deftp Implementation VSCM
@format
From: Matthias Blume <blume @@ cs.Princeton.EDU>
Date: Tue, 1 Mar 1994 11:42:31 -0500
@end format

Disclaimer: The code below is only a quick hack.  If I find some time to
spare I might get around to make some more things work.@refill

You have to provide @file{vscm.init} as an explicit command line
argument.  Since this is not very nice I would recommend the following
installation procedure:@refill

@enumerate
@item
run scheme@refill
@item
@code{(load "vscm.init")}@refill
@item
@code{(slib:dump "dumpfile")}@refill
@item
mv dumpfile place-where-vscm-standard-bootfile-resides
e.g. mv dumpfile /usr/local/vscm/lib/scheme-boot
(In this case vscm should have been compiled with flag
-DDEFAULT_BOOTFILE='"/usr/local/vscm/lib/scheme-boot"'.  See Makefile
(definition of DDP) for details.)@refill
@end enumerate

@end deftp

@deftp Implementation Scheme48
To make a Scheme48 image for an installation under @code{<prefix>},@refill

@enumerate
@item
@code{cd} to the SLIB directory@refill
@item
type @code{make prefix=<prefix> slib48}.@refill
@item
To install the image, type @code{make prefix=<prefix> install48}.  This
will also create a shell script with the name @code{slib48} which will
invoke the saved image.@refill
@end enumerate
@end deftp

@deftp Implementation {PLT Scheme}
@deftpx Implementation {DrScheme}
@deftpx Implementation {MzScheme}

The @file{init.ss} file in the _slibinit_ collection is an SLIB
initialization file.@refill

To use SLIB in MzScheme, set the @var{SCHEME_LIBRARY_PATH} environment
variable to the installed SLIB location; then invoke MzScheme thus:@refill

@code{mzscheme -f $@{SCHEME_LIBRARY_PATH@}DrScheme.init}@refill
@end deftp

@deftp Implementation {MIT Scheme}
@code{scheme -load $@{SCHEME_LIBRARY_PATH@}mitscheme.init}@refill
@end deftp

@deftp Implementation {Guile}
@code{guile -l $@{SCHEME_LIBRARY_PATH@}guile.init}@refill
@end deftp



@node Porting, Coding Guidelines, Installation, About SLIB
@section Porting

If there is no initialization file for your Scheme implementation, you
will have to create one.  Your Scheme implementation must be largely
compliant with@refill
@lisp
@cite{IEEE Std 1178-1990},
@cite{Revised^4 Report on the Algorithmic Language Scheme}, or
@cite{Revised^5 Report on the Algorithmic Language Scheme}
@end lisp
@noindent
in order to support SLIB.  @footnote{If you are porting a
@cite{Revised^3 Report on the Algorithmic Language Scheme}
implementation, then you will need to finish writing @file{sc4sc3.scm}
and @code{load} it from your initialization file.}@refill

@file{Template.scm} is an example configuration file.  The comments
inside will direct you on how to customize it to reflect your system.
Give your new initialization file the implementation's name with
@file{.init} appended.  For instance, if you were porting
@code{foo-scheme} then the initialization file might be called
@file{foo.init}.@refill

Your customized version should then be loaded as part of your scheme
implementation's initialization.  It will load @file{require.scm} from
the library; this will allow the use of @code{provide},
@code{provided?}, and @code{require} along with the @dfn{vicinity}
functions (these functions are documented in the sections
@ref{Feature} and @ref{Require}).  The rest of the library will then
be accessible in a system independent fashion.@refill

Please mail new working configuration files to @code{agj @@ alum.mit.edu}
so that they can be included in the SLIB distribution.@refill


@node Coding Guidelines, Copyrights, Porting, About SLIB
@section Coding Guidelines

All library packages are written in IEEE P1178 Scheme and assume that a
configuration file and @file{require.scm} package have already been
loaded.  Other versions of Scheme can be supported in library packages
as well by using, for example, @code{(provided? 'r3rs)} or
@code{(require 'r3rs)} (@pxref{Require}).@refill
@ftindex r3rs

If a procedure defined in a module is called by other procedures in
that module, then those procedures should instead call an alias
defined in that module:@refill

@lisp
(define module-name:foo foo)
@end lisp

The module name and @samp{:} should prefix that symbol for the
internal name.  Do not export internal aliases.@refill

A procedure is exported from a module by putting Schmooz-style
comments (@pxref{Schmooz}) or @samp{;@@} at the beginning of the line
immediately preceding the definition (@code{define},
@code{define-syntax}, or @code{defmacro}).  Modules, exports and other
relevant issues are discussed in @ref{Compiling Scheme}.@refill

Code submitted for inclusion in SLIB should not duplicate (more than
one) routines already in SLIB files.  Use @code{require} to force
those library routines to be used by your package.@refill

Documentation should be provided in Emacs Texinfo format if possible,
but documentation must be provided.@refill

Your package will be released sooner with SLIB if you send me a file
which tests your code.  Please run this test @emph{before} you send me
the code!@refill

@subsection Modifications

Please document your changes.  A line or two for @file{ChangeLog} is
sufficient for simple fixes or extensions.  Look at the format of
@file{ChangeLog} to see what information is desired.  Please send me
@code{diff} files from the latest SLIB distribution (remember to send
@code{diff}s of @file{slib.texi} and @file{ChangeLog}).  This makes for
less email traffic and makes it easier for me to integrate when more
than one person is changing a file (this happens a lot with
@file{slib.texi} and @samp{*.init} files).@refill

If someone else wrote a package you want to significantly modify, please
try to contact the author, who may be working on a new version.  This
will insure against wasting effort on obsolete versions.@refill

Please @emph{do not} reformat the source code with your favorite
beautifier, make 10 fixes, and send me the resulting source code.  I do
not have the time to fish through 10000 diffs to find your 10 real fixes.@refill

@node Copyrights, About this manual, Coding Guidelines, About SLIB
@section Copyrights

@ifset html
<A NAME="Copyrights">@refill
@end ifset
@ifset html
</A>@refill
@end ifset

This section has instructions for SLIB authors regarding copyrights.@refill
@cindex copyright

Each package in SLIB must either be in the public domain, or come with a
statement of terms permitting users to copy, redistribute and modify it.
The comments at the beginning of @file{require.scm} and
@file{macwork.scm} illustrate copyright and appropriate terms.@refill

If your code or changes amount to less than about 10 lines, you do not
need to add your copyright or send a disclaimer.@refill

@subsection Putting code into the Public Domain

In order to put code in the public domain you should sign a copyright
disclaimer and send it to the SLIB maintainer.  Contact
agj @@ alum.mit.edu for the address to mail the disclaimer to.@refill

@need 1000
@quotation
I, @var{<my-name>}, hereby affirm that I have placed the software
package @var{<name>} in the public domain.@refill

I affirm that I am the sole author and sole copyright holder for the
software package, that I have the right to place this software package
in the public domain, and that I will do nothing to undermine this
status in the future.@refill
@flushright
                                        @var{signature and date}
@end flushright
@end quotation

This wording assumes that you are the sole author.  If you are not the
sole author, the wording needs to be different.  If you don't want to
be bothered with sending a letter every time you release or modify a
module, make your letter say that it also applies to your future
revisions of that module.@refill

Make sure no employer has any claim to the copyright on the work you
are submitting.  If there is any doubt, create a copyright disclaimer
and have your employer sign it.  Mail the signed disclaimer to the
SLIB maintainer.  Contact agj @@ alum.mit.edu for the address to mail
the disclaimer to.  An example disclaimer follows.@refill

@subsection Explicit copying terms

@noindent
If you submit more than about 10 lines of code which you are not
placing into the Public Domain (by sending me a disclaimer) you need
to:@refill

@itemize @bullet
@item
Arrange that your name appears in a copyright line for the appropriate
year.  Multiple copyright lines are acceptable.@refill
@item
With your copyright line, specify any terms you require to be
different from those already in the file.@refill
@item
Make sure no employer has any claim to the copyright on the work you
are submitting.  If there is any doubt, create a copyright disclaimer
and have your employer sign it.  Mail the signed disclaim to the SLIB
maintainer.  Contact agj @@ alum.mit.edu for the address to mail the
disclaimer to.@refill
@end itemize

@subsection Example: Company Copyright Disclaimer

This disclaimer should be signed by a vice president or general
manager of the company.  If you can't get at them, anyone else
authorized to license out software produced there will do.  Here is a
sample wording:@refill

@quotation
@var{<employer>} Corporation hereby disclaims all copyright
interest in the program @var{<program>} written by @var{<name>}.@refill

@var{<employer>} Corporation affirms that it has no other intellectual
property interest that would undermine this release, and will do
nothing to undermine it in the future.@refill

@flushleft
@var{<signature and date>},
@var{<name>}, @var{<title>}, @var{<employer>} Corporation
@end flushleft
@end quotation

@node About this manual,  , Copyrights, About SLIB
@section About this manual

@itemize @bullet
@item
Entries that are labeled as Functions are called for their return
values.  Entries that are labeled as Procedures are called primarily for
their side effects.@refill

@item
Examples in this text were produced using the @code{scm} Scheme
implementation.@refill

@item
At the beginning of each section, there is a line that looks like@refill
@ftindex feature
@code{(require 'feature)}.  Include this line in your code prior to
using the package.@refill
@end itemize


@node Index,  , About SLIB, Top
@c @node Procedure and Macro Index, Operator Index, About SLIB, Top
@unnumbered Procedure and Macro Index

This is an alphabetical list of all the procedures and macros in SLIB.@refill

@printindex fn

@c @node Variable Index, Concept Index, Operator Index, Top
@unnumbered Variable Index

This is an alphabetical list of all the global variables in SLIB.@refill

@printindex vr

@c @node Concept Index,  , Variable Index, Top
@unnumbered Concept and Feature Index

@printindex cp

@contents
