This is elisp, produced by makeinfo version 4.0f from ./elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This Info file contains edition 2.8 of the GNU Emacs Lisp Reference
Manual, corresponding to Emacs version 21.2.

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
2000, 2001, 2002 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Copying", with the Front-Cover texts being "A
GNU Manual", and with the Back-Cover Texts as in (a) below.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: elisp,  Node: Library Headers,  Prev: Comment Tips,  Up: Tips

Conventional Headers for Emacs Libraries
========================================

   Emacs has conventions for using special comments in Lisp libraries
to divide them into sections and give information such as who wrote
them.  This section explains these conventions.

   We'll start with an example, a package that is included in the Emacs
distribution.

   Parts of this example reflect its status as part of Emacs; for
example, the copyright notice lists the Free Software Foundation as the
copyright holder, and the copying permission says the file is part of
Emacs.  When you write a package and post it, the copyright holder would
be you (unless your employer claims to own it instead), and you should
get the suggested copying permission from the end of the GNU General
Public License itself.  Don't say your file is part of Emacs if we
haven't installed it in Emacs yet!

   With that warning out of the way, on to the example:

     ;;; lisp-mnt.el --- minor mode for Emacs Lisp maintainers
     
     ;; Copyright (C) 1992 Free Software Foundation, Inc.
     
     ;; Author: Eric S. Raymond <esr@snark.thyrsus.com>
     ;; Maintainer: Eric S. Raymond <esr@snark.thyrsus.com>
     ;; Created: 14 Jul 1992
     ;; Version: 1.2
     ;; Keywords: docs
     
     ;; This file is part of GNU Emacs.
     ...
     ;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
     ;; Boston, MA 02111-1307, USA.

   The very first line should have this format:

     ;;; FILENAME --- DESCRIPTION

The description should be complete in one line.

   After the copyright notice come several "header comment" lines, each
beginning with `;; HEADER-NAME:'.  Here is a table of the conventional
possibilities for HEADER-NAME:

`Author'
     This line states the name and net address of at least the principal
     author of the library.

     If there are multiple authors, you can list them on continuation
     lines led by `;;' and a tab character, like this:

          ;; Author: Ashwin Ram <Ram-Ashwin@cs.yale.edu>
          ;;      Dave Sill <de5@ornl.gov>
          ;;      Dave Brennan <brennan@hal.com>
          ;;      Eric Raymond <esr@snark.thyrsus.com>

`Maintainer'
     This line should contain a single name/address as in the Author
     line, or an address only, or the string `FSF'.  If there is no
     maintainer line, the person(s) in the Author field are presumed to
     be the maintainers.  The example above is mildly bogus because the
     maintainer line is redundant.

     The idea behind the `Author' and `Maintainer' lines is to make
     possible a Lisp function to "send mail to the maintainer" without
     having to mine the name out by hand.

     Be sure to surround the network address with `<...>' if you
     include the person's full name as well as the network address.

`Created'
     This optional line gives the original creation date of the file.
     For historical interest only.

`Version'
     If you wish to record version numbers for the individual Lisp
     program, put them in this line.

`Adapted-By'
     In this header line, place the name of the person who adapted the
     library for installation (to make it fit the style conventions, for
     example).

`Keywords'
     This line lists keywords for the `finder-by-keyword' help command.
     Please use that command to see a list of the meaningful keywords.

     This field is important; it's how people will find your package
     when they're looking for things by topic area.  To separate the
     keywords, you can use spaces, commas, or both.

   Just about every Lisp library ought to have the `Author' and
`Keywords' header comment lines.  Use the others if they are
appropriate.  You can also put in header lines with other header
names--they have no standard meanings, so they can't do any harm.

   We use additional stylized comments to subdivide the contents of the
library file.  These should be separated by blank lines from anything
else.  Here is a table of them:

`;;; Commentary:'
     This begins introductory comments that explain how the library
     works.  It should come right after the copying permissions,
     terminated by a `Change Log', `History' or `Code' comment line.
     This text is used by the Finder package, so it should make sense
     in that context.

`;;; Documentation'
     This has been used in some files in place of `;;; Commentary:',
     but `;;; Commentary:' is preferred.

`;;; Change Log:'
     This begins change log information stored in the library file (if
     you store the change history there).  For Lisp files distributed
     with Emacs, the change history is kept in the file `ChangeLog' and
     not in the source file at all; these files generally do not have a
     `;;; Change Log:' line.  `History' is an alternative to `Change
     Log'.

`;;; Code:'
     This begins the actual code of the program.

`;;; FILENAME ends here'
     This is the "footer line"; it appears at the very end of the file.
     Its purpose is to enable people to detect truncated versions of
     the file from the lack of a footer line.


File: elisp,  Node: GNU Emacs Internals,  Next: Standard Errors,  Prev: Tips,  Up: Top

GNU Emacs Internals
*******************

   This chapter describes how the runnable Emacs executable is dumped
with the preloaded Lisp libraries in it, how storage is allocated, and
some internal aspects of GNU Emacs that may be of interest to C
programmers.

* Menu:

* Building Emacs::      How to the dumped Emacs is made.
* Pure Storage::        A kludge to make preloaded Lisp functions sharable.
* Garbage Collection::  Reclaiming space for Lisp objects no longer used.
* Memory Usage::        Info about total size of Lisp objects made so far.
* Writing Emacs Primitives::   Writing C code for Emacs.
* Object Internals::    Data formats of buffers, windows, processes.


File: elisp,  Node: Building Emacs,  Next: Pure Storage,  Up: GNU Emacs Internals

Building Emacs
==============

   This section explains the steps involved in building the Emacs
executable.  You don't have to know this material to build and install
Emacs, since the makefiles do all these things automatically.  This
information is pertinent to Emacs maintenance.

   Compilation of the C source files in the `src' directory produces an
executable file called `temacs', also called a "bare impure Emacs".  It
contains the Emacs Lisp interpreter and I/O routines, but not the
editing commands.

   The command `temacs -l loadup' uses `temacs' to create the real
runnable Emacs executable.  These arguments direct `temacs' to evaluate
the Lisp files specified in the file `loadup.el'.  These files set up
the normal Emacs editing environment, resulting in an Emacs that is
still impure but no longer bare.

   It takes a substantial time to load the standard Lisp files.
Luckily, you don't have to do this each time you run Emacs; `temacs' can
dump out an executable program called `emacs' that has these files
preloaded.  `emacs' starts more quickly because it does not need to
load the files.  This is the Emacs executable that is normally
installed.

   To create `emacs', use the command `temacs -batch -l loadup dump'.
The purpose of `-batch' here is to prevent `temacs' from trying to
initialize any of its data on the terminal; this ensures that the
tables of terminal information are empty in the dumped Emacs.  The
argument `dump' tells `loadup.el' to dump a new executable named
`emacs'.

   Some operating systems don't support dumping.  On those systems, you
must start Emacs with the `temacs -l loadup' command each time you use
it.  This takes a substantial time, but since you need to start Emacs
once a day at most--or once a week if you never log out--the extra time
is not too severe a problem.

   You can specify additional files to preload by writing a library
named `site-load.el' that loads them.  You may need to add a definition

     #define SITELOAD_PURESIZE_EXTRA N

to make N added bytes of pure space to hold the additional files.  (Try
adding increments of 20000 until it is big enough.)  However, the
advantage of preloading additional files decreases as machines get
faster.  On modern machines, it is usually not advisable.

   After `loadup.el' reads `site-load.el', it finds the documentation
strings for primitive and preloaded functions (and variables) in the
file `etc/DOC' where they are stored, by calling `Snarf-documentation'
(*note Accessing Documentation::).

   You can specify other Lisp expressions to execute just before dumping
by putting them in a library named `site-init.el'.  This file is
executed after the documentation strings are found.

   If you want to preload function or variable definitions, there are
three ways you can do this and make their documentation strings
accessible when you subsequently run Emacs:

   * Arrange to scan these files when producing the `etc/DOC' file, and
     load them with `site-load.el'.

   * Load the files with `site-init.el', then copy the files into the
     installation directory for Lisp files when you install Emacs.

   * Specify a non-`nil' value for `byte-compile-dynamic-docstrings' as
     a local variable in each of these files, and load them with either
     `site-load.el' or `site-init.el'.  (This method has the drawback
     that the documentation strings take up space in Emacs all the
     time.)

   It is not advisable to put anything in `site-load.el' or
`site-init.el' that would alter any of the features that users expect
in an ordinary unmodified Emacs.  If you feel you must override normal
features for your site, do it with `default.el', so that users can
override your changes if they wish.  *Note Startup Summary::.

 - Function: dump-emacs to-file from-file
     This function dumps the current state of Emacs into an executable
     file TO-FILE.  It takes symbols from FROM-FILE (this is normally
     the executable file `temacs').

     If you want to use this function in an Emacs that was already
     dumped, you must run Emacs with `-batch'.


File: elisp,  Node: Pure Storage,  Next: Garbage Collection,  Prev: Building Emacs,  Up: GNU Emacs Internals

Pure Storage
============

   Emacs Lisp uses two kinds of storage for user-created Lisp objects:
"normal storage" and "pure storage".  Normal storage is where all the
new data created during an Emacs session are kept; see the following
section for information on normal storage.  Pure storage is used for
certain data in the preloaded standard Lisp files--data that should
never change during actual use of Emacs.

   Pure storage is allocated only while `temacs' is loading the
standard preloaded Lisp libraries.  In the file `emacs', it is marked
as read-only (on operating systems that permit this), so that the
memory space can be shared by all the Emacs jobs running on the machine
at once.  Pure storage is not expandable; a fixed amount is allocated
when Emacs is compiled, and if that is not sufficient for the preloaded
libraries, `temacs' crashes.  If that happens, you must increase the
compilation parameter `PURESIZE' in the file `src/puresize.h'.  This
normally won't happen unless you try to preload additional libraries or
add features to the standard ones.

 - Function: purecopy object
     This function makes a copy in pure storage of OBJECT, and returns
     it.  It copies a string by simply making a new string with the same
     characters in pure storage.  It recursively copies the contents of
     vectors and cons cells.  It does not make copies of other objects
     such as symbols, but just returns them unchanged.  It signals an
     error if asked to copy markers.

     This function is a no-op except while Emacs is being built and
     dumped; it is usually called only in the file
     `emacs/lisp/loaddefs.el', but a few packages call it just in case
     you decide to preload them.

 - Variable: pure-bytes-used
     The value of this variable is the number of bytes of pure storage
     allocated so far.  Typically, in a dumped Emacs, this number is
     very close to the total amount of pure storage available--if it
     were not, we would preallocate less.

 - Variable: purify-flag
     This variable determines whether `defun' should make a copy of the
     function definition in pure storage.  If it is non-`nil', then the
     function definition is copied into pure storage.

     This flag is `t' while loading all of the basic functions for
     building Emacs initially (allowing those functions to be sharable
     and non-collectible).  Dumping Emacs as an executable always writes
     `nil' in this variable, regardless of the value it actually has
     before and after dumping.

     You should not change this flag in a running Emacs.


File: elisp,  Node: Garbage Collection,  Next: Memory Usage,  Prev: Pure Storage,  Up: GNU Emacs Internals

Garbage Collection
==================

   When a program creates a list or the user defines a new function
(such as by loading a library), that data is placed in normal storage.
If normal storage runs low, then Emacs asks the operating system to
allocate more memory in blocks of 1k bytes.  Each block is used for one
type of Lisp object, so symbols, cons cells, markers, etc., are
segregated in distinct blocks in memory.  (Vectors, long strings,
buffers and certain other editing types, which are fairly large, are
allocated in individual blocks, one per object, while small strings are
packed into blocks of 8k bytes.)

   It is quite common to use some storage for a while, then release it
by (for example) killing a buffer or deleting the last pointer to an
object.  Emacs provides a "garbage collector" to reclaim this abandoned
storage.  (This name is traditional, but "garbage recycler" might be a
more intuitive metaphor for this facility.)

   The garbage collector operates by finding and marking all Lisp
objects that are still accessible to Lisp programs.  To begin with, it
assumes all the symbols, their values and associated function
definitions, and any data presently on the stack, are accessible.  Any
objects that can be reached indirectly through other accessible objects
are also accessible.

   When marking is finished, all objects still unmarked are garbage.  No
matter what the Lisp program or the user does, it is impossible to refer
to them, since there is no longer a way to reach them.  Their space
might as well be reused, since no one will miss them.  The second
("sweep") phase of the garbage collector arranges to reuse them.

   The sweep phase puts unused cons cells onto a "free list" for future
allocation; likewise for symbols and markers.  It compacts the
accessible strings so they occupy fewer 8k blocks; then it frees the
other 8k blocks.  Vectors, buffers, windows, and other large objects are
individually allocated and freed using `malloc' and `free'.

     Common Lisp note: Unlike other Lisps, GNU Emacs Lisp does not call
     the garbage collector when the free list is empty.  Instead, it
     simply requests the operating system to allocate more storage, and
     processing continues until `gc-cons-threshold' bytes have been
     used.

     This means that you can make sure that the garbage collector will
     not run during a certain portion of a Lisp program by calling the
     garbage collector explicitly just before it (provided that portion
     of the program does not use so much space as to force a second
     garbage collection).

 - Command: garbage-collect
     This command runs a garbage collection, and returns information on
     the amount of space in use.  (Garbage collection can also occur
     spontaneously if you use more than `gc-cons-threshold' bytes of
     Lisp data since the previous garbage collection.)

     `garbage-collect' returns a list containing the following
     information:

          ((USED-CONSES . FREE-CONSES)
           (USED-SYMS . FREE-SYMS)
           (USED-MISCS . FREE-MISCS)
           USED-STRING-CHARS
           USED-VECTOR-SLOTS
           (USED-FLOATS . FREE-FLOATS)
           (USED-INTERVALS . FREE-INTERVALS)
           (USED-STRINGS . FREE-STRINGS))

     Here is an example:

          (garbage-collect)
               => ((106886 . 13184) (9769 . 0)
                          (7731 . 4651) 347543 121628
                          (31 . 94) (1273 . 168)
                          (25474 . 3569))

     Here is a table explaining each element:

    USED-CONSES
          The number of cons cells in use.

    FREE-CONSES
          The number of cons cells for which space has been obtained
          from the operating system, but that are not currently being
          used.

    USED-SYMS
          The number of symbols in use.

    FREE-SYMS
          The number of symbols for which space has been obtained from
          the operating system, but that are not currently being used.

    USED-MISCS
          The number of miscellaneous objects in use.  These include
          markers and overlays, plus certain objects not visible to
          users.

    FREE-MISCS
          The number of miscellaneous objects for which space has been
          obtained from the operating system, but that are not
          currently being used.

    USED-STRING-CHARS
          The total size of all strings, in characters.

    USED-VECTOR-SLOTS
          The total number of elements of existing vectors.

    USED-FLOATS
          The number of floats in use.

    FREE-FLOATS
          The number of floats for which space has been obtained from
          the operating system, but that are not currently being used.

    USED-INTERVALS
          The number of intervals in use.  Intervals are an internal
          data structure used for representing text properties.

    FREE-INTERVALS
          The number of intervals for which space has been obtained
          from the operating system, but that are not currently being
          used.

    USED-STRINGS
          The number of strings in use.

    FREE-STRINGS
          The number of string headers for which the space was obtained
          from the operating system, but which are currently not in
          use.  (A string object consists of a header and the storage
          for the string text itself; the latter is only allocated when
          the string is created.)

 - User Option: garbage-collection-messages
     If this variable is non-`nil', Emacs displays a message at the
     beginning and end of garbage collection.  The default value is
     `nil', meaning there are no such messages.

 - User Option: gc-cons-threshold
     The value of this variable is the number of bytes of storage that
     must be allocated for Lisp objects after one garbage collection in
     order to trigger another garbage collection.  A cons cell counts
     as eight bytes, a string as one byte per character plus a few
     bytes of overhead, and so on; space allocated to the contents of
     buffers does not count.  Note that the subsequent garbage
     collection does not happen immediately when the threshold is
     exhausted, but only the next time the Lisp evaluator is called.

     The initial threshold value is 400,000.  If you specify a larger
     value, garbage collection will happen less often.  This reduces the
     amount of time spent garbage collecting, but increases total
     memory use.  You may want to do this when running a program that
     creates lots of Lisp data.

     You can make collections more frequent by specifying a smaller
     value, down to 10,000.  A value less than 10,000 will remain in
     effect only until the subsequent garbage collection, at which time
     `garbage-collect' will set the threshold back to 10,000.

   The value return by `garbage-collect' describes the amount of memory
used by Lisp data, broken down by data type.  By contrast, the function
`memory-limit' provides information on the total amount of memory Emacs
is currently using.

 - Function: memory-limit
     This function returns the address of the last byte Emacs has
     allocated, divided by 1024.  We divide the value by 1024 to make
     sure it fits in a Lisp integer.

     You can use this to get a general idea of how your actions affect
     the memory usage.


File: elisp,  Node: Memory Usage,  Next: Writing Emacs Primitives,  Prev: Garbage Collection,  Up: GNU Emacs Internals

Memory Usage
============

   These functions and variables give information about the total amount
of memory allocation that Emacs has done, broken down by data type.
Note the difference between these and the values returned by
`(garbage-collect)'; those count objects that currently exist, but
these count the number or size of all allocations, including those for
objects that have since been freed.

 - Variable: cons-cells-consed
     The total number of cons cells that have been allocated so far in
     this Emacs session.

 - Variable: floats-consed
     The total number of floats that have been allocated so far in this
     Emacs session.

 - Variable: vector-cells-consed
     The total number of vector cells that have been allocated so far
     in this Emacs session.

 - Variable: symbols-consed
     The total number of symbols that have been allocated so far in
     this Emacs session.

 - Variable: string-chars-consed
     The total number of string characters that have been allocated so
     far in this Emacs session.

 - Variable: misc-objects-consed
     The total number of miscellaneous objects that have been allocated
     so far in this Emacs session.  These include markers and overlays,
     plus certain objects not visible to users.

 - Variable: intervals-consed
     The total number of intervals that have been allocated so far in
     this Emacs session.

 - Variable: strings-consed
     The total number of strings that have been allocated so far in this
     Emacs session.


File: elisp,  Node: Writing Emacs Primitives,  Next: Object Internals,  Prev: Memory Usage,  Up: GNU Emacs Internals

Writing Emacs Primitives
========================

   Lisp primitives are Lisp functions implemented in C.  The details of
interfacing the C function so that Lisp can call it are handled by a few
C macros.  The only way to really understand how to write new C code is
to read the source, but we can explain some things here.

   An example of a special form is the definition of `or', from
`eval.c'.  (An ordinary function would have the same general
appearance.)

     DEFUN ("or", For, Sor, 0, UNEVALLED, 0,
       "Eval args until one of them yields non-nil; return that value.\n\
     The remaining args are not evalled at all.\n\
     If all args return nil, return nil.")
       (args)
          Lisp_Object args;
     {
       register Lisp_Object val;
       Lisp_Object args_left;
       struct gcpro gcpro1;
     
       if (NILP (args))
         return Qnil;
     
       args_left = args;
       GCPRO1 (args_left);
     
       do
         {
           val = Feval (Fcar (args_left));
           if (!NILP (val))
             break;
           args_left = Fcdr (args_left);
         }
       while (!NILP (args_left));
     
       UNGCPRO;
       return val;
     }

   Let's start with a precise explanation of the arguments to the
`DEFUN' macro.  Here is a template for them:

     DEFUN (LNAME, FNAME, SNAME, MIN, MAX, INTERACTIVE, DOC)

LNAME
     This is the name of the Lisp symbol to define as the function
     name; in the example above, it is `or'.

FNAME
     This is the C function name for this function.  This is the name
     that is used in C code for calling the function.  The name is, by
     convention, `F' prepended to the Lisp name, with all dashes (`-')
     in the Lisp name changed to underscores.  Thus, to call this
     function from C code, call `For'.  Remember that the arguments must
     be of type `Lisp_Object'; various macros and functions for creating
     values of type `Lisp_Object' are declared in the file `lisp.h'.

SNAME
     This is a C variable name to use for a structure that holds the
     data for the subr object that represents the function in Lisp.
     This structure conveys the Lisp symbol name to the initialization
     routine that will create the symbol and store the subr object as
     its definition.  By convention, this name is always FNAME with `F'
     replaced with `S'.

MIN
     This is the minimum number of arguments that the function
     requires.  The function `or' allows a minimum of zero arguments.

MAX
     This is the maximum number of arguments that the function accepts,
     if there is a fixed maximum.  Alternatively, it can be `UNEVALLED',
     indicating a special form that receives unevaluated arguments, or
     `MANY', indicating an unlimited number of evaluated arguments (the
     equivalent of `&rest').  Both `UNEVALLED' and `MANY' are macros.
     If MAX is a number, it may not be less than MIN and it may not be
     greater than seven.

INTERACTIVE
     This is an interactive specification, a string such as might be
     used as the argument of `interactive' in a Lisp function.  In the
     case of `or', it is 0 (a null pointer), indicating that `or'
     cannot be called interactively.  A value of `""' indicates a
     function that should receive no arguments when called
     interactively.

DOC
     This is the documentation string.  It is written just like a
     documentation string for a function defined in Lisp, except you
     must write `\n\' at the end of each line.  In particular, the
     first line should be a single sentence.

   After the call to the `DEFUN' macro, you must write the argument
name list that every C function must have, followed by ordinary C
declarations for the arguments.  For a function with a fixed maximum
number of arguments, declare a C argument for each Lisp argument, and
give them all type `Lisp_Object'.  When a Lisp function has no upper
limit on the number of arguments, its implementation in C actually
receives exactly two arguments: the first is the number of Lisp
arguments, and the second is the address of a block containing their
values.  They have types `int' and `Lisp_Object *'.

   Within the function `For' itself, note the use of the macros
`GCPRO1' and `UNGCPRO'.  `GCPRO1' is used to "protect" a variable from
garbage collection--to inform the garbage collector that it must look
in that variable and regard its contents as an accessible object.  This
is necessary whenever you call `Feval' or anything that can directly or
indirectly call `Feval'.  At such a time, any Lisp object that you
intend to refer to again must be protected somehow.  `UNGCPRO' cancels
the protection of the variables that are protected in the current
function.  It is necessary to do this explicitly.

   For most data types, it suffices to protect at least one pointer to
the object; as long as the object is not recycled, all pointers to it
remain valid.  This is not so for strings, because the garbage collector
can move them.  When the garbage collector moves a string, it relocates
all the pointers it knows about; any other pointers become invalid.
Therefore, you must protect all pointers to strings across any point
where garbage collection may be possible.

   The macro `GCPRO1' protects just one local variable.  If you want to
protect two, use `GCPRO2' instead; repeating `GCPRO1' will not work.
Macros `GCPRO3' and `GCPRO4' also exist.

   These macros implicitly use local variables such as `gcpro1'; you
must declare these explicitly, with type `struct gcpro'.  Thus, if you
use `GCPRO2', you must declare `gcpro1' and `gcpro2'.  Alas, we can't
explain all the tricky details here.

   You must not use C initializers for static or global variables unless
the variables are never written once Emacs is dumped.  These variables
with initializers are allocated in an area of memory that becomes
read-only (on certain operating systems) as a result of dumping Emacs.
*Note Pure Storage::.

   Do not use static variables within functions--place all static
variables at top level in the file.  This is necessary because Emacs on
some operating systems defines the keyword `static' as a null macro.
(This definition is used because those systems put all variables
declared static in a place that becomes read-only after dumping, whether
they have initializers or not.)

   Defining the C function is not enough to make a Lisp primitive
available; you must also create the Lisp symbol for the primitive and
store a suitable subr object in its function cell.  The code looks like
this:

     defsubr (&SUBR-STRUCTURE-NAME);

Here SUBR-STRUCTURE-NAME is the name you used as the third argument to
`DEFUN'.

   If you add a new primitive to a file that already has Lisp primitives
defined in it, find the function (near the end of the file) named
`syms_of_SOMETHING', and add the call to `defsubr' there.  If the file
doesn't have this function, or if you create a new file, add to it a
`syms_of_FILENAME' (e.g., `syms_of_myfile').  Then find the spot in
`emacs.c' where all of these functions are called, and add a call to
`syms_of_FILENAME' there.

   The function `syms_of_FILENAME' is also the place to define any C
variables that are to be visible as Lisp variables.  `DEFVAR_LISP'
makes a C variable of type `Lisp_Object' visible in Lisp.  `DEFVAR_INT'
makes a C variable of type `int' visible in Lisp with a value that is
always an integer.  `DEFVAR_BOOL' makes a C variable of type `int'
visible in Lisp with a value that is either `t' or `nil'.  Note that
variables defined with `DEFVAR_BOOL' are automatically added to the list
`byte-boolean-vars' used by the byte compiler.

   If you define a file-scope C variable of type `Lisp_Object', you
must protect it from garbage-collection by calling `staticpro' in
`syms_of_FILENAME', like this:

     staticpro (&VARIABLE);

   Here is another example function, with more complicated arguments.
This comes from the code in `window.c', and it demonstrates the use of
macros and functions to manipulate Lisp objects.

     DEFUN ("coordinates-in-window-p", Fcoordinates_in_window_p,
       Scoordinates_in_window_p, 2, 2,
       "xSpecify coordinate pair: \nXExpression which evals to window: ",
       "Return non-nil if COORDINATES is in WINDOW.\n\
     COORDINATES is a cons of the form (X . Y), X and Y being distances\n\
     ...
     If they are on the border between WINDOW and its right sibling,\n\
        `vertical-line' is returned.")
       (coordinates, window)
          register Lisp_Object coordinates, window;
     {
       int x, y;
     
       CHECK_LIVE_WINDOW (window, 0);
       CHECK_CONS (coordinates, 1);
       x = XINT (Fcar (coordinates));
       y = XINT (Fcdr (coordinates));
     
       switch (coordinates_in_window (XWINDOW (window), &x, &y))
         {
         case 0:			/* NOT in window at all. */
           return Qnil;
     
         case 1:			/* In text part of window. */
           return Fcons (make_number (x), make_number (y));
     
         case 2:			/* In mode line of window. */
           return Qmode_line;
     
         case 3:			/* On right border of window.  */
           return Qvertical_line;
     
         default:
           abort ();
         }
     }

   Note that C code cannot call functions by name unless they are
defined in C.  The way to call a function written in Lisp is to use
`Ffuncall', which embodies the Lisp function `funcall'.  Since the Lisp
function `funcall' accepts an unlimited number of arguments, in C it
takes two: the number of Lisp-level arguments, and a one-dimensional
array containing their values.  The first Lisp-level argument is the
Lisp function to call, and the rest are the arguments to pass to it.
Since `Ffuncall' can call the evaluator, you must protect pointers from
garbage collection around the call to `Ffuncall'.

   The C functions `call0', `call1', `call2', and so on, provide handy
ways to call a Lisp function conveniently with a fixed number of
arguments.  They work by calling `Ffuncall'.

   `eval.c' is a very good file to look through for examples; `lisp.h'
contains the definitions for some important macros and functions.

   If you define a function which is side-effect free, update the code
in `byte-opt.el' which binds `side-effect-free-fns' and
`side-effect-and-error-free-fns' to include it.  This will help the
optimizer.


File: elisp,  Node: Object Internals,  Prev: Writing Emacs Primitives,  Up: GNU Emacs Internals

Object Internals
================

   GNU Emacs Lisp manipulates many different types of data.  The actual
data are stored in a heap and the only access that programs have to it
is through pointers.  Pointers are thirty-two bits wide in most
implementations.  Depending on the operating system and type of machine
for which you compile Emacs, twenty-eight bits are used to address the
object, and the remaining four bits are used for a GC mark bit and the
tag that identifies the object's type.

   Because Lisp objects are represented as tagged pointers, it is always
possible to determine the Lisp data type of any object.  The C data type
`Lisp_Object' can hold any Lisp object of any data type.  Ordinary
variables have type `Lisp_Object', which means they can hold any type
of Lisp value; you can determine the actual data type only at run time.
The same is true for function arguments; if you want a function to
accept only a certain type of argument, you must check the type
explicitly using a suitable predicate (*note Type Predicates::).

* Menu:

* Buffer Internals::    Components of a buffer structure.
* Window Internals::    Components of a window structure.
* Process Internals::   Components of a process structure.


File: elisp,  Node: Buffer Internals,  Next: Window Internals,  Up: Object Internals

Buffer Internals
----------------

   Buffers contain fields not directly accessible by the Lisp
programmer.  We describe them here, naming them by the names used in
the C code.  Many are accessible indirectly in Lisp programs via Lisp
primitives.

   Two structures are used to represent buffers in C.  The
`buffer_text' structure contains fields describing the text of a
buffer; the `buffer' structure holds other fields.  In the case of
indirect buffers, two or more `buffer' structures reference the same
`buffer_text' structure.

   Here is a list of the `struct buffer_text' fields:

`beg'
     This field contains the actual address of the buffer contents.

`gpt'
     This holds the character position of the gap in the buffer.

`z'
     This field contains the character position of the end of the buffer
     text.

`gpt_byte'
     Contains the byte position of the gap.

`z_byte'
     Holds the byte position of the end of the buffer text.

`gap_size'
     Contains the size of buffer's gap.

`modiff'
     This field counts buffer-modification events for this buffer.  It
     is incremented for each such event, and never otherwise changed.

`save_modiff'
     Contains the previous value of `modiff', as of the last time a
     buffer was visited or saved in a file.

`overlay_modiff'
     Counts modifications to overlays analogous to `modiff'.

`beg_unchanged'
     Holds the number of characters at the start of the text that are
     known to be unchanged since the last redisplay that finished.

`end_unchanged'
     Holds the number of characters at the end of the text that are
     known to be unchanged since the last redisplay that finished.

`unchanged_modified'
     Contains the value of `modiff' at the time of the last redisplay
     that finished.  If this value matches `modiff', `beg_unchanged'
     and `end_unchanged' contain no useful information.

`overlay_unchanged_modified'
     Contains the value of `overlay_modiff' at the time of the last
     redisplay that finished.  If this value matches `overlay_modiff',
     `beg_unchanged' and `end_unchanged' contain no useful information.

`markers'
     The markers that refer to this buffer.  This is actually a single
     marker, and successive elements in its marker `chain' are the other
     markers referring to this buffer text.

`intervals'
     Contains the interval tree which records the text properties of
     this buffer.

   The fields of `struct buffer' are:

`next'
     Points to the next buffer, in the chain of all buffers including
     killed buffers.  This chain is used only for garbage collection,
     in order to collect killed buffers properly.  Note that vectors,
     and most kinds of objects allocated as vectors, are all on one
     chain, but buffers are on a separate chain of their own.

`own_text'
     This is a `struct buffer_text' structure.  In an ordinary buffer,
     it holds the buffer contents.  In indirect buffers, this field is
     not used.

`text'
     This points to the `buffer_text' structure that is used for this
     buffer.  In an ordinary buffer, this is the `own_text' field above.
     In an indirect buffer, this is the `own_text' field of the base
     buffer.

`pt'
     Contains the character position of point in a buffer.

`pt_byte'
     Contains the byte position of point in a buffer.

`begv'
     This field contains the character position of the beginning of the
     accessible range of text in the buffer.

`begv_byte'
     This field contains the byte position of the beginning of the
     accessible range of text in the buffer.

`zv'
     This field contains the character position of the end of the
     accessible range of text in the buffer.

`zv_byte'
     This field contains the byte position of the end of the accessible
     range of text in the buffer.

`base_buffer'
     In an indirect buffer, this points to the base buffer.  In an
     ordinary buffer, it is null.

`local_var_flags'
     This field contains flags indicating that certain variables are
     local in this buffer.  Such variables are declared in the C code
     using `DEFVAR_PER_BUFFER', and their buffer-local bindings are
     stored in fields in the buffer structure itself.  (Some of these
     fields are described in this table.)

`modtime'
     This field contains the modification time of the visited file.  It
     is set when the file is written or read.  Before writing the
     buffer into a file, this field is compared to the modification
     time of the file to see if the file has changed on disk.  *Note
     Buffer Modification::.

`auto_save_modified'
     This field contains the time when the buffer was last auto-saved.

`auto_save_failure_time'
     The time at which we detected a failure to auto-save, or -1 if we
     didn't have a failure.

`last_window_start'
     This field contains the `window-start' position in the buffer as of
     the last time the buffer was displayed in a window.

`clip_changed'
     This flag is set when narrowing changes in a buffer.

`prevent_redisplay_optimizations_p'
     this flag indicates that redisplay optimizations should not be used
     to display this buffer.

`undo_list'
     This field points to the buffer's undo list.  *Note Undo::.

`name'
     The buffer name is a string that names the buffer.  It is
     guaranteed to be unique.  *Note Buffer Names::.

`filename'
     The name of the file visited in this buffer, or `nil'.

`directory'
     The directory for expanding relative file names.

`save_length'
     Length of the file this buffer is visiting, when last read or
     saved.  This and other fields concerned with saving are not kept
     in the `buffer_text' structure because indirect buffers are never
     saved.

`auto_save_file_name'
     File name used for auto-saving this buffer.  This is not in the
     `buffer_text' because it's not used in indirect buffers at all.

`read_only'
     Non-`nil' means this buffer is read-only.

`mark'
     This field contains the mark for the buffer.  The mark is a marker,
     hence it is also included on the list `markers'.  *Note The Mark::.

`local_var_alist'
     This field contains the association list describing the
     buffer-local variable bindings of this buffer, not including the
     built-in buffer-local bindings that have special slots in the
     buffer object.  (Those slots are omitted from this table.)  *Note
     Buffer-Local Variables::.

`major_mode'
     Symbol naming the major mode of this buffer, e.g., `lisp-mode'.

`mode_name'
     Pretty name of major mode, e.g., `"Lisp"'.

`mode_line_format'
     Mode line element that controls the format of the mode line.  If
     this is `nil', no mode line will be displayed.

`header_line_format'
     This field is analoguous to `mode_line_format' for the mode line
     displayed at the top of windows.

`keymap'
     This field holds the buffer's local keymap.  *Note Keymaps::.

`abbrev_table'
     This buffer's local abbrevs.

`syntax_table'
     This field contains the syntax table for the buffer.  *Note Syntax
     Tables::.

`category_table'
     This field contains the category table for the buffer.

`case_fold_search'
     The value of `case-fold-search' in this buffer.

`tab_width'
     The value of `tab-width' in this buffer.

`fill_column'
     The value of `fill-column' in this buffer.

`left_margin'
     The value of `left-margin' in this buffer.

`auto_fill_function'
     The value of `auto-fill-function' in this buffer.

`downcase_table'
     This field contains the conversion table for converting text to
     lower case.  *Note Case Tables::.

`upcase_table'
     This field contains the conversion table for converting text to
     upper case.  *Note Case Tables::.

`case_canon_table'
     This field contains the conversion table for canonicalizing text
     for case-folding search.  *Note Case Tables::.

`case_eqv_table'
     This field contains the equivalence table for case-folding search.
     *Note Case Tables::.

`truncate_lines'
     The value of `truncate-lines' in this buffer.

`ctl_arrow'
     The value of `ctl-arrow' in this buffer.

`selective_display'
     The value of `selective-display' in this buffer.

`selective_display_ellipsis'
     The value of `selective-display-ellipsis' in this buffer.

`minor_modes'
     An alist of the minor modes of this buffer.

`overwrite_mode'
     The value of `overwrite_mode' in this buffer.

`abbrev_mode'
     The value of `abbrev-mode' in this buffer.

`display_table'
     This field contains the buffer's display table, or `nil' if it
     doesn't have one.  *Note Display Tables::.

`save_modified'
     This field contains the time when the buffer was last saved, as an
     integer.  *Note Buffer Modification::.

`mark_active'
     This field is non-`nil' if the buffer's mark is active.

`overlays_before'
     This field holds a list of the overlays in this buffer that end at
     or before the current overlay center position.  They are sorted in
     order of decreasing end position.

`overlays_after'
     This field holds a list of the overlays in this buffer that end
     after the current overlay center position.  They are sorted in
     order of increasing beginning position.

`overlay_center'
     This field holds the current overlay center position.  *Note
     Overlays::.

`enable_multibyte_characters'
     This field holds the buffer's local value of
     `enable-multibyte-characters'--either `t' or `nil'.

`buffer_file_coding_system'
     The value of `buffer-file-coding-system' in this buffer.

`file_format'
     The value of `buffer-file-format' in this buffer.

`pt_marker'
     In an indirect buffer, or a buffer that is the base of an indirect
     buffer, this holds a marker that records point for this buffer
     when the buffer is not current.

`begv_marker'
     In an indirect buffer, or a buffer that is the base of an indirect
     buffer, this holds a marker that records `begv' for this buffer
     when the buffer is not current.

`zv_marker'
     In an indirect buffer, or a buffer that is the base of an indirect
     buffer, this holds a marker that records `zv' for this buffer when
     the buffer is not current.

`file_truename'
     The truename of the visited file, or `nil'.

`invisibility_spec'
     The value of `buffer-invisibility-spec' in this buffer.

`last_selected_window'
     This is the last window that was selected with this buffer in it,
     or `nil' if that window no longer displays this buffer.

`display_count'
     This field is incremented each time the buffer is displayed in a
     window.

`left_margin_width'
     The value of `left-margin-width' in this buffer.

`right_margin_width'
     The value of `right-margin-width' in this buffer.

`indicate_empty_lines'
     Non-`nil' means indicate empty lines (lines with no text) with a
     small bitmap in the fringe, when using a window system that can do
     it.

`display_time'
     This holds a time stamp that is updated each time this buffer is
     displayed in a window.

`scroll_up_aggressively'
     The value of `scroll-up-aggressively' in this buffer.

`scroll_down_aggressively'
     The value of `scroll-down-aggressively' in this buffer.

