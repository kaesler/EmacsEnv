This is elisp, produced by makeinfo version 4.0f from ./elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This Info file contains edition 2.8 of the GNU Emacs Lisp Reference
Manual, corresponding to Emacs version 21.2.

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
2000, 2001, 2002 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Copying", with the Front-Cover texts being "A
GNU Manual", and with the Back-Cover Texts as in (a) below.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: elisp,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

   This Info file contains edition 2.8 of the GNU Emacs Lisp Reference
Manual, corresponding to GNU Emacs version 21.2.

* Menu:

* Introduction::            Introduction and conventions used.
* Standards: Coding Conventions.    Coding conventions for Emacs Lisp.

* Lisp Data Types::         Data types of objects in Emacs Lisp.
* Numbers::                 Numbers and arithmetic functions.
* Strings and Characters::  Strings, and functions that work on them.
* Lists::                   Lists, cons cells, and related functions.
* Sequences Arrays Vectors::  Lists, strings and vectors are called sequences.
                                Certain functions act on any kind of sequence.
                                The description of vectors is here as well.
* Hash Tables::             Very fast lookup-tables.
* Symbols::                 Symbols represent names, uniquely.

* Evaluation::              How Lisp expressions are evaluated.
* Control Structures::      Conditionals, loops, nonlocal exits.
* Variables::               Using symbols in programs to stand for values.
* Functions::               A function is a Lisp program
                              that can be invoked from other functions.
* Macros::                  Macros are a way to extend the Lisp language.
* Customization::           Writing customization declarations.

* Loading::                 Reading files of Lisp code into Lisp.
* Byte Compilation::        Compilation makes programs run faster.
* Advising Functions::      Adding to the definition of a function.
* Debugging::               Tools and tips for debugging Lisp programs.

* Read and Print::          Converting Lisp objects to text and back.
* Minibuffers::             Using the minibuffer to read input.
* Command Loop::            How the editor command loop works,
                              and how you can call its subroutines.
* Keymaps::                 Defining the bindings from keys to commands.
* Modes::                   Defining major and minor modes.
* Documentation::           Writing and using documentation strings.

* Files::                   Accessing files.
* Backups and Auto-Saving:: Controlling how backups and auto-save
                              files are made.
* Buffers::                 Creating and using buffer objects.
* Windows::                 Manipulating windows and displaying buffers.
* Frames::		    Making multiple X windows.
* Positions::               Buffer positions and motion functions.
* Markers::                 Markers represent positions and update
                              automatically when the text is changed.

* Text::                    Examining and changing text in buffers.
* Non-ASCII Characters::    Non-ASCII text in buffers and strings.
* Searching and Matching::  Searching buffers for strings or regexps.
* Syntax Tables::           The syntax table controls word and list parsing.
* Abbrevs::                 How Abbrev mode works, and its data structures.

* Processes::               Running and communicating with subprocesses.
* Display::	            Features for controlling the screen display.
* Calendar::		    Customizing the calendar and diary.
* System Interface::        Getting the user id, system type, environment
                              variables, and other such things.

Appendices

* Antinews::                Info for users downgrading to Emacs 20.
* GNU Free Documentation License:: The license for this documentation
* GPL::                     Conditions for copying and changing GNU Emacs.
* Tips::                    Advice and coding conventions for Emacs Lisp.
* GNU Emacs Internals::     Building and dumping Emacs;
                              internal data structures.
* Standard Errors::         List of all error symbols.
* Standard Buffer-Local Variables::
                            List of variables buffer-local in all buffers.
* Standard Keymaps::        List of standard keymaps.
* Standard Hooks::          List of standard hook variables.

* Index::                   Index including concepts, functions, variables,
                              and other terms.

* New Symbols::             New functions and variables in Emacs 21.

      --- The Detailed Node Listing ---

Here are other nodes that are inferiors of those already listed,
mentioned here so you can get to them in one step:

Introduction

* Caveats::                 Flaws and a request for help.
* Lisp History::            Emacs Lisp is descended from Maclisp.
* Conventions::             How the manual is formatted.
* Acknowledgements::        The authors, editors, and sponsors of this manual.

Conventions

* Some Terms::              Explanation of terms we use in this manual.
* nil and t::               How the symbols `nil' and `t' are used.
* Evaluation Notation::     The format we use for examples of evaluation.
* Printing Notation::       The format we use for examples that print output.
* Error Messages::          The format we use for examples of errors.
* Buffer Text Notation::    The format we use for buffer contents in examples.
* Format of Descriptions::  Notation for describing functions, variables, etc.

Tips and Conventions

* Coding Conventions::      Conventions for clean and robust programs.
* Compilation Tips::        Making compiled code run fast.
* Documentation Tips::      Writing readable documentation strings.
* Comment Tips::	    Conventions for writing comments.
* Library Headers::         Standard headers for library packages.

Format of Descriptions

* A Sample Function Description::
* A Sample Variable Description::

Lisp Data Types

* Printed Representation::  How Lisp objects are represented as text.
* Comments::                Comments and their formatting conventions.
* Programming Types::       Types found in all Lisp systems.
* Editing Types::           Types specific to Emacs.
* Type Predicates::         Tests related to types.
* Equality Predicates::     Tests of equality between any two objects.

Programming Types

* Integer Type::        Numbers without fractional parts.
* Floating Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                          control characters.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, property list, or itself.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                          functions.

List Type

* Dotted Pair Notation::    An alternative syntax for lists.
* Association List Type::   A specially constructed list.

Editing Types

* Buffer Type::             The basic object of editing.
* Window Type::             What makes buffers visible.
* Window Configuration Type::Save what the screen looks like.
* Marker Type::             A position in a buffer.
* Process Type::            A process running on the underlying OS.
* Stream Type::             Receive or send characters.
* Keymap Type::             What function a keystroke invokes.
* Overlay Type::            How an overlay is represented.

Numbers

* Integer Basics::            Representation and range of integers.
* Float Basics::	      Representation and range of floating point.
* Predicates on Numbers::     Testing for numbers.
* Comparison of Numbers::     Equality and inequality predicates.
* Arithmetic Operations::     How to add, subtract, multiply and divide.
* Bitwise Operations::        Logical and, or, not, shifting.
* Numeric Conversions::	      Converting float to integer and vice versa.
* Math Functions::            Trig, exponential and logarithmic functions.
* Random Numbers::            Obtaining random integers, predictable or not.

Strings and Characters

* String Basics::           Basic properties of strings and characters.
* Predicates for Strings::  Testing whether an object is a string or char.
* Creating Strings::        Functions to allocate new strings.
* Text Comparison::         Comparing characters or strings.
* String Conversion::       Converting characters or strings and vice versa.
* Formatting Strings::      `format': Emacs's analogue of `printf'.
* Case Conversion::         Case conversion functions.

Lists

* Cons Cells::              How lists are made out of cons cells.
* Lists as Boxes::          Graphical notation to explain lists.
* List-related Predicates:: Is this object a list?  Comparing two lists.
* List Elements::           Extracting the pieces of a list.
* Building Lists::          Creating list structure.
* Modifying Lists::         Storing new pieces into an existing list.
* Sets And Lists::          A list can represent a finite mathematical set.
* Association Lists::       A list can represent a finite relation or mapping.

Modifying Existing List Structure

* Setcar::                  Replacing an element in a list.
* Setcdr::                  Replacing part of the list backbone.
                              This can be used to remove or add elements.
* Rearrangement::           Reordering the elements in a list; combining lists.

Sequences, Arrays, and Vectors

* Sequence Functions::      Functions that accept any kind of sequence.
* Arrays::                  Characteristics of arrays in Emacs Lisp.
* Array Functions::         Functions specifically for arrays.
* Vectors::                 Functions specifically for vectors.

Symbols

* Symbol Components::       Symbols have names, values, function definitions
                              and property lists.
* Definitions::             A definition says how a symbol will be used.
* Creating Symbols::        How symbols are kept unique.
* Property Lists::          Each symbol has a property list
                              for recording miscellaneous information.

Evaluation

* Intro Eval::              Evaluation in the scheme of things.
* Eval::                    How to invoke the Lisp interpreter explicitly.
* Forms::                   How various sorts of objects are evaluated.
* Quoting::                 Avoiding evaluation (to put constants in
                              the program).

Kinds of Forms

* Self-Evaluating Forms::   Forms that evaluate to themselves.
* Symbol Forms::            Symbols evaluate as variables.
* Classifying Lists::       How to distinguish various sorts of list forms.
* Function Forms::          Forms that call functions.
* Macro Forms::             Forms that call macros.
* Special Forms::           ``Special forms'' are idiosyncratic primitives,
                              most of them extremely important.
* Autoloading::             Functions set up to load files
                              containing their real definitions.

Control Structures

* Sequencing::              Evaluation in textual order.
* Conditionals::            `if', `cond'.
* Combining Conditions::    `and', `or', `not'.
* Iteration::               `while' loops.
* Nonlocal Exits::          Jumping out of a sequence.

Nonlocal Exits

* Catch and Throw::         Nonlocal exits for the program's own purposes.
* Examples of Catch::       Showing how such nonlocal exits can be written.
* Errors::                  How errors are signaled and handled.
* Cleanups::                Arranging to run a cleanup form if an
                              error happens.

Errors

* Signaling Errors::        How to report an error.
* Processing of Errors::    What Emacs does when you report an error.
* Handling Errors::         How you can trap errors and continue execution.
* Error Symbols::           How errors are classified for trapping them.

Variables

* Global Variables::        Variable values that exist permanently, everywhere.
* Constant Variables::      Certain "variables" have values that never change.
* Local Variables::         Variable values that exist only temporarily.
* Void Variables::          Symbols that lack values.
* Defining Variables::      A definition says a symbol is used as a variable.
* Accessing Variables::     Examining values of variables whose names
                              are known only at run time.
* Setting Variables::       Storing new values in variables.
* Variable Scoping::        How Lisp chooses among local and global values.
* Buffer-Local Variables::  Variable values in effect only in one buffer.

Scoping Rules for Variable Bindings

* Scope::                   Scope means where in the program a value
                              is visible.  Comparison with other languages.
* Extent::                  Extent means how long in time a value exists.
* Impl of Scope::           Two ways to implement dynamic scoping.
* Using Scoping::           How to use dynamic scoping carefully and
                              avoid problems.

Buffer-Local Variables

* Intro to Buffer-Local::   Introduction and concepts.
* Creating Buffer-Local::   Creating and destroying buffer-local bindings.
* Default Value::           The default value is seen in buffers
                              that don't have their own buffer-local values.

Functions

* What Is a Function::      Lisp functions vs primitives; terminology.
* Lambda Expressions::      How functions are expressed as Lisp objects.
* Function Names::          A symbol can serve as the name of a function.
* Defining Functions::      Lisp expressions for defining functions.
* Calling Functions::       How to use an existing function.
* Mapping Functions::       Applying a function to each element of a list, etc.
* Anonymous Functions::     Lambda-expressions are functions with no names.
* Function Cells::          Accessing or setting the function definition
                              of a symbol.
* Related Topics::          Cross-references to specific Lisp primitives
                              that have a special bearing on how
                              functions work.

Lambda Expressions

* Lambda Components::       The parts of a lambda expression.
* Simple Lambda::           A simple example.
* Argument List::           Details and special features of argument lists.
* Function Documentation::  How to put documentation in a function.

Macros

* Simple Macro::            A basic example.
* Expansion::               How, when and why macros are expanded.
* Compiling Macros::        How macros are expanded by the compiler.
* Defining Macros::         How to write a macro definition.
* Backquote::               Easier construction of list structure.
* Problems with Macros::    Don't evaluate the macro arguments too many times.
                              Don't hide the user's variables.

Loading

* How Programs Do Loading:: The `load' function and others.
* Autoload::                Setting up a function to autoload.
* Named Features::          Loading a library if it isn't already loaded.
* Repeated Loading::        Precautions about loading a file twice.

Byte Compilation

* Compilation Functions::   Byte compilation functions.
* Disassembly::             Disassembling byte-code; how to read byte-code.

Advising Functions

* Simple Advice::           A simple example to explain the basics of advice.
* Defining Advice::         Detailed description of `defadvice'.
* Computed Advice::         ...is to `defadvice' as `fset' is to `defun'.
* Activation of Advice::    Advice doesn't do anything until you activate it.
* Enabling Advice::         You can enable or disable each piece of advice.
* Preactivation::           Preactivation is a way of speeding up the
                              loading of compiled advice.
* Argument Access in Advice:: How advice can access the function's arguments.
* Subr Arguments::          Accessing arguments when advising a primitive.
* Combined Definition::     How advice is implemented.

Debugging Lisp Programs

* Debugger::                How the Emacs Lisp debugger is implemented.
* Syntax Errors::           How to find syntax errors.
* Compilation Errors::      How to find errors that show up in
                              byte compilation.
* Edebug::                  A source-level Emacs Lisp debugger.

The Lisp Debugger

* Error Debugging::         Entering the debugger when an error happens.
* Function Debugging::      Entering it when a certain function is called.
* Explicit Debug::          Entering it at a certain point in the program.
* Using Debugger::          What the debugger does; what you see while in it.
* Debugger Commands::       Commands used while in the debugger.
* Invoking the Debugger::   How to call the function `debug'.
* Internals of Debugger::   Subroutines of the debugger, and global variables.

Debugging Invalid Lisp Syntax

* Excess Open::             How to find a spurious open paren or missing close.
* Excess Close::            How to find a spurious close paren or missing open.

Reading and Printing Lisp Objects

* Streams Intro::           Overview of streams, reading and printing.
* Input Streams::           Various data types that can be used as
                              input streams.
* Input Functions::         Functions to read Lisp objects from text.
* Output Streams::          Various data types that can be used as
                              output streams.
* Output Functions::        Functions to print Lisp objects as text.

Minibuffers

* Intro to Minibuffers::    Basic information about minibuffers.
* Text from Minibuffer::    How to read a straight text string.
* Object from Minibuffer::  How to read a Lisp object or expression.
* Completion::              How to invoke and customize completion.
* Yes-or-No Queries::       Asking a question with a simple answer.
* Minibuffer Misc::         Various customization hooks and variables.

Completion

* Basic Completion::        Low-level functions for completing strings.
                              (These are too low level to use the minibuffer.)
* Minibuffer Completion::   Invoking the minibuffer with completion.
* Completion Commands::     Minibuffer commands that do completion.
* High-Level Completion::   Convenient special cases of completion
                              (reading buffer name, file name, etc.)
* Reading File Names::      Using completion to read file names.
* Programmed Completion::   Finding the completions for a given file name.

Command Loop

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Input Events::	What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How C-g works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn't.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.

Defining Commands

* Using Interactive::       General rules for `interactive'.
* Interactive Codes::       The standard letter-codes for reading arguments
                              in various ways.
* Interactive Examples::    Examples of how to read interactive arguments.

Keymaps

* Keymap Terminology::        	Definitions of terms pertaining to keymaps.
* Format of Keymaps::		What a keymap looks like as a Lisp object.
* Creating Keymaps:: 		Functions to create and copy keymaps.
* Inheritance and Keymaps::	How one keymap can inherit the bindings
				  of another keymap.
* Prefix Keys::                 Defining a key with a keymap as its definition.
* Menu Keymaps::		A keymap can define a menu for X
				  or for use from the terminal.
* Active Keymaps::	        Each buffer has a local keymap
                                  to override the standard (global) bindings.
				  Each minor mode can also override them.
* Key Lookup::                  How extracting elements from keymaps works.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::       Redefining a key in a keymap.
* Key Binding Commands::        Interactive interfaces for redefining keys.
* Scanning Keymaps::            Looking through all keymaps, for printing help.

Major and Minor Modes

* Major Modes::             Defining major modes.
* Minor Modes::             Defining minor modes.
* Mode Line Format::        Customizing the text that appears in the mode line.
* Hooks::                   How to use hooks; how to write code that
                              provides hooks.

Major Modes

* Major Mode Conventions::  Coding conventions for keymaps, etc.
* Example Major Modes::     Text mode and Lisp modes.
* Auto Major Mode::         How Emacs chooses the major mode automatically.
* Mode Help::               Finding out how to use a mode.

Minor Modes

* Minor Mode Conventions::  Tips for writing a minor mode.
* Keymaps and Minor Modes:: How a minor mode can have its own keymap.

Mode Line Format

* Mode Line Data::          The data structure that controls the mode line.
* Mode Line Variables::     Variables used in that data structure.
* %-Constructs::            Putting information into a mode line.

Documentation

* Documentation Basics::    Good style for doc strings.
                              Where to put them.  How Emacs stores them.
* Accessing Documentation:: How Lisp programs can access doc strings.
* Keys in Documentation::   Substituting current key bindings.
* Describing Characters::   Making printable descriptions of
                              non-printing characters and key sequences.
* Help Functions::          Subroutines used by Emacs help facilities.

Files

* Visiting Files::          Reading files into Emacs buffers for editing.
* Saving Buffers::          Writing changed buffers back into files.
* Reading from Files::      Reading files into other buffers.
* Writing to Files::        Writing new files from parts of buffers.
* File Locks::              Locking and unlocking files, to prevent
                                simultaneous editing by two people.
* Information about Files::   Testing existence, accessibility, size of files.
* Contents of Directories::   Getting a list of the files in a directory.
* Changing Files::          Renaming files, changing protection, etc.
* File Names::              Decomposing and expanding file names.

Visiting Files

* Visiting Functions::      The usual interface functions for visiting.
* Subroutines of Visiting:: Lower-level subroutines that they use.

Information about Files

* Testing Accessibility::   Is a given file readable?  Writable?
* Kinds of Files::          Is it a directory?  A link?
* File Attributes::         How large is it?  Any other names?  Etc.

File Names

* File Name Components::    The directory part of a file name, and the rest.
* Directory Names::         A directory's name as a directory
                              is different from its name as a file.
* Relative File Names::     Some file names are relative to a
                              current directory.
* File Name Expansion::     Converting relative file names to absolute ones.
* Unique File Names::       Generating names for temporary files.
* File Name Completion::    Finding the completions for a given file name.

Backups and Auto-Saving

* Backup Files::            How backup files are made; how their names
                              are chosen.
* Auto-Saving::             How auto-save files are made; how their
                              names are chosen.
* Reverting::               `revert-buffer', and how to customize
                              what it does.

Backup Files

* Making Backups::          How Emacs makes backup files, and when.
* Rename or Copy::          Two alternatives: renaming the old file
                              or copying it.
* Numbered Backups::        Keeping multiple backups for each source file.
* Backup Names::            How backup file names are computed; customization.

Buffers

* Buffer Basics::           What is a buffer?
* Buffer Names::            Accessing and changing buffer names.
* Buffer File Name::        The buffer file name indicates which file
                              is visited.
* Buffer Modification::     A buffer is "modified" if it needs to be saved.
* Modification Time::       Determining whether the visited file was changed
                              ``behind Emacs's back''.
* Read Only Buffers::       Modifying text is not allowed in a
                              read-only buffer.
* The Buffer List::         How to look at all the existing buffers.
* Creating Buffers::        Functions that create buffers.
* Killing Buffers::         Buffers exist until explicitly killed.
* Current Buffer::          Designating a buffer as current
                              so primitives will access its contents.

Windows

* Basic Windows::           Basic information on using windows.
* Splitting Windows::       Splitting one window into two windows.
* Deleting Windows::        Deleting a window gives its space to other windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each window displays the contents of a buffer.
* Displaying Buffers::      Higher-lever functions for displaying a buffer
                              and choosing a window for it.
* Window Point::            Each window has its own location of point.
* Window Start::            The display-start position controls which text
                              is on-screen in the window.
* Vertical Scrolling::      Moving text up and down in the window.
* Horizontal Scrolling::    Moving text sideways on the window.
* Size of Window::          Accessing the size of a window.
* Resizing Windows::        Changing the size of a window.
* Window Configurations::   Saving and restoring the state of the screen.

Frames

* Creating Frames::	    Creating additional frames.
* Multiple Displays::       Creating frames on other X displays.
* Frame Parameters::	    Controlling frame size, position, font, etc.
* Frame Titles::            Automatic updating of frame titles.
* Deleting Frames::	    Frames last until explicitly deleted.
* Finding All Frames::	    How to examine all existing frames.
* Frames and Windows::	    A frame contains windows;
			      display of text always works through windows.
* Minibuffers and Frames::  How a frame finds the minibuffer to use.
* Input Focus::		    Specifying the selected frame.
* Visibility of Frames::    Frames may be visible or invisible, or icons.
* Raising and Lowering::    Raising a frame makes it hide other X windows;
			      lowering it puts it underneath the others.
* Frame Configurations::    Saving the state of all frames.
* Mouse Tracking::	    Getting events that say when the mouse moves.
* Mouse Position::	    Asking where the mouse is, or moving it.
* Pop-Up Menus::	    Displaying a menu for the user to select from.
* Dialog Boxes::            Displaying a box to ask yes or no.
* Pointer Shapes::          Specifying the shape of the mouse pointer.
* Window System Selections::Transferring text to and from other windows.
* Color Names::	            Getting the definitions of color names.
* Resources::		    Getting resource values from the server.
* Display Feature Testing:: Determining the features of a terminal.

Positions

* Point::                   The special position where editing takes place.
* Motion::                  Changing point.
* Excursions::              Temporary motion and buffer changes.
* Narrowing::               Restricting editing to a portion of the buffer.

Motion

* Character Motion::        Moving in terms of characters.
* Word Motion::             Moving in terms of words.
* Buffer End Motion::       Moving to the beginning or end of the buffer.
* Text Lines::              Moving in terms of lines of text.
* Screen Lines::            Moving in terms of lines as displayed.
* List Motion::             Moving by parsing lists and sexps.
* Skipping Characters::     Skipping characters belonging to a certain set.

Markers

* Overview of Markers::     The components of a marker, and how it relocates.
* Predicates on Markers::   Testing whether an object is a marker.
* Creating Markers::        Making empty markers or markers at certain places.
* Information from Markers::  Finding the marker's buffer or character
                                position.
* Moving Markers::          Moving the marker to a new buffer or position.
* The Mark::                How ``the mark'' is implemented with a marker.
* The Region::              How to access ``the region''.

Text

* Near Point::              Examining text in the vicinity of point.
* Buffer Contents::         Examining text in a general fashion.
* Insertion::               Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::                Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::           Where removed text sometimes is saved for
                              later use.
* Undo::                    Undoing changes to the text of a buffer.
* Auto Filling::            How auto-fill mode is implemented to break lines.
* Filling::                 Functions for explicit filling.
* Margins::                 How to specify margins for filling commands.
* Sorting::                 Functions for sorting parts of the buffer.
* Indentation::             Functions to insert or adjust indentation.
* Columns::                 Computing horizontal positions, and using them.
* Case Changes::            Case conversion of parts of the buffer.
* Text Properties::         Assigning Lisp property lists to text characters.
* Substitution::            Replacing a given character wherever it appears.
* Transposition::           Swapping two portions of a buffer.
* Registers::               How registers are implemented.  Accessing
                              the text or position stored in a register.
* Change Hooks::            Supplying functions to be run when text is changed.

The Kill Ring

* Kill Ring Concepts::      What text looks like in the kill ring.
* Kill Functions::          Functions that kill text.
* Yank Commands::           Commands that access the kill ring.
* Low-Level Kill Ring::	    Functions and variables for kill ring access.
* Internals of Kill Ring::  Variables that hold kill-ring data.

Indentation

* Primitive Indent::        Functions used to count and insert indentation.
* Mode-Specific Indent::    Customize indentation for different modes.
* Region Indent::           Indent all the lines in a region.
* Relative Indent::         Indent the current line based on previous lines.
* Indent Tabs::             Adjustable, typewriter-like tab stops.
* Motion by Indent::        Move to first non-blank character.

Text Properties

* Examining Properties::    Looking at the properties of one character.
* Changing Properties::	    Setting the properties of a range of text.
* Property Search::	    Searching for where a property changes value.
* Special Properties::	    Particular properties with special meanings.
* Format Properties::       Properties for representing formatting of text.
* Sticky Properties::       How inserted text gets properties from
                              neighboring text.
* Saving Properties::       Saving text properties in files, and reading
                              them back.
* Lazy Properties::         Computing text properties in a lazy fashion
                              only when text is examined.
* Clickable Text::          Using text properties to make regions of text
                              do something when you click on them.
* Fields::                  The `field' property defines
                              fields within the buffer.
* Not Intervals::	    Why text properties do not use
			      Lisp-visible text intervals.

Non-ASCII Characters

* Text Representations::    Unibyte and multibyte representations
* Converting Representations::  Converting unibyte to multibyte and vice versa.
* Selecting a Representation::  Treating a byte sequence as unibyte or multi.
* Character Codes::         How unibyte and multibyte relate to
                                codes of individual characters.
* Character Sets::          The space of possible characters codes
                                is divided into various character sets.
* Chars and Bytes::         More information about multibyte encodings.
* Splitting Characters::    Converting a character to its byte sequence.
* Scanning Charsets::       Which character sets are used in a buffer?
* Translation of Characters::   Translation tables are used for conversion.
* Coding Systems::          Coding systems are conversions for saving files.
* Input Methods::           Input methods allow users to enter various
                                non-ASCII characters without special keyboards.
* Locales::                 Interacting with the POSIX locale.

Searching and Matching

* String Search::           Search for an exact match.
* Regular Expressions::     Describing classes of strings.
* Regexp Search::           Searching for a match for a regexp.
* Match Data::              Finding out which part of the text matched
                              various parts of a regexp, after regexp search.
* Saving Match Data::       Saving and restoring this information.
* Standard Regexps::        Useful regexps for finding sentences, pages,...
* Searching and Case::      Case-independent or case-significant searching.

Regular Expressions

* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.

Syntax Tables

* Syntax Descriptors::      How characters are classified.
* Syntax Table Functions::  How to create, examine and alter syntax tables.
* Parsing Expressions::     Parsing balanced expressions
                              using the syntax table.
* Standard Syntax Tables::  Syntax tables used by various major modes.
* Syntax Table Internals::  How syntax table information is stored.

Syntax Descriptors

* Syntax Class Table::      Table of syntax classes.
* Syntax Flags::            Additional flags each character can have.

Abbrevs And Abbrev Expansion

* Abbrev Mode::             Setting up Emacs for abbreviation.
* Tables: Abbrev Tables.    Creating and working with abbrev tables.
* Defining Abbrevs::        Specifying abbreviations and their expansions.
* Files: Abbrev Files.      Saving abbrevs in files.
* Expansion: Abbrev Expansion.  Controlling expansion; expansion subroutines.
* Standard Abbrev Tables::  Abbrev tables used by various major modes.

Processes

* Subprocess Creation::     Functions that start subprocesses.
* Synchronous Processes::   Details of using synchronous subprocesses.
* Asynchronous Processes::  Starting up an asynchronous subprocess.
* Deleting Processes::      Eliminating an asynchronous subprocess.
* Process Information::     Accessing run-status and other attributes.
* Input to Processes::      Sending input to an asynchronous subprocess.
* Signals to Processes::    Stopping, continuing or interrupting
                              an asynchronous subprocess.
* Output from Processes::   Collecting output from an asynchronous subprocess.
* Sentinels::               Sentinels run when process run-status changes.
* Network::                 Opening network connections.

Receiving Output from Processes

* Process Buffers::         If no filter, output is put in a buffer.
* Filter Functions::        Filter functions accept output from the process.
* Accepting Output::        How to wait until process output arrives.

Operating System Interface

* Starting Up::             Customizing Emacs start-up processing.
* Getting Out::             How exiting works (permanent or temporary).
* System Environment::      Distinguish the name and kind of system.
* Terminal Input::          Recording terminal input for debugging.
* Terminal Output::         Recording terminal output for debugging.
* Flow Control::            How to turn output flow control on or off.
* Batch Mode::              Running Emacs without terminal interaction.

Starting Up Emacs

* Startup Summary::         Sequence of actions Emacs performs at start-up.
* Init File::               Details on reading the init file (`.emacs').
* Terminal-Specific::       How the terminal-specific Lisp file is read.
* Command-Line Arguments::  How command line arguments are processed,
                              and how you can customize them.

Getting out of Emacs

* Killing Emacs::           Exiting Emacs irreversibly.
* Suspending Emacs::        Exiting Emacs reversibly.

Emacs Display

* Refresh Screen::          Clearing the screen and redrawing everything on it.
* Truncation::              Folding or wrapping long text lines.
* The Echo Area::           Where messages are displayed.
* Selective Display::       Hiding part of the buffer text.
* Overlay Arrow::           Display of an arrow to indicate position.
* Temporary Displays::      Displays that go away automatically.
* Waiting::                 Forcing display update and waiting for user.
* Blinking::                How Emacs shows the matching open parenthesis.
* Usual Display::	    How control characters are displayed.
* Beeping::                 Audible signal to the user.
* Window Systems::          Which window system is being used.

GNU Emacs Internals

* Building Emacs::          How to preload Lisp libraries into Emacs.
* Pure Storage::            A kludge to make preloaded Lisp functions sharable.
* Garbage Collection::      Reclaiming space for Lisp objects no longer used.
* Object Internals::        Data formats of buffers, windows, processes.
* Writing Emacs Primitives::  Writing C code for Emacs.

Object Internals

* Buffer Internals::        Components of a buffer structure.
* Window Internals::        Components of a window structure.
* Process Internals::       Components of a process structure.


File: elisp,  Node: Introduction,  Next: Lisp Data Types,  Prev: Top,  Up: Top

Introduction
************

   Most of the GNU Emacs text editor is written in the programming
language called Emacs Lisp.  You can write new code in Emacs Lisp and
install it as an extension to the editor.  However, Emacs Lisp is more
than a mere "extension language"; it is a full computer programming
language in its own right.  You can use it as you would any other
programming language.

   Because Emacs Lisp is designed for use in an editor, it has special
features for scanning and parsing text as well as features for handling
files, buffers, displays, subprocesses, and so on.  Emacs Lisp is
closely integrated with the editing facilities; thus, editing commands
are functions that can also conveniently be called from Lisp programs,
and parameters for customization are ordinary Lisp variables.

   This manual attempts to be a full description of Emacs Lisp.  For a
beginner's introduction to Emacs Lisp, see `An Introduction to Emacs
Lisp Programming', by Bob Chassell, also published by the Free Software
Foundation.  This manual presumes considerable familiarity with the use
of Emacs for editing; see `The GNU Emacs Manual' for this basic
information.

   Generally speaking, the earlier chapters describe features of Emacs
Lisp that have counterparts in many programming languages, and later
chapters describe features that are peculiar to Emacs Lisp or relate
specifically to editing.

   This is edition 2.8.

* Menu:

* Caveats::             Flaws and a request for help.
* Lisp History::        Emacs Lisp is descended from Maclisp.
* Conventions::         How the manual is formatted.
* Version Info::        Which Emacs version is running?
* Acknowledgements::    The authors, editors, and sponsors of this manual.


File: elisp,  Node: Caveats,  Next: Lisp History,  Up: Introduction

Caveats
=======

   This manual has gone through numerous drafts.  It is nearly complete
but not flawless.  There are a few topics that are not covered, either
because we consider them secondary (such as most of the individual
modes) or because they are yet to be written.  Because we are not able
to deal with them completely, we have left out several parts
intentionally.  This includes most information about usage on VMS.

   The manual should be fully correct in what it does cover, and it is
therefore open to criticism on anything it says--from specific examples
and descriptive text, to the ordering of chapters and sections.  If
something is confusing, or you find that you have to look at the sources
or experiment to learn something not covered in the manual, then perhaps
the manual should be fixed.  Please let us know.

   As you use this manual, we ask that you send corrections as soon as
you find them.  If you think of a simple, real life example for a
function or group of functions, please make an effort to write it up
and send it in.  Please reference any comments to the node name and
function or variable name, as appropriate.  Also state the number of
the edition you are criticizing.

   Please mail comments and corrections to

     bug-lisp-manual@gnu.org

We let mail to this list accumulate unread until someone decides to
apply the corrections.  Months, and sometimes years, go by between
updates.  So please attach no significance to the lack of a reply--your
mail _will_ be acted on in due time.  If you want to contact the Emacs
maintainers more quickly, send mail to `bug-gnu-emacs@gnu.org'.


File: elisp,  Node: Lisp History,  Next: Conventions,  Prev: Caveats,  Up: Introduction

Lisp History
============

   Lisp (LISt Processing language) was first developed in the late 1950s
at the Massachusetts Institute of Technology for research in artificial
intelligence.  The great power of the Lisp language makes it ideal for
other purposes as well, such as writing editing commands.

   Dozens of Lisp implementations have been built over the years, each
with its own idiosyncrasies.  Many of them were inspired by Maclisp,
which was written in the 1960s at MIT's Project MAC.  Eventually the
implementors of the descendants of Maclisp came together and developed a
standard for Lisp systems, called Common Lisp.  In the meantime, Gerry
Sussman and Guy Steele at MIT developed a simplified but very powerful
dialect of Lisp, called Scheme.

   GNU Emacs Lisp is largely inspired by Maclisp, and a little by Common
Lisp.  If you know Common Lisp, you will notice many similarities.
However, many features of Common Lisp have been omitted or simplified
in order to reduce the memory requirements of GNU Emacs.  Sometimes the
simplifications are so drastic that a Common Lisp user might be very
confused.  We will occasionally point out how GNU Emacs Lisp differs
from Common Lisp.  If you don't know Common Lisp, don't worry about it;
this manual is self-contained.

   A certain amount of Common Lisp emulation is available via the `cl'
library.  *Note Common Lisp Extension: (cl)Top.

   Emacs Lisp is not at all influenced by Scheme; but the GNU project
has an implementation of Scheme, called Guile.  We use Guile in all new
GNU software that calls for extensibility.


File: elisp,  Node: Conventions,  Next: Version Info,  Prev: Lisp History,  Up: Introduction

Conventions
===========

   This section explains the notational conventions that are used in
this manual.  You may want to skip this section and refer back to it
later.

* Menu:

* Some Terms::               Explanation of terms we use in this manual.
* nil and t::                How the symbols `nil' and `t' are used.
* Evaluation Notation::      The format we use for examples of evaluation.
* Printing Notation::        The format we use when examples print text.
* Error Messages::           The format we use for examples of errors.
* Buffer Text Notation::     The format we use for buffer contents in examples.
* Format of Descriptions::   Notation for describing functions, variables, etc.


File: elisp,  Node: Some Terms,  Next: nil and t,  Up: Conventions

Some Terms
----------

   Throughout this manual, the phrases "the Lisp reader" and "the Lisp
printer" refer to those routines in Lisp that convert textual
representations of Lisp objects into actual Lisp objects, and vice
versa.  *Note Printed Representation::, for more details.  You, the
person reading this manual, are thought of as "the programmer" and are
addressed as "you".  "The user" is the person who uses Lisp programs,
including those you write.

   Examples of Lisp code are formatted like this: `(list 1 2 3)'.
Names that represent metasyntactic variables, or arguments to a function
being described, are formatted like this: FIRST-NUMBER.


File: elisp,  Node: nil and t,  Next: Evaluation Notation,  Prev: Some Terms,  Up: Conventions

`nil' and `t'
-------------

   In Lisp, the symbol `nil' has three separate meanings: it is a
symbol with the name `nil'; it is the logical truth value FALSE; and it
is the empty list--the list of zero elements.  When used as a variable,
`nil' always has the value `nil'.

   As far as the Lisp reader is concerned, `()' and `nil' are
identical: they stand for the same object, the symbol `nil'.  The
different ways of writing the symbol are intended entirely for human
readers.  After the Lisp reader has read either `()' or `nil', there is
no way to determine which representation was actually written by the
programmer.

   In this manual, we use `()' when we wish to emphasize that it means
the empty list, and we use `nil' when we wish to emphasize that it
means the truth value FALSE.  That is a good convention to use in Lisp
programs also.

     (cons 'foo ())                ; Emphasize the empty list
     (not nil)                     ; Emphasize the truth value FALSE

   In contexts where a truth value is expected, any non-`nil' value is
considered to be TRUE.  However, `t' is the preferred way to represent
the truth value TRUE.  When you need to choose a value which represents
TRUE, and there is no other basis for choosing, use `t'.  The symbol
`t' always has the value `t'.

   In Emacs Lisp, `nil' and `t' are special symbols that always
evaluate to themselves.  This is so that you do not need to quote them
to use them as constants in a program.  An attempt to change their
values results in a `setting-constant' error.  The same is true of any
symbol whose name starts with a colon (`:').  *Note Constant
Variables::.


File: elisp,  Node: Evaluation Notation,  Next: Printing Notation,  Prev: nil and t,  Up: Conventions

Evaluation Notation
-------------------

   A Lisp expression that you can evaluate is called a "form".
Evaluating a form always produces a result, which is a Lisp object.  In
the examples in this manual, this is indicated with `=>':

     (car '(1 2))
          => 1

You can read this as "`(car '(1 2))' evaluates to 1".

   When a form is a macro call, it expands into a new form for Lisp to
evaluate.  We show the result of the expansion with `==>'.  We may or
may not show the result of the evaluation of the expanded form.

     (third '(a b c))
          ==> (car (cdr (cdr '(a b c))))
          => c

   Sometimes to help describe one form we show another form that
produces identical results.  The exact equivalence of two forms is
indicated with `=='.

     (make-sparse-keymap) == (list 'keymap)


File: elisp,  Node: Printing Notation,  Next: Error Messages,  Prev: Evaluation Notation,  Up: Conventions

Printing Notation
-----------------

   Many of the examples in this manual print text when they are
evaluated.  If you execute example code in a Lisp Interaction buffer
(such as the buffer `*scratch*'), the printed text is inserted into the
buffer.  If you execute the example by other means (such as by
evaluating the function `eval-region'), the printed text is displayed
in the echo area.

   Examples in this manual indicate printed text with `-|',
irrespective of where that text goes.  The value returned by evaluating
the form (here `bar') follows on a separate line.

     (progn (print 'foo) (print 'bar))
          -| foo
          -| bar
          => bar


File: elisp,  Node: Error Messages,  Next: Buffer Text Notation,  Prev: Printing Notation,  Up: Conventions

Error Messages
--------------

   Some examples signal errors.  This normally displays an error message
in the echo area.  We show the error message on a line starting with
`error-->'.  Note that `error-->' itself does not appear in the echo
area.

     (+ 23 'x)
     error--> Wrong type argument: number-or-marker-p, x

