This is elisp, produced by makeinfo version 4.0f from ./elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This Info file contains edition 2.8 of the GNU Emacs Lisp Reference
Manual, corresponding to Emacs version 21.2.

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
2000, 2001, 2002 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Copying", with the Front-Cover texts being "A
GNU Manual", and with the Back-Cover Texts as in (a) below.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: elisp,  Node: Variable Scoping,  Next: Buffer-Local Variables,  Prev: Setting Variables,  Up: Variables

Scoping Rules for Variable Bindings
===================================

   A given symbol `foo' can have several local variable bindings,
established at different places in the Lisp program, as well as a global
binding.  The most recently established binding takes precedence over
the others.

   Local bindings in Emacs Lisp have "indefinite scope" and "dynamic
extent".  "Scope" refers to _where_ textually in the source code the
binding can be accessed.  "Indefinite scope" means that any part of the
program can potentially access the variable binding.  "Extent" refers
to _when_, as the program is executing, the binding exists.  "Dynamic
extent" means that the binding lasts as long as the activation of the
construct that established it.

   The combination of dynamic extent and indefinite scope is called
"dynamic scoping".  By contrast, most programming languages use
"lexical scoping", in which references to a local variable must be
located textually within the function or block that binds the variable.

     Common Lisp note: Variables declared "special" in Common Lisp are
     dynamically scoped, like all variables in Emacs Lisp.

* Menu:

* Scope::          Scope means where in the program a value is visible.
                     Comparison with other languages.
* Extent::         Extent means how long in time a value exists.
* Impl of Scope::  Two ways to implement dynamic scoping.
* Using Scoping::  How to use dynamic scoping carefully and avoid problems.


File: elisp,  Node: Scope,  Next: Extent,  Up: Variable Scoping

Scope
-----

   Emacs Lisp uses "indefinite scope" for local variable bindings.
This means that any function anywhere in the program text might access a
given binding of a variable.  Consider the following function
definitions:

     (defun binder (x)   ; `x' is bound in `binder'.
        (foo 5))         ; `foo' is some other function.
     
     (defun user ()      ; `x' is used "free" in `user'.
       (list x))

   In a lexically scoped language, the binding of `x' in `binder' would
never be accessible in `user', because `user' is not textually
contained within the function `binder'.  However, in dynamically-scoped
Emacs Lisp, `user' may or may not refer to the binding of `x'
established in `binder', depending on the circumstances:

   * If we call `user' directly without calling `binder' at all, then
     whatever binding of `x' is found, it cannot come from `binder'.

   * If we define `foo' as follows and then call `binder', then the
     binding made in `binder' will be seen in `user':

          (defun foo (lose)
            (user))

   * However, if we define `foo' as follows and then call `binder',
     then the binding made in `binder' _will not_ be seen in `user':

          (defun foo (x)
            (user))

     Here, when `foo' is called by `binder', it binds `x'.  (The
     binding in `foo' is said to "shadow" the one made in `binder'.)
     Therefore, `user' will access the `x' bound by `foo' instead of
     the one bound by `binder'.

   Emacs Lisp uses dynamic scoping because simple implementations of
lexical scoping are slow.  In addition, every Lisp system needs to offer
dynamic scoping at least as an option; if lexical scoping is the norm,
there must be a way to specify dynamic scoping instead for a particular
variable.  It might not be a bad thing for Emacs to offer both, but
implementing it with dynamic scoping only was much easier.


File: elisp,  Node: Extent,  Next: Impl of Scope,  Prev: Scope,  Up: Variable Scoping

Extent
------

   "Extent" refers to the time during program execution that a variable
name is valid.  In Emacs Lisp, a variable is valid only while the form
that bound it is executing.  This is called "dynamic extent".  "Local"
or "automatic" variables in most languages, including C and Pascal,
have dynamic extent.

   One alternative to dynamic extent is "indefinite extent".  This
means that a variable binding can live on past the exit from the form
that made the binding.  Common Lisp and Scheme, for example, support
this, but Emacs Lisp does not.

   To illustrate this, the function below, `make-add', returns a
function that purports to add N to its own argument M.  This would work
in Common Lisp, but it does not do the job in Emacs Lisp, because after
the call to `make-add' exits, the variable `n' is no longer bound to
the actual argument 2.

     (defun make-add (n)
         (function (lambda (m) (+ n m))))  ; Return a function.
          => make-add
     (fset 'add2 (make-add 2))  ; Define function `add2'
                                ;   with `(make-add 2)'.
          => (lambda (m) (+ n m))
     (add2 4)                   ; Try to add 2 to 4.
     error--> Symbol's value as variable is void: n

   Some Lisp dialects have "closures", objects that are like functions
but record additional variable bindings.  Emacs Lisp does not have
closures.


File: elisp,  Node: Impl of Scope,  Next: Using Scoping,  Prev: Extent,  Up: Variable Scoping

Implementation of Dynamic Scoping
---------------------------------

   A simple sample implementation (which is not how Emacs Lisp actually
works) may help you understand dynamic binding.  This technique is
called "deep binding" and was used in early Lisp systems.

   Suppose there is a stack of bindings, which are variable-value pairs.
At entry to a function or to a `let' form, we can push bindings onto
the stack for the arguments or local variables created there.  We can
pop those bindings from the stack at exit from the binding construct.

   We can find the value of a variable by searching the stack from top
to bottom for a binding for that variable; the value from that binding
is the value of the variable.  To set the variable, we search for the
current binding, then store the new value into that binding.

   As you can see, a function's bindings remain in effect as long as it
continues execution, even during its calls to other functions.  That is
why we say the extent of the binding is dynamic.  And any other function
can refer to the bindings, if it uses the same variables while the
bindings are in effect.  That is why we say the scope is indefinite.

   The actual implementation of variable scoping in GNU Emacs Lisp uses
a technique called "shallow binding".  Each variable has a standard
place in which its current value is always found--the value cell of the
symbol.

   In shallow binding, setting the variable works by storing a value in
the value cell.  Creating a new binding works by pushing the old value
(belonging to a previous binding) onto a stack, and storing the new
local value in the value cell.  Eliminating a binding works by popping
the old value off the stack, into the value cell.

   We use shallow binding because it has the same results as deep
binding, but runs faster, since there is never a need to search for a
binding.


File: elisp,  Node: Using Scoping,  Prev: Impl of Scope,  Up: Variable Scoping

Proper Use of Dynamic Scoping
-----------------------------

   Binding a variable in one function and using it in another is a
powerful technique, but if used without restraint, it can make programs
hard to understand.  There are two clean ways to use this technique:

   * Use or bind the variable only in a few related functions, written
     close together in one file.  Such a variable is used for
     communication within one program.

     You should write comments to inform other programmers that they
     can see all uses of the variable before them, and to advise them
     not to add uses elsewhere.

   * Give the variable a well-defined, documented meaning, and make all
     appropriate functions refer to it (but not bind it or set it)
     wherever that meaning is relevant.  For example, the variable
     `case-fold-search' is defined as "non-`nil' means ignore case when
     searching"; various search and replace functions refer to it
     directly or through their subroutines, but do not bind or set it.

     Then you can bind the variable in other programs, knowing reliably
     what the effect will be.

   In either case, you should define the variable with `defvar'.  This
helps other people understand your program by telling them to look for
inter-function usage.  It also avoids a warning from the byte compiler.
Choose the variable's name to avoid name conflicts--don't use short
names like `x'.


File: elisp,  Node: Buffer-Local Variables,  Next: Frame-Local Variables,  Prev: Variable Scoping,  Up: Variables

Buffer-Local Variables
======================

   Global and local variable bindings are found in most programming
languages in one form or another.  Emacs, however, also supports
additional, unusual kinds of variable binding: "buffer-local" bindings,
which apply only in one buffer, and "frame-local" bindings, which apply
only in one frame.  Having different values for a variable in different
buffers and/or frames is an important customization method.

   This section describes buffer-local bindings; for frame-local
bindings, see the following section, *Note Frame-Local Variables::.  (A
few variables have bindings that are local to each terminal; see *Note
Multiple Displays::.)

* Menu:

* Intro to Buffer-Local::      Introduction and concepts.
* Creating Buffer-Local::      Creating and destroying buffer-local bindings.
* Default Value::              The default value is seen in buffers
                                 that don't have their own buffer-local values.


File: elisp,  Node: Intro to Buffer-Local,  Next: Creating Buffer-Local,  Up: Buffer-Local Variables

Introduction to Buffer-Local Variables
--------------------------------------

   A buffer-local variable has a buffer-local binding associated with a
particular buffer.  The binding is in effect when that buffer is
current; otherwise, it is not in effect.  If you set the variable while
a buffer-local binding is in effect, the new value goes in that binding,
so its other bindings are unchanged.  This means that the change is
visible only in the buffer where you made it.

   The variable's ordinary binding, which is not associated with any
specific buffer, is called the "default binding".  In most cases, this
is the global binding.

   A variable can have buffer-local bindings in some buffers but not in
other buffers.  The default binding is shared by all the buffers that
don't have their own bindings for the variable.  (This includes all
newly-created buffers.)  If you set the variable in a buffer that does
not have a buffer-local binding for it, this sets the default binding
(assuming there are no frame-local bindings to complicate the matter),
so the new value is visible in all the buffers that see the default
binding.

   The most common use of buffer-local bindings is for major modes to
change variables that control the behavior of commands.  For example, C
mode and Lisp mode both set the variable `paragraph-start' to specify
that only blank lines separate paragraphs.  They do this by making the
variable buffer-local in the buffer that is being put into C mode or
Lisp mode, and then setting it to the new value for that mode.  *Note
Major Modes::.

   The usual way to make a buffer-local binding is with
`make-local-variable', which is what major mode commands typically use.
This affects just the current buffer; all other buffers (including
those yet to be created) will continue to share the default value unless
they are explicitly given their own buffer-local bindings.

   A more powerful operation is to mark the variable as "automatically
buffer-local" by calling `make-variable-buffer-local'.  You can think
of this as making the variable local in all buffers, even those yet to
be created.  More precisely, the effect is that setting the variable
automatically makes the variable local to the current buffer if it is
not already so.  All buffers start out by sharing the default value of
the variable as usual, but setting the variable creates a buffer-local
binding for the current buffer.  The new value is stored in the
buffer-local binding, leaving the default binding untouched.  This
means that the default value cannot be changed with `setq' in any
buffer; the only way to change it is with `setq-default'.

   *Warning:* When a variable has buffer-local values in one or more
buffers, you can get Emacs very confused by binding the variable with
`let', changing to a different current buffer in which a different
binding is in effect, and then exiting the `let'.  This can scramble
the values of the buffer-local and default bindings.

   To preserve your sanity, avoid using a variable in that way.  If you
use `save-excursion' around each piece of code that changes to a
different current buffer, you will not have this problem (*note
Excursions::).  Here is an example of what to avoid:

     (setq foo 'b)
     (set-buffer "a")
     (make-local-variable 'foo)
     (setq foo 'a)
     (let ((foo 'temp))
       (set-buffer "b")
       BODY...)
     foo => 'a      ; The old buffer-local value from buffer `a'
                    ;   is now the default value.
     (set-buffer "a")
     foo => 'temp   ; The local `let' value that should be gone
                    ;   is now the buffer-local value in buffer `a'.

But `save-excursion' as shown here avoids the problem:

     (let ((foo 'temp))
       (save-excursion
         (set-buffer "b")
         BODY...))

   Note that references to `foo' in BODY access the buffer-local
binding of buffer `b'.

   When a file specifies local variable values, these become
buffer-local values when you visit the file.  *Note File Variables:
(emacs)File Variables.


File: elisp,  Node: Creating Buffer-Local,  Next: Default Value,  Prev: Intro to Buffer-Local,  Up: Buffer-Local Variables

Creating and Deleting Buffer-Local Bindings
-------------------------------------------

 - Command: make-local-variable variable
     This function creates a buffer-local binding in the current buffer
     for VARIABLE (a symbol).  Other buffers are not affected.  The
     value returned is VARIABLE.

     The buffer-local value of VARIABLE starts out as the same value
     VARIABLE previously had.  If VARIABLE was void, it remains void.

          ;; In buffer `b1':
          (setq foo 5)                ; Affects all buffers.
               => 5
          (make-local-variable 'foo)  ; Now it is local in `b1'.
               => foo
          foo                         ; That did not change
               => 5                   ;   the value.
          (setq foo 6)                ; Change the value
               => 6                   ;   in `b1'.
          foo
               => 6
          
          ;; In buffer `b2', the value hasn't changed.
          (save-excursion
            (set-buffer "b2")
            foo)
               => 5

     Making a variable buffer-local within a `let'-binding for that
     variable does not work reliably, unless the buffer in which you do
     this is not current either on entry to or exit from the `let'.
     This is because `let' does not distinguish between different kinds
     of bindings; it knows only which variable the binding was made for.

     If the variable is terminal-local, this function signals an error.
     Such variables cannot have buffer-local bindings as well.  *Note
     Multiple Displays::.

     *Note:* Do not use `make-local-variable' for a hook variable.
     Instead, use `make-local-hook'.  *Note Hooks::.

 - Command: make-variable-buffer-local variable
     This function marks VARIABLE (a symbol) automatically
     buffer-local, so that any subsequent attempt to set it will make it
     local to the current buffer at the time.

     A peculiar wrinkle of this feature is that binding the variable
     (with `let' or other binding constructs) does not create a
     buffer-local binding for it.  Only setting the variable (with
     `set' or `setq') does so.

     The value returned is VARIABLE.

     *Warning:* Don't assume that you should use
     `make-variable-buffer-local' for user-option variables, simply
     because users _might_ want to customize them differently in
     different buffers.  Users can make any variable local, when they
     wish to.  It is better to leave the choice to them.

     The time to use `make-variable-buffer-local' is when it is crucial
     that no two buffers ever share the same binding.  For example,
     when a variable is used for internal purposes in a Lisp program
     which depends on having separate values in separate buffers, then
     using `make-variable-buffer-local' can be the best solution.

 - Function: local-variable-p variable &optional buffer
     This returns `t' if VARIABLE is buffer-local in buffer BUFFER
     (which defaults to the current buffer); otherwise, `nil'.

 - Function: buffer-local-variables &optional buffer
     This function returns a list describing the buffer-local variables
     in buffer BUFFER.  (If BUFFER is omitted, the current buffer is
     used.)  It returns an association list (*note Association Lists::)
     in which each element contains one buffer-local variable and its
     value.  However, when a variable's buffer-local binding in BUFFER
     is void, then the variable appears directly in the resulting list.

          (make-local-variable 'foobar)
          (makunbound 'foobar)
          (make-local-variable 'bind-me)
          (setq bind-me 69)
          (setq lcl (buffer-local-variables))
              ;; First, built-in variables local in all buffers:
          => ((mark-active . nil)
              (buffer-undo-list . nil)
              (mode-name . "Fundamental")
              ...
              ;; Next, non-built-in buffer-local variables.
              ;; This one is buffer-local and void:
              foobar
              ;; This one is buffer-local and nonvoid:
              (bind-me . 69))

     Note that storing new values into the CDRs of cons cells in this
     list does _not_ change the buffer-local values of the variables.

 - Command: kill-local-variable variable
     This function deletes the buffer-local binding (if any) for
     VARIABLE (a symbol) in the current buffer.  As a result, the
     default binding of VARIABLE becomes visible in this buffer.  This
     typically results in a change in the value of VARIABLE, since the
     default value is usually different from the buffer-local value just
     eliminated.

     If you kill the buffer-local binding of a variable that
     automatically becomes buffer-local when set, this makes the
     default value visible in the current buffer.  However, if you set
     the variable again, that will once again create a buffer-local
     binding for it.

     `kill-local-variable' returns VARIABLE.

     This function is a command because it is sometimes useful to kill
     one buffer-local variable interactively, just as it is useful to
     create buffer-local variables interactively.

 - Function: kill-all-local-variables
     This function eliminates all the buffer-local variable bindings of
     the current buffer except for variables marked as "permanent".  As
     a result, the buffer will see the default values of most variables.

     This function also resets certain other information pertaining to
     the buffer: it sets the local keymap to `nil', the syntax table to
     the value of `(standard-syntax-table)', the case table to
     `(standard-case-table)', and the abbrev table to the value of
     `fundamental-mode-abbrev-table'.

     The very first thing this function does is run the normal hook
     `change-major-mode-hook' (see below).

     Every major mode command begins by calling this function, which
     has the effect of switching to Fundamental mode and erasing most
     of the effects of the previous major mode.  To ensure that this
     does its job, the variables that major modes set should not be
     marked permanent.

     `kill-all-local-variables' returns `nil'.

 - Variable: change-major-mode-hook
     The function `kill-all-local-variables' runs this normal hook
     before it does anything else.  This gives major modes a way to
     arrange for something special to be done if the user switches to a
     different major mode.  For best results, make this variable
     buffer-local, so that it will disappear after doing its job and
     will not interfere with the subsequent major mode.  *Note Hooks::.

   A buffer-local variable is "permanent" if the variable name (a
symbol) has a `permanent-local' property that is non-`nil'.  Permanent
locals are appropriate for data pertaining to where the file came from
or how to save it, rather than with how to edit the contents.


File: elisp,  Node: Default Value,  Prev: Creating Buffer-Local,  Up: Buffer-Local Variables

The Default Value of a Buffer-Local Variable
--------------------------------------------

   The global value of a variable with buffer-local bindings is also
called the "default" value, because it is the value that is in effect
whenever neither the current buffer nor the selected frame has its own
binding for the variable.

   The functions `default-value' and `setq-default' access and change a
variable's default value regardless of whether the current buffer has a
buffer-local binding.  For example, you could use `setq-default' to
change the default setting of `paragraph-start' for most buffers; and
this would work even when you are in a C or Lisp mode buffer that has a
buffer-local value for this variable.

   The special forms `defvar' and `defconst' also set the default value
(if they set the variable at all), rather than any buffer-local or
frame-local value.

 - Function: default-value symbol
     This function returns SYMBOL's default value.  This is the value
     that is seen in buffers and frames that do not have their own
     values for this variable.  If SYMBOL is not buffer-local, this is
     equivalent to `symbol-value' (*note Accessing Variables::).

 - Function: default-boundp symbol
     The function `default-boundp' tells you whether SYMBOL's default
     value is nonvoid.  If `(default-boundp 'foo)' returns `nil', then
     `(default-value 'foo)' would get an error.

     `default-boundp' is to `default-value' as `boundp' is to
     `symbol-value'.

 - Special Form: setq-default [symbol form]...
     This special form gives each SYMBOL a new default value, which is
     the result of evaluating the corresponding FORM.  It does not
     evaluate SYMBOL, but does evaluate FORM.  The value of the
     `setq-default' form is the value of the last FORM.

     If a SYMBOL is not buffer-local for the current buffer, and is not
     marked automatically buffer-local, `setq-default' has the same
     effect as `setq'.  If SYMBOL is buffer-local for the current
     buffer, then this changes the value that other buffers will see
     (as long as they don't have a buffer-local value), but not the
     value that the current buffer sees.

          ;; In buffer `foo':
          (make-local-variable 'buffer-local)
               => buffer-local
          (setq buffer-local 'value-in-foo)
               => value-in-foo
          (setq-default buffer-local 'new-default)
               => new-default
          buffer-local
               => value-in-foo
          (default-value 'buffer-local)
               => new-default
          
          ;; In (the new) buffer `bar':
          buffer-local
               => new-default
          (default-value 'buffer-local)
               => new-default
          (setq buffer-local 'another-default)
               => another-default
          (default-value 'buffer-local)
               => another-default
          
          ;; Back in buffer `foo':
          buffer-local
               => value-in-foo
          (default-value 'buffer-local)
               => another-default

 - Function: set-default symbol value
     This function is like `setq-default', except that SYMBOL is an
     ordinary evaluated argument.

          (set-default (car '(a b c)) 23)
               => 23
          (default-value 'a)
               => 23


File: elisp,  Node: Frame-Local Variables,  Next: Future Local Variables,  Prev: Buffer-Local Variables,  Up: Variables

Frame-Local Variables
=====================

   Just as variables can have buffer-local bindings, they can also have
frame-local bindings.  These bindings belong to one frame, and are in
effect when that frame is selected.  Frame-local bindings are actually
frame parameters: you create a frame-local binding in a specific frame
by calling `modify-frame-parameters' and specifying the variable name
as the parameter name.

   To enable frame-local bindings for a certain variable, call the
function `make-variable-frame-local'.

 - Command: make-variable-frame-local variable
     Enable the use of frame-local bindings for VARIABLE.  This does
     not in itself create any frame-local bindings for the variable;
     however, if some frame already has a value for VARIABLE as a frame
     parameter, that value automatically becomes a frame-local binding.

     If the variable is terminal-local, this function signals an error,
     because such variables cannot have frame-local bindings as well.
     *Note Multiple Displays::.  A few variables that are implemented
     specially in Emacs can be (and usually are) buffer-local, but can
     never be frame-local.

   Buffer-local bindings take precedence over frame-local bindings.
Thus, consider a variable `foo': if the current buffer has a
buffer-local binding for `foo', that binding is active; otherwise, if
the selected frame has a frame-local binding for `foo', that binding is
active; otherwise, the default binding of `foo' is active.

   Here is an example.  First we prepare a few bindings for `foo':

     (setq f1 (selected-frame))
     (make-variable-frame-local 'foo)
     
     ;; Make a buffer-local binding for `foo' in `b1'.
     (set-buffer (get-buffer-create "b1"))
     (make-local-variable 'foo)
     (setq foo '(b 1))
     
     ;; Make a frame-local binding for `foo' in a new frame.
     ;; Store that frame in `f2'.
     (setq f2 (make-frame))
     (modify-frame-parameters f2 '((foo . (f 2))))

   Now we examine `foo' in various contexts.  Whenever the buffer `b1'
is current, its buffer-local binding is in effect, regardless of the
selected frame:

     (select-frame f1)
     (set-buffer (get-buffer-create "b1"))
     foo
          => (b 1)
     
     (select-frame f2)
     (set-buffer (get-buffer-create "b1"))
     foo
          => (b 1)

Otherwise, the frame gets a chance to provide the binding; when frame
`f2' is selected, its frame-local binding is in effect:

     (select-frame f2)
     (set-buffer (get-buffer "*scratch*"))
     foo
          => (f 2)

When neither the current buffer nor the selected frame provides a
binding, the default binding is used:

     (select-frame f1)
     (set-buffer (get-buffer "*scratch*"))
     foo
          => nil

When the active binding of a variable is a frame-local binding, setting
the variable changes that binding.  You can observe the result with
`frame-parameters':

     (select-frame f2)
     (set-buffer (get-buffer "*scratch*"))
     (setq foo 'nobody)
     (assq 'foo (frame-parameters f2))
          => (foo . nobody)


File: elisp,  Node: Future Local Variables,  Next: File Local Variables,  Prev: Frame-Local Variables,  Up: Variables

Possible Future Local Variables
===============================

   We have considered the idea of bindings that are local to a category
of frames--for example, all color frames, or all frames with dark
backgrounds.  We have not implemented them because it is not clear that
this feature is really useful.  You can get more or less the same
results by adding a function to `after-make-frame-functions', set up to
define a particular frame parameter according to the appropriate
conditions for each frame.

   It would also be possible to implement window-local bindings.  We
don't know of many situations where they would be useful, and it seems
that indirect buffers (*note Indirect Buffers::) with buffer-local
bindings offer a way to handle these situations more robustly.

   If sufficient application is found for either of these two kinds of
local bindings, we will provide it in a subsequent Emacs version.


File: elisp,  Node: File Local Variables,  Prev: Future Local Variables,  Up: Variables

File Local Variables
====================

   This section describes the functions and variables that affect
processing of local variables lists in files.

 - User Option: enable-local-variables
     This variable controls whether to process file local variables
     lists.  A value of `t' means process the local variables lists
     unconditionally; `nil' means ignore them; anything else means ask
     the user what to do for each file.  The default value is `t'.

 - Function: hack-local-variables &optional force
     This function parses, and binds or evaluates as appropriate, any
     local variables specified by the contents of the current buffer.
     The variable `enable-local-variables' has its effect here.

     The argument FORCE usually comes from the argument FIND-FILE given
     to `normal-mode'.

   If a file local variable list could specify the a function that will
be called later, or an expression that will be executed later, simply
visiting a file could take over your Emacs.  To prevent this, Emacs
takes care not to allow local variable lists to set such variables.

   For one thing, any variable whose name ends in `-function',
`-functions', `-hook', `-hooks', `-form', `-forms', `-program',
`-command' or `-predicate' cannot be set in a local variable list.  In
general, you should use such a name whenever it is appropriate for the
variable's meaning.

   In addition, any variable whose name has a non-`nil'
`risky-local-variable' property is also ignored.  So are all variables
listed in `ignored-local-variables':

 - Variable: ignored-local-variables
     This variable holds a list of variables that should not be set by
     a file's local variables list.  Any value specified for one of
     these variables is ignored.

   The `Eval:' "variable" is also a potential loophole, so Emacs
normally asks for confirmation before handling it.

 - User Option: enable-local-eval
     This variable controls processing of `Eval:' in local variables
     lists in files being visited.  A value of `t' means process them
     unconditionally; `nil' means ignore them; anything else means ask
     the user what to do for each file.  The default value is `maybe'.


File: elisp,  Node: Functions,  Next: Macros,  Prev: Variables,  Up: Top

Functions
*********

   A Lisp program is composed mainly of Lisp functions.  This chapter
explains what functions are, how they accept arguments, and how to
define them.

* Menu:

* What Is a Function::    Lisp functions vs. primitives; terminology.
* Lambda Expressions::    How functions are expressed as Lisp objects.
* Function Names::        A symbol can serve as the name of a function.
* Defining Functions::    Lisp expressions for defining functions.
* Calling Functions::     How to use an existing function.
* Mapping Functions::     Applying a function to each element of a list, etc.
* Anonymous Functions::   Lambda expressions are functions with no names.
* Function Cells::        Accessing or setting the function definition
                            of a symbol.
* Inline Functions::	  Defining functions that the compiler will open code.
* Related Topics::        Cross-references to specific Lisp primitives
                            that have a special bearing on how functions work.


File: elisp,  Node: What Is a Function,  Next: Lambda Expressions,  Up: Functions

What Is a Function?
===================

   In a general sense, a function is a rule for carrying on a
computation given several values called "arguments".  The result of the
computation is called the value of the function.  The computation can
also have side effects: lasting changes in the values of variables or
the contents of data structures.

   Here are important terms for functions in Emacs Lisp and for other
function-like objects.

"function"
     In Emacs Lisp, a "function" is anything that can be applied to
     arguments in a Lisp program.  In some cases, we use it more
     specifically to mean a function written in Lisp.  Special forms and
     macros are not functions.

"primitive"
     A "primitive" is a function callable from Lisp that is written in
     C, such as `car' or `append'.  These functions are also called
     "built-in" functions or "subrs".  (Special forms are also
     considered primitives.)

     Usually the reason we implement a function as a primitive is either
     because it is fundamental, because it provides a low-level
     interface to operating system services, or because it needs to run
     fast.  Primitives can be modified or added only by changing the C
     sources and recompiling the editor.  See *Note Writing Emacs
     Primitives::.

"lambda expression"
     A "lambda expression" is a function written in Lisp.  These are
     described in the following section.  *Note Lambda Expressions::.

"special form"
     A "special form" is a primitive that is like a function but does
     not evaluate all of its arguments in the usual way.  It may
     evaluate only some of the arguments, or may evaluate them in an
     unusual order, or several times.  Many special forms are described
     in *Note Control Structures::.

"macro"
     A "macro" is a construct defined in Lisp by the programmer.  It
     differs from a function in that it translates a Lisp expression
     that you write into an equivalent expression to be evaluated
     instead of the original expression.  Macros enable Lisp
     programmers to do the sorts of things that special forms can do.
     *Note Macros::, for how to define and use macros.

"command"
     A "command" is an object that `command-execute' can invoke; it is
     a possible definition for a key sequence.  Some functions are
     commands; a function written in Lisp is a command if it contains an
     interactive declaration (*note Defining Commands::).  Such a
     function can be called from Lisp expressions like other functions;
     in this case, the fact that the function is a command makes no
     difference.

     Keyboard macros (strings and vectors) are commands also, even
     though they are not functions.  A symbol is a command if its
     function definition is a command; such symbols can be invoked with
     `M-x'.  The symbol is a function as well if the definition is a
     function.  *Note Command Overview::.

"keystroke command"
     A "keystroke command" is a command that is bound to a key sequence
     (typically one to three keystrokes).  The distinction is made here
     merely to avoid confusion with the meaning of "command" in
     non-Emacs editors; for Lisp programs, the distinction is normally
     unimportant.

"byte-code function"
     A "byte-code function" is a function that has been compiled by the
     byte compiler.  *Note Byte-Code Type::.

 - Function: functionp object
     This function returns `t' if OBJECT is any kind of function, or a
     special form or macro.

 - Function: subrp object
     This function returns `t' if OBJECT is a built-in function (i.e.,
     a Lisp primitive).

          (subrp 'message)            ; `message' is a symbol,
               => nil                 ;   not a subr object.
          (subrp (symbol-function 'message))
               => t

 - Function: byte-code-function-p object
     This function returns `t' if OBJECT is a byte-code function.  For
     example:

          (byte-code-function-p (symbol-function 'next-line))
               => t

 - Function: subr-arity subr
     This function provides information about the argument list of a
     primitive, SUBR.  The returned value is a pair `(MIN . MAX)'.  MIN
     is the minimum number of args.  MAX is the maximum number or the
     symbol `many', for a function with `&rest' arguments, or the
     symbol `unevalled' if SUBR is a special form.


File: elisp,  Node: Lambda Expressions,  Next: Function Names,  Prev: What Is a Function,  Up: Functions

Lambda Expressions
==================

   A function written in Lisp is a list that looks like this:

     (lambda (ARG-VARIABLES...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-DECLARATION]
       BODY-FORMS...)

Such a list is called a "lambda expression".  In Emacs Lisp, it
actually is valid as an expression--it evaluates to itself.  In some
other Lisp dialects, a lambda expression is not a valid expression at
all.  In either case, its main use is not to be evaluated as an
expression, but to be called as a function.

* Menu:

* Lambda Components::       The parts of a lambda expression.
* Simple Lambda::           A simple example.
* Argument List::           Details and special features of argument lists.
* Function Documentation::  How to put documentation in a function.


File: elisp,  Node: Lambda Components,  Next: Simple Lambda,  Up: Lambda Expressions

Components of a Lambda Expression
---------------------------------

   A function written in Lisp (a "lambda expression") is a list that
looks like this:

     (lambda (ARG-VARIABLES...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-DECLARATION]
       BODY-FORMS...)

   The first element of a lambda expression is always the symbol
`lambda'.  This indicates that the list represents a function.  The
reason functions are defined to start with `lambda' is so that other
lists, intended for other uses, will not accidentally be valid as
functions.

   The second element is a list of symbols--the argument variable names.
This is called the "lambda list".  When a Lisp function is called, the
argument values are matched up against the variables in the lambda
list, which are given local bindings with the values provided.  *Note
Local Variables::.

   The documentation string is a Lisp string object placed within the
function definition to describe the function for the Emacs help
facilities.  *Note Function Documentation::.

   The interactive declaration is a list of the form `(interactive
CODE-STRING)'.  This declares how to provide arguments if the function
is used interactively.  Functions with this declaration are called
"commands"; they can be called using `M-x' or bound to a key.
Functions not intended to be called in this way should not have
interactive declarations.  *Note Defining Commands::, for how to write
an interactive declaration.

   The rest of the elements are the "body" of the function: the Lisp
code to do the work of the function (or, as a Lisp programmer would say,
"a list of Lisp forms to evaluate").  The value returned by the
function is the value returned by the last element of the body.


File: elisp,  Node: Simple Lambda,  Next: Argument List,  Prev: Lambda Components,  Up: Lambda Expressions

A Simple Lambda-Expression Example
----------------------------------

   Consider for example the following function:

     (lambda (a b c) (+ a b c))

We can call this function by writing it as the CAR of an expression,
like this:

     ((lambda (a b c) (+ a b c))
      1 2 3)

This call evaluates the body of the lambda expression  with the variable
`a' bound to 1, `b' bound to 2, and `c' bound to 3.  Evaluation of the
body adds these three numbers, producing the result 6; therefore, this
call to the function returns the value 6.

   Note that the arguments can be the results of other function calls,
as in this example:

     ((lambda (a b c) (+ a b c))
      1 (* 2 3) (- 5 4))

This evaluates the arguments `1', `(* 2 3)', and `(- 5 4)' from left to
right.  Then it applies the lambda expression to the argument values 1,
6 and 1 to produce the value 8.

   It is not often useful to write a lambda expression as the CAR of a
form in this way.  You can get the same result, of making local
variables and giving them values, using the special form `let' (*note
Local Variables::).  And `let' is clearer and easier to use.  In
practice, lambda expressions are either stored as the function
definitions of symbols, to produce named functions, or passed as
arguments to other functions (*note Anonymous Functions::).

   However, calls to explicit lambda expressions were very useful in the
old days of Lisp, before the special form `let' was invented.  At that
time, they were the only way to bind and initialize local variables.


File: elisp,  Node: Argument List,  Next: Function Documentation,  Prev: Simple Lambda,  Up: Lambda Expressions

Other Features of Argument Lists
--------------------------------

   Our simple sample function, `(lambda (a b c) (+ a b c))', specifies
three argument variables, so it must be called with three arguments: if
you try to call it with only two arguments or four arguments, you get a
`wrong-number-of-arguments' error.

   It is often convenient to write a function that allows certain
arguments to be omitted.  For example, the function `substring' accepts
three arguments--a string, the start index and the end index--but the
third argument defaults to the LENGTH of the string if you omit it.  It
is also convenient for certain functions to accept an indefinite number
of arguments, as the functions `list' and `+' do.

   To specify optional arguments that may be omitted when a function is
called, simply include the keyword `&optional' before the optional
arguments.  To specify a list of zero or more extra arguments, include
the keyword `&rest' before one final argument.

   Thus, the complete syntax for an argument list is as follows:

     (REQUIRED-VARS...
      [&optional OPTIONAL-VARS...]
      [&rest REST-VAR])

The square brackets indicate that the `&optional' and `&rest' clauses,
and the variables that follow them, are optional.

   A call to the function requires one actual argument for each of the
REQUIRED-VARS.  There may be actual arguments for zero or more of the
OPTIONAL-VARS, and there cannot be any actual arguments beyond that
unless the lambda list uses `&rest'.  In that case, there may be any
number of extra actual arguments.

   If actual arguments for the optional and rest variables are omitted,
then they always default to `nil'.  There is no way for the function to
distinguish between an explicit argument of `nil' and an omitted
argument.  However, the body of the function is free to consider `nil'
an abbreviation for some other meaningful value.  This is what
`substring' does; `nil' as the third argument to `substring' means to
use the length of the string supplied.

     Common Lisp note: Common Lisp allows the function to specify what
     default value to use when an optional argument is omitted; Emacs
     Lisp always uses `nil'.  Emacs Lisp does not support "supplied-p"
     variables that tell you whether an argument was explicitly passed.

   For example, an argument list that looks like this:

     (a b &optional c d &rest e)

binds `a' and `b' to the first two actual arguments, which are
required.  If one or two more arguments are provided, `c' and `d' are
bound to them respectively; any arguments after the first four are
collected into a list and `e' is bound to that list.  If there are only
two arguments, `c' is `nil'; if two or three arguments, `d' is `nil';
if four arguments or fewer, `e' is `nil'.

   There is no way to have required arguments following optional
ones--it would not make sense.  To see why this must be so, suppose
that `c' in the example were optional and `d' were required.  Suppose
three actual arguments are given; which variable would the third
argument be for?  Would it be used for the C, or for D?  One can argue
for both possibilities.  Similarly, it makes no sense to have any more
arguments (either required or optional) after a `&rest' argument.

   Here are some examples of argument lists and proper calls:

     ((lambda (n) (1+ n))                ; One required:
      1)                                 ; requires exactly one argument.
          => 2
     ((lambda (n &optional n1)           ; One required and one optional:
              (if n1 (+ n n1) (1+ n)))   ; 1 or 2 arguments.
      1 2)
          => 3
     ((lambda (n &rest ns)               ; One required and one rest:
              (+ n (apply '+ ns)))       ; 1 or more arguments.
      1 2 3 4 5)
          => 15


File: elisp,  Node: Function Documentation,  Prev: Argument List,  Up: Lambda Expressions

Documentation Strings of Functions
----------------------------------

   A lambda expression may optionally have a "documentation string" just
after the lambda list.  This string does not affect execution of the
function; it is a kind of comment, but a systematized comment which
actually appears inside the Lisp world and can be used by the Emacs help
facilities.  *Note Documentation::, for how the DOCUMENTATION-STRING is
accessed.

   It is a good idea to provide documentation strings for all the
functions in your program, even those that are called only from within
your program.  Documentation strings are like comments, except that they
are easier to access.

   The first line of the documentation string should stand on its own,
because `apropos' displays just this first line.  It should consist of
one or two complete sentences that summarize the function's purpose.

   The start of the documentation string is usually indented in the
source file, but since these spaces come before the starting
double-quote, they are not part of the string.  Some people make a
practice of indenting any additional lines of the string so that the
text lines up in the program source.  _This is a mistake._  The
indentation of the following lines is inside the string; what looks
nice in the source code will look ugly when displayed by the help
commands.

   You may wonder how the documentation string could be optional, since
there are required components of the function that follow it (the body).
Since evaluation of a string returns that string, without any side
effects, it has no effect if it is not the last form in the body.
Thus, in practice, there is no confusion between the first form of the
body and the documentation string; if the only body form is a string
then it serves both as the return value and as the documentation.


File: elisp,  Node: Function Names,  Next: Defining Functions,  Prev: Lambda Expressions,  Up: Functions

Naming a Function
=================

   In most computer languages, every function has a name; the idea of a
function without a name is nonsensical.  In Lisp, a function in the
strictest sense has no name.  It is simply a list whose first element is
`lambda', a byte-code function object, or a primitive subr-object.

   However, a symbol can serve as the name of a function.  This happens
when you put the function in the symbol's "function cell" (*note Symbol
Components::).  Then the symbol itself becomes a valid, callable
function, equivalent to the list or subr-object that its function cell
refers to.  The contents of the function cell are also called the
symbol's "function definition".  The procedure of using a symbol's
function definition in place of the symbol is called "symbol function
indirection"; see *Note Function Indirection::.

   In practice, nearly all functions are given names in this way and
referred to through their names.  For example, the symbol `car' works
as a function and does what it does because the primitive subr-object
`#<subr car>' is stored in its function cell.

   We give functions names because it is convenient to refer to them by
their names in Lisp expressions.  For primitive subr-objects such as
`#<subr car>', names are the only way you can refer to them: there is
no read syntax for such objects.  For functions written in Lisp, the
name is more convenient to use in a call than an explicit lambda
expression.  Also, a function with a name can refer to itself--it can
be recursive.  Writing the function's name in its own definition is much
more convenient than making the function definition point to itself
(something that is not impossible but that has various disadvantages in
practice).

   We often identify functions with the symbols used to name them.  For
example, we often speak of "the function `car'", not distinguishing
between the symbol `car' and the primitive subr-object that is its
function definition.  For most purposes, there is no need to
distinguish.

   Even so, keep in mind that a function need not have a unique name.
While a given function object _usually_ appears in the function cell of
only one symbol, this is just a matter of convenience.  It is easy to
store it in several symbols using `fset'; then each of the symbols is
equally well a name for the same function.

   A symbol used as a function name may also be used as a variable;
these two uses of a symbol are independent and do not conflict.  (Some
Lisp dialects, such as Scheme, do not distinguish between a symbol's
value and its function definition; a symbol's value as a variable is
also its function definition.)  If you have not given a symbol a
function definition, you cannot use it as a function; whether the
symbol has a value as a variable makes no difference to this.

