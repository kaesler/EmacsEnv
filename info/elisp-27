This is elisp, produced by makeinfo version 4.0f from ./elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This Info file contains edition 2.8 of the GNU Emacs Lisp Reference
Manual, corresponding to Emacs version 21.2.

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
2000, 2001, 2002 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Copying", with the Front-Cover texts being "A
GNU Manual", and with the Back-Cover Texts as in (a) below.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: elisp,  Node: Buffers and Windows,  Next: Displaying Buffers,  Prev: Cyclic Window Ordering,  Up: Windows

Buffers and Windows
===================

   This section describes low-level functions to examine windows or to
display buffers in windows in a precisely controlled fashion.  *Note
Displaying Buffers::, for related functions that find a window to use
and specify a buffer for it.  The functions described there are easier
to use than these, but they employ heuristics in choosing or creating a
window; use these functions when you need complete control.

 - Function: set-window-buffer window buffer-or-name
     This function makes WINDOW display BUFFER-OR-NAME as its contents.
     It returns `nil'.  This is the fundamental primitive for changing
     which buffer is displayed in a window, and all ways of doing that
     call this function.

          (set-window-buffer (selected-window) "foo")
               => nil

 - Function: window-buffer &optional window
     This function returns the buffer that WINDOW is displaying.  If
     WINDOW is omitted, this function returns the buffer for the
     selected window.

          (window-buffer)
               => #<buffer windows.texi>

 - Function: get-buffer-window buffer-or-name &optional all-frames
     This function returns a window currently displaying
     BUFFER-OR-NAME, or `nil' if there is none.  If there are several
     such windows, then the function returns the first one in the
     cyclic ordering of windows, starting from the selected window.
     *Note Cyclic Window Ordering::.

     The argument ALL-FRAMES controls which windows to consider.

        * If it is `nil', consider windows on the selected frame.

        * If it is `t', consider windows on all frames.

        * If it is `visible', consider windows on all visible frames.

        * If it is 0, consider windows on all visible or iconified
          frames.

        * If it is a frame, consider windows on that frame.

 - Function: get-buffer-window-list buffer-or-name &optional minibuf
          all-frames
     This function returns a list of all the windows currently
     displaying BUFFER-OR-NAME.

     The two optional arguments work like the optional arguments of
     `next-window' (*note Cyclic Window Ordering::); they are _not_
     like the single optional argument of `get-buffer-window'.  Perhaps
     we should change `get-buffer-window' in the future to make it
     compatible with the other functions.

     The argument ALL-FRAMES controls which windows to consider.

        * If it is `nil', consider windows on the selected frame.

        * If it is `t', consider windows on all frames.

        * If it is `visible', consider windows on all visible frames.

        * If it is 0, consider windows on all visible or iconified
          frames.

        * If it is a frame, consider windows on that frame.

 - Variable: buffer-display-time
     This variable records the time at which a buffer was last made
     visible in a window.  It is always local in each buffer; each time
     `set-window-buffer' is called, it sets this variable to
     `(current-time)' in the specified buffer (*note Time of Day::).
     When a buffer is first created, `buffer-display-time' starts out
     with the value `nil'.


File: elisp,  Node: Displaying Buffers,  Next: Choosing Window,  Prev: Buffers and Windows,  Up: Windows

Displaying Buffers in Windows
=============================

   In this section we describe convenient functions that choose a window
automatically and use it to display a specified buffer.  These functions
can also split an existing window in certain circumstances.  We also
describe variables that parameterize the heuristics used for choosing a
window.  *Note Buffers and Windows::, for low-level functions that give
you more precise control.  All of these functions work by calling
`set-window-buffer'.

   Do not use the functions in this section in order to make a buffer
current so that a Lisp program can access or modify it; they are too
drastic for that purpose, since they change the display of buffers in
windows, which would be gratuitous and surprise the user.  Instead, use
`set-buffer' and `save-current-buffer' (*note Current Buffer::), which
designate buffers as current for programmed access without affecting
the display of buffers in windows.

 - Command: switch-to-buffer buffer-or-name &optional norecord
     This function makes BUFFER-OR-NAME the current buffer, and also
     displays the buffer in the selected window.  This means that a
     human can see the buffer and subsequent keyboard commands will
     apply to it.  Contrast this with `set-buffer', which makes
     BUFFER-OR-NAME the current buffer but does not display it in the
     selected window.  *Note Current Buffer::.

     If BUFFER-OR-NAME does not identify an existing buffer, then a new
     buffer by that name is created.  The major mode for the new buffer
     is set according to the variable `default-major-mode'.  *Note Auto
     Major Mode::.

     Normally the specified buffer is put at the front of the buffer
     list (both the selected frame's buffer list and the
     frame-independent buffer list).  This affects the operation of
     `other-buffer'.  However, if NORECORD is non-`nil', this is not
     done.  *Note The Buffer List::.

     The `switch-to-buffer' function is often used interactively, as
     the binding of `C-x b'.  It is also used frequently in programs.
     It always returns `nil'.

 - Command: switch-to-buffer-other-window buffer-or-name &optional
          norecord
     This function makes BUFFER-OR-NAME the current buffer and displays
     it in a window not currently selected.  It then selects that
     window.  The handling of the buffer is the same as in
     `switch-to-buffer'.

     The currently selected window is absolutely never used to do the
     job.  If it is the only window, then it is split to make a
     distinct window for this purpose.  If the selected window is
     already displaying the buffer, then it continues to do so, but
     another window is nonetheless found to display it in as well.

     This function updates the buffer list just like `switch-to-buffer'
     unless NORECORD is non-`nil'.

 - Function: pop-to-buffer buffer-or-name &optional other-window
          norecord
     This function makes BUFFER-OR-NAME the current buffer and switches
     to it in some window, preferably not the window previously
     selected.  The "popped-to" window becomes the selected window
     within its frame.

     If the variable `pop-up-frames' is non-`nil', `pop-to-buffer'
     looks for a window in any visible frame already displaying the
     buffer; if there is one, it returns that window and makes it be
     selected within its frame.  If there is none, it creates a new
     frame and displays the buffer in it.

     If `pop-up-frames' is `nil', then `pop-to-buffer' operates
     entirely within the selected frame.  (If the selected frame has
     just a minibuffer, `pop-to-buffer' operates within the most
     recently selected frame that was not just a minibuffer.)

     If the variable `pop-up-windows' is non-`nil', windows may be
     split to create a new window that is different from the original
     window.  For details, see *Note Choosing Window::.

     If OTHER-WINDOW is non-`nil', `pop-to-buffer' finds or creates
     another window even if BUFFER-OR-NAME is already visible in the
     selected window.  Thus BUFFER-OR-NAME could end up displayed in
     two windows.  On the other hand, if BUFFER-OR-NAME is already
     displayed in the selected window and OTHER-WINDOW is `nil', then
     the selected window is considered sufficient display for
     BUFFER-OR-NAME, so that nothing needs to be done.

     All the variables that affect `display-buffer' affect
     `pop-to-buffer' as well.  *Note Choosing Window::.

     If BUFFER-OR-NAME is a string that does not name an existing
     buffer, a buffer by that name is created.  The major mode for the
     new buffer is set according to the variable `default-major-mode'.
     *Note Auto Major Mode::.

     This function updates the buffer list just like `switch-to-buffer'
     unless NORECORD is non-`nil'.

 - Command: replace-buffer-in-windows buffer
     This function replaces BUFFER with some other buffer in all
     windows displaying it.  The other buffer used is chosen with
     `other-buffer'.  In the usual applications of this function, you
     don't care which other buffer is used; you just want to make sure
     that BUFFER is no longer displayed.

     This function returns `nil'.


File: elisp,  Node: Choosing Window,  Next: Window Point,  Prev: Displaying Buffers,  Up: Windows

Choosing a Window for Display
=============================

   This section describes the basic facility that chooses a window to
display a buffer in--`display-buffer'.  All the higher-level functions
and commands use this subroutine.  Here we describe how to use
`display-buffer' and how to customize it.

 - Command: display-buffer buffer-or-name &optional not-this-window
          frame
     This command makes BUFFER-OR-NAME appear in some window, like
     `pop-to-buffer', but it does not select that window and does not
     make the buffer current.  The identity of the selected window is
     unaltered by this function.

     If NOT-THIS-WINDOW is non-`nil', it means to display the specified
     buffer in a window other than the selected one, even if it is
     already on display in the selected window.  This can cause the
     buffer to appear in two windows at once.  Otherwise, if
     BUFFER-OR-NAME is already being displayed in any window, that is
     good enough, so this function does nothing.

     `display-buffer' returns the window chosen to display
     BUFFER-OR-NAME.

     If the argument FRAME is non-`nil', it specifies which frames to
     check when deciding whether the buffer is already displayed.  If
     the buffer is already displayed in some window on one of these
     frames, `display-buffer' simply returns that window.  Here are the
     possible values of FRAME:

        * If it is `nil', consider windows on the selected frame.

        * If it is `t', consider windows on all frames.

        * If it is `visible', consider windows on all visible frames.

        * If it is 0, consider windows on all visible or iconified
          frames.

        * If it is a frame, consider windows on that frame.

     Precisely how `display-buffer' finds or creates a window depends on
     the variables described below.

 - User Option: display-buffer-reuse-frames
     If this variable is non-`nil', `display-buffer' searches existing
     frames for a window displaying the buffer.  If the buffer is
     already displayed in a window in some frame, `display-buffer' makes
     the frame visible and raises it, to use that window.  If the
     buffer is not already displayed, or if
     `display-buffer-reuse-frames' is `nil', `display-buffer''s
     behavior is determined by other variables, described below.

 - User Option: pop-up-windows
     This variable controls whether `display-buffer' makes new windows.
     If it is non-`nil' and there is only one window, then that window
     is split.  If it is `nil', then `display-buffer' does not split
     the single window, but uses it whole.

 - User Option: split-height-threshold
     This variable determines when `display-buffer' may split a window,
     if there are multiple windows.  `display-buffer' always splits the
     largest window if it has at least this many lines.  If the largest
     window is not this tall, it is split only if it is the sole window
     and `pop-up-windows' is non-`nil'.

 - User Option: even-window-heights
     This variable determines if `display-buffer' should even out window
     heights if the buffer gets displayed in an existing window, above
     or beneath another existing window.  If `even-window-heights' is
     `t', the default, window heights will be evened out.  If
     `even-window-heights' is `nil', the orginal window heights will be
     left alone.

 - User Option: pop-up-frames
     This variable controls whether `display-buffer' makes new frames.
     If it is non-`nil', `display-buffer' looks for an existing window
     already displaying the desired buffer, on any visible frame.  If
     it finds one, it returns that window.  Otherwise it makes a new
     frame.  The variables `pop-up-windows' and
     `split-height-threshold' do not matter if `pop-up-frames' is
     non-`nil'.

     If `pop-up-frames' is `nil', then `display-buffer' either splits a
     window or reuses one.

     *Note Frames::, for more information.

 - Variable: pop-up-frame-function
     This variable specifies how to make a new frame if `pop-up-frames'
     is non-`nil'.

     Its value should be a function of no arguments.  When
     `display-buffer' makes a new frame, it does so by calling that
     function, which should return a frame.  The default value of the
     variable is a function that creates a frame using parameters from
     `pop-up-frame-alist'.

 - User Option: pop-up-frame-alist
     This variable holds an alist specifying frame parameters used when
     `display-buffer' makes a new frame.  *Note Frame Parameters::, for
     more information about frame parameters.

 - User Option: special-display-buffer-names
     A list of buffer names for buffers that should be displayed
     specially.  If the buffer's name is in this list, `display-buffer'
     handles the buffer specially.

     By default, special display means to give the buffer a dedicated
     frame.

     If an element is a list, instead of a string, then the CAR of the
     list is the buffer name, and the rest of the list says how to
     create the frame.  There are two possibilities for the rest of the
     list.  It can be an alist, specifying frame parameters, or it can
     contain a function and arguments to give to it.  (The function's
     first argument is always the buffer to be displayed; the arguments
     from the list come after that.)

 - User Option: special-display-regexps
     A list of regular expressions that specify buffers that should be
     displayed specially.  If the buffer's name matches any of the
     regular expressions in this list, `display-buffer' handles the
     buffer specially.

     By default, special display means to give the buffer a dedicated
     frame.

     If an element is a list, instead of a string, then the CAR of the
     list is the regular expression, and the rest of the list says how
     to create the frame.  See above, under
     `special-display-buffer-names'.

 - Variable: special-display-function
     This variable holds the function to call to display a buffer
     specially.  It receives the buffer as an argument, and should
     return the window in which it is displayed.

     The default value of this variable is
     `special-display-popup-frame'.

 - Function: special-display-popup-frame buffer &rest args
     This function makes BUFFER visible in a frame of its own.  If
     BUFFER is already displayed in a window in some frame, it makes
     the frame visible and raises it, to use that window.  Otherwise, it
     creates a frame that will be dedicated to BUFFER.

     If ARGS is an alist, it specifies frame parameters for the new
     frame.

     If ARGS is a list whose CAR is a symbol, then `(car ARGS)' is
     called as a function to actually create and set up the frame; it
     is called with BUFFER as first argument, and `(cdr ARGS)' as
     additional arguments.

     This function always uses an existing window displaying BUFFER,
     whether or not it is in a frame of its own; but if you set up the
     above variables in your init file, before BUFFER was created, then
     presumably the window was previously made by this function.

 - User Option: special-display-frame-alist
     This variable holds frame parameters for
     `special-display-popup-frame' to use when it creates a frame.

 - User Option: same-window-buffer-names
     A list of buffer names for buffers that should be displayed in the
     selected window.  If the buffer's name is in this list,
     `display-buffer' handles the buffer by switching to it in the
     selected window.

 - User Option: same-window-regexps
     A list of regular expressions that specify buffers that should be
     displayed in the selected window.  If the buffer's name matches
     any of the regular expressions in this list, `display-buffer'
     handles the buffer by switching to it in the selected window.

 - Variable: display-buffer-function
     This variable is the most flexible way to customize the behavior of
     `display-buffer'.  If it is non-`nil', it should be a function
     that `display-buffer' calls to do the work.  The function should
     accept two arguments, the same two arguments that `display-buffer'
     received.  It should choose or create a window, display the
     specified buffer, and then return the window.

     This hook takes precedence over all the other options and hooks
     described above.

   A window can be marked as "dedicated" to its buffer.  Then
`display-buffer' will not try to use that window to display any other
buffer.

 - Function: window-dedicated-p window
     This function returns `t' if WINDOW is marked as dedicated;
     otherwise `nil'.

 - Function: set-window-dedicated-p window flag
     This function marks WINDOW as dedicated if FLAG is non-`nil', and
     nondedicated otherwise.


File: elisp,  Node: Window Point,  Next: Window Start,  Prev: Choosing Window,  Up: Windows

Windows and Point
=================

   Each window has its own value of point, independent of the value of
point in other windows displaying the same buffer.  This makes it useful
to have multiple windows showing one buffer.

   * The window point is established when a window is first created; it
     is initialized from the buffer's point, or from the window point
     of another window opened on the buffer if such a window exists.

   * Selecting a window sets the value of point in its buffer from the
     window's value of point.  Conversely, deselecting a window sets the
     window's value of point from that of the buffer.  Thus, when you
     switch between windows that display a given buffer, the point
     value for the selected window is in effect in the buffer, while
     the point values for the other windows are stored in those windows.

   * As long as the selected window displays the current buffer, the
     window's point and the buffer's point always move together; they
     remain equal.

   * *Note Positions::, for more details on buffer positions.

   As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

 - Function: window-point &optional window
     This function returns the current position of point in WINDOW.
     For a nonselected window, this is the value point would have (in
     that window's buffer) if that window were selected.  If WINDOW is
     `nil', the selected window is used.

     When WINDOW is the selected window and its buffer is also the
     current buffer, the value returned is the same as point in that
     buffer.

     Strictly speaking, it would be more correct to return the
     "top-level" value of point, outside of any `save-excursion' forms.
     But that value is hard to find.

 - Function: set-window-point window position
     This function positions point in WINDOW at position POSITION in
     WINDOW's buffer.


File: elisp,  Node: Window Start,  Next: Textual Scrolling,  Prev: Window Point,  Up: Windows

The Window Start Position
=========================

   Each window contains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the "display-start" position of the window (or just the
"start").  The character after this position is the one that appears at
the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

 - Function: window-start &optional window
     This function returns the display-start position of window WINDOW.
     If WINDOW is `nil', the selected window is used.  For example,

          (window-start)
               => 7058

     When you create a window, or display a different buffer in it, the
     display-start position is set to a display-start position recently
     used for the same buffer, or 1 if the buffer doesn't have any.

     Redisplay updates the window-start position (if you have not
     specified it explicitly since the previous redisplay)--for
     example, to make sure point appears on the screen.  Nothing except
     redisplay automatically changes the window-start position; if you
     move point, do not expect the window-start position to change in
     response until after the next redisplay.

     For a realistic example of using `window-start', see the
     description of `count-lines' in *Note Text Lines::.

 - Function: window-end &optional window update
     This function returns the position of the end of the display in
     window WINDOW.  If WINDOW is `nil', the selected window is used.

     Simply changing the buffer text or moving point does not update the
     value that `window-end' returns.  The value is updated only when
     Emacs redisplays and redisplay completes without being preempted.

     If the last redisplay of WINDOW was preempted, and did not finish,
     Emacs does not know the position of the end of display in that
     window.  In that case, this function returns `nil'.

     If UPDATE is non-`nil', `window-end' always returns an up-to-date
     value for where the window ends, based on the current
     `window-start' value.  If the saved value is valid, `window-end'
     returns that; otherwise it computes the correct value by scanning
     the buffer text.

     Even if UPDATE is non-`nil', `window-end' does not attempt to
     scroll the display if point has moved off the screen, the way real
     redisplay would do.  It does not alter the `window-start' value.
     In effect, it reports where the displayed text will end if
     scrolling is not required.

 - Function: set-window-start window position &optional noforce
     This function sets the display-start position of WINDOW to
     POSITION in WINDOW's buffer.  It returns POSITION.

     The display routines insist that the position of point be visible
     when a buffer is displayed.  Normally, they change the
     display-start position (that is, scroll the window) whenever
     necessary to make point visible.  However, if you specify the
     start position with this function using `nil' for NOFORCE, it
     means you want display to start at POSITION even if that would put
     the location of point off the screen.  If this does place point
     off screen, the display routines move point to the left margin on
     the middle line in the window.

     For example, if point is 1 and you set the start of the window
     to 2, then point would be "above" the top of the window.  The
     display routines will automatically move point if it is still 1
     when redisplay occurs.  Here is an example:

          ;; Here is what `foo' looks like before executing
          ;;   the `set-window-start' expression.
          
          ---------- Buffer: foo ----------
          -!-This is the contents of buffer foo.
          2
          3
          4
          5
          6
          ---------- Buffer: foo ----------
          
          (set-window-start
           (selected-window)
           (1+ (window-start)))
          => 2
          
          ;; Here is what `foo' looks like after executing
          ;;   the `set-window-start' expression.
          ---------- Buffer: foo ----------
          his is the contents of buffer foo.
          2
          3
          -!-4
          5
          6
          ---------- Buffer: foo ----------

     If NOFORCE is non-`nil', and POSITION would place point off screen
     at the next redisplay, then redisplay computes a new window-start
     position that works well with point, and thus POSITION is not used.

 - Function: pos-visible-in-window-p &optional position window partially
     This function returns `t' if POSITION is within the range of text
     currently visible on the screen in WINDOW.  It returns `nil' if
     POSITION is scrolled vertically or horizontally out of view.
     Locations that are partially obscured are not considered visible
     unless PARTIALLY is non-`nil'.  The argument POSITION defaults to
     the current position of point in WINDOW; WINDOW, to the selected
     window.

     Here is an example:

          (or (pos-visible-in-window-p
               (point) (selected-window))
              (recenter 0))


File: elisp,  Node: Textual Scrolling,  Next: Vertical Scrolling,  Prev: Window Start,  Up: Windows

Textual Scrolling
=================

   "Textual scrolling" means moving the text up or down though a
window.  It works by changing the value of the window's display-start
location.  It may also change the value of `window-point' to keep point
on the screen.

   Textual scrolling was formerly called "vertical scrolling," but we
changed its name to distinguish it from the new vertical fractional
scrolling feature (*note Vertical Scrolling::).

   In the commands `scroll-up' and `scroll-down', the directions "up"
and "down" refer to the motion of the text in the buffer at which you
are looking through the window.  Imagine that the text is written on a
long roll of paper and that the scrolling commands move the paper up
and down.  Thus, if you are looking at text in the middle of a buffer
and repeatedly call `scroll-down', you will eventually see the
beginning of the buffer.

   Some people have urged that the opposite convention be used: they
imagine that the window moves over text that remains in place.  Then
"down" commands would take you to the end of the buffer.  This view is
more consistent with the actual relationship between windows and the
text in the buffer, but it is less like what the user sees.  The
position of a window on the terminal does not move, and short scrolling
commands clearly move the text up or down on the screen.  We have chosen
names that fit the user's point of view.

   The textual scrolling functions (aside from `scroll-other-window')
have unpredictable results if the current buffer is different from the
buffer that is displayed in the selected window.  *Note Current
Buffer::.

 - Command: scroll-up &optional count
     This function scrolls the text in the selected window upward COUNT
     lines.  If COUNT is negative, scrolling is actually downward.

     If COUNT is `nil' (or omitted), then the length of scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window (not counting its mode line).

     `scroll-up' returns `nil'.

 - Command: scroll-down &optional count
     This function scrolls the text in the selected window downward
     COUNT lines.  If COUNT is negative, scrolling is actually upward.

     If COUNT is omitted or `nil', then the length of the scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window (not counting its mode line).

     `scroll-down' returns `nil'.

 - Command: scroll-other-window &optional count
     This function scrolls the text in another window upward COUNT
     lines.  Negative values of COUNT, or `nil', are handled as in
     `scroll-up'.

     You can specify which buffer to scroll by setting the variable
     `other-window-scroll-buffer' to a buffer.  If that buffer isn't
     already displayed, `scroll-other-window' displays it in some
     window.

     When the selected window is the minibuffer, the next window is
     normally the one at the top left corner.  You can specify a
     different window to scroll, when the minibuffer is selected, by
     setting the variable `minibuffer-scroll-window'.  This variable
     has no effect when any other window is selected.  *Note Minibuffer
     Misc::.

     When the minibuffer is active, it is the next window if the
     selected window is the one at the bottom right corner.  In this
     case, `scroll-other-window' attempts to scroll the minibuffer.  If
     the minibuffer contains just one line, it has nowhere to scroll
     to, so the line reappears after the echo area momentarily displays
     the message "Beginning of buffer".

 - Variable: other-window-scroll-buffer
     If this variable is non-`nil', it tells `scroll-other-window'
     which buffer to scroll.

 - User Option: scroll-margin
     This option specifies the size of the scroll margin--a minimum
     number of lines between point and the top or bottom of a window.
     Whenever point gets within this many lines of the top or bottom of
     the window, the window scrolls automatically (if possible) to move
     point out of the margin, closer to the center of the window.

 - User Option: scroll-conservatively
     This variable controls how scrolling is done automatically when
     point moves off the screen (or into the scroll margin).  If the
     value is zero, then redisplay scrolls the text to center point
     vertically in the window.  If the value is a positive integer N,
     then redisplay scrolls the window up to N lines in either
     direction, if that will bring point back into view.  Otherwise, it
     centers point.  The default value is zero.

 - User Option: scroll-down-aggressively
     The value of this variable should be either `nil' or a fraction F
     between 0 and 1.  If it is a fraction, that specifies where on the
     screen to put point when scrolling down.  More precisely, when a
     window scrolls down because point is above the window start, the
     new start position is chosen to put point F part of the window
     height from the top.  The larger F, the more aggressive the
     scrolling.

     A value of `nil' is equivalent to .5, since its effect is to center
     point.  This variable automatically becomes buffer-local when set
     in any fashion.

 - User Option: scroll-up-aggressively
     Likewise, for scrolling up.  The value, F, specifies how far point
     should be placed from the bottom of the window; thus, as with
     `scroll-up-aggressively', a larger value scrolls more aggressively.

 - User Option: scroll-step
     This variable is an older variant of `scroll-conservatively'.  The
     difference is that it if its value is N, that permits scrolling
     only by precisely N lines, not a smaller number.  This feature
     does not work with `scroll-margin'.  The default value is zero.

 - User Option: scroll-preserve-screen-position
     If this option is non-`nil', the scroll functions move point so
     that the vertical position of the cursor is unchanged, when that is
     possible.

 - User Option: next-screen-context-lines
     The value of this variable is the number of lines of continuity to
     retain when scrolling by full screens.  For example, `scroll-up'
     with an argument of `nil' scrolls so that this many lines at the
     bottom of the window appear instead at the top.  The default value
     is `2'.

 - Command: recenter &optional count
     This function scrolls the selected window to put the text where
     point is located at a specified vertical position within the
     window.

     If COUNT is a nonnegative number, it puts the line containing
     point COUNT lines down from the top of the window.  If COUNT is a
     negative number, then it counts upward from the bottom of the
     window, so that -1 stands for the last usable line in the window.
     If COUNT is a non-`nil' list, then it stands for the line in the
     middle of the window.

     If COUNT is `nil', `recenter' puts the line containing point in
     the middle of the window, then clears and redisplays the entire
     selected frame.

     When `recenter' is called interactively, COUNT is the raw prefix
     argument.  Thus, typing `C-u' as the prefix sets the COUNT to a
     non-`nil' list, while typing `C-u 4' sets COUNT to 4, which
     positions the current line four lines from the top.

     With an argument of zero, `recenter' positions the current line at
     the top of the window.  This action is so handy that some people
     make a separate key binding to do this.  For example,

          (defun line-to-top-of-window ()
            "Scroll current line to top of window.
          Replaces three keystroke sequence C-u 0 C-l."
            (interactive)
            (recenter 0))
          
          (global-set-key [kp-multiply] 'line-to-top-of-window)


File: elisp,  Node: Vertical Scrolling,  Next: Horizontal Scrolling,  Prev: Textual Scrolling,  Up: Windows

Vertical Fractional Scrolling
=============================

   "Vertical fractional scrolling" means shifting the image in the
window up or down by a specified multiple or fraction of a line.
Starting in Emacs 21, each window has a "vertical scroll position",
which is a number, never less than zero.  It specifies how far to raise
the contents of the window.  Raising the window contents generally makes
all or part of some lines disappear off the top, and all or part of some
other lines appear at the bottom.  The usual value is zero.

   The vertical scroll position is measured in units of the normal line
height, which is the height of the default font.  Thus, if the value is
.5, that means the window contents are scrolled up half the normal line
height.  If it is 3.3, that means the window contents are scrolled up
somewhat over three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many
lines, depends on what the lines contain.  A value of .5 could scroll a
line whose height is very short off the screen, while a value of 3.3
could scroll just part of the way through a tall line or an image.

 - Function: window-vscroll &optional window
     This function returns the current vertical scroll position of
     WINDOW, If WINDOW is `nil', the selected window is used.

          (window-vscroll)
               => 0

 - Function: set-window-vscroll window lines
     This function sets WINDOW's vertical scroll position to LINES.
     The argument LINES should be zero or positive; if not, it is taken
     as zero.

     The actual vertical scroll position must always correspond to an
     integral number of pixels, so the value you specify is rounded
     accordingly.

     The return value is the result of this rounding.

          (set-window-vscroll (selected-window) 1.2)
               => 1.13


File: elisp,  Node: Horizontal Scrolling,  Next: Size of Window,  Prev: Vertical Scrolling,  Up: Windows

Horizontal Scrolling
====================

   "Horizontal scrolling" means shifting the image in the window left
or right by a specified multiple of the normal character width.  Each
window has a "vertical scroll position", which is a number, never less
than zero.  It specifies how far to shift the contents left.  Shifting
the window contents left generally makes all or part of some characters
disappear off the left, and all or part of some other characters appear
at the right.  The usual value is zero.

   The horizontal scroll position is measured in units of the normal
character width, which is the width of space in the default font.  Thus,
if the value is 5, that means the window contents are scrolled left by 5
times the normal character width.  How many characters actually
disappear off to the left depends on their width, and could vary from
line to line.

   Because we read from side to side in the "inner loop", and from top
to bottom in the "outer loop", the effect of horizontal scrolling is
not like that of textual or vertical scrolling.  Textual scrolling
involves selection of a portion of text to display, and vertical
scrolling moves the window contents contiguously; but horizontal
scrolling causes part of _each line_ to go off screen.

   Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the edge
to be revealed by it; so this is not allowed.  Scrolling to the left is
allowed; it scrolls the first columns of text off the edge of the window
and can reveal additional columns on the right that were truncated
before.  Once a window has a nonzero amount of leftward horizontal
scrolling, you can scroll it back to the right, but only so far as to
reduce the net horizontal scroll to zero.  There is no limit to how far
left you can scroll, but eventually all the text will disappear off the
left edge.

   In Emacs 21, redisplay automatically alters the horizontal scrolling
of a window as necessary to ensure that point is always visible, if
`automatic-hscrolling' is set.  However, you can still set the
horizontal scrolling value explicitly.  The value you specify serves as
a lower bound for automatic scrolling, i.e. automatic scrolling will
not scroll a window to a column less than the specified one.

 - Command: scroll-left &optional count
     This function scrolls the selected window COUNT columns to the
     left (or to the right if COUNT is negative).  The default for
     COUNT is the window width, minus 2.

     The return value is the total amount of leftward horizontal
     scrolling in effect after the change--just like the value returned
     by `window-hscroll' (below).

 - Command: scroll-right &optional count
     This function scrolls the selected window COUNT columns to the
     right (or to the left if COUNT is negative).  The default for
     COUNT is the window width, minus 2.

     The return value is the total amount of leftward horizontal
     scrolling in effect after the change--just like the value returned
     by `window-hscroll' (below).

     Once you scroll a window as far right as it can go, back to its
     normal position where the total leftward scrolling is zero,
     attempts to scroll any farther right have no effect.

 - Function: window-hscroll &optional window
     This function returns the total leftward horizontal scrolling of
     WINDOW--the number of columns by which the text in WINDOW is
     scrolled left past the left margin.

     The value is never negative.  It is zero when no horizontal
     scrolling has been done in WINDOW (which is usually the case).

     If WINDOW is `nil', the selected window is used.

          (window-hscroll)
               => 0
          (scroll-left 5)
               => 5
          (window-hscroll)
               => 5

 - Function: set-window-hscroll window columns
     This function sets the number of columns from the left margin that
     WINDOW is scrolled from the value of COLUMNS.  The argument
     COLUMNS should be zero or positive; if not, it is taken as zero.
     Fractional values of COLUMNS are not supported at present.

     The value returned is COLUMNS.

          (set-window-hscroll (selected-window) 10)
               => 10

   Here is how you can determine whether a given position POSITION is
off the screen due to horizontal scrolling:

     (defun hscroll-on-screen (window position)
       (save-excursion
         (goto-char position)
         (and
          (>= (- (current-column) (window-hscroll window)) 0)
          (< (- (current-column) (window-hscroll window))
             (window-width window)))))


File: elisp,  Node: Size of Window,  Next: Resizing Windows,  Prev: Horizontal Scrolling,  Up: Windows

The Size of a Window
====================

   An Emacs window is rectangular, and its size information consists of
the height (the number of lines) and the width (the number of character
positions in each line).  The mode line is included in the height.  But
the width does not count the scroll bar or the column of `|' characters
that separates side-by-side windows.

   The following three functions return size information about a window:

 - Function: window-height &optional window
     This function returns the number of lines in WINDOW, including its
     mode line.  If WINDOW fills its entire frame, this is typically
     one less than the value of `frame-height' on that frame (since the
     last line is always reserved for the minibuffer).

     If WINDOW is `nil', the function uses the selected window.

          (window-height)
               => 23
          (split-window-vertically)
               => #<window 4 on windows.texi>
          (window-height)
               => 11

 - Function: window-width &optional window
     This function returns the number of columns in WINDOW.  If WINDOW
     fills its entire frame, this is the same as the value of
     `frame-width' on that frame.  The width does not include the
     window's scroll bar or the column of `|' characters that separates
     side-by-side windows.

     If WINDOW is `nil', the function uses the selected window.

          (window-width)
               => 80

 - Function: window-edges &optional window
     This function returns a list of the edge coordinates of WINDOW.
     If WINDOW is `nil', the selected window is used.

     The order of the list is `(LEFT TOP RIGHT BOTTOM)', all elements
     relative to 0, 0 at the top left corner of the frame.  The element
     RIGHT of the value is one more than the rightmost column used by
     WINDOW, and BOTTOM is one more than the bottommost row used by
     WINDOW and its mode-line.

     If a window has a scroll bar, the right edge value includes the
     width of the scroll bar.  Otherwise, if the window has a neighbor
     on the right, its right edge value includes the width of the
     separator line between the window and that neighbor.  Since the
     width of the window does not include this separator, the width
     does not usually equal the difference between the right and left
     edges.

     Here is the result obtained on a typical 24-line terminal with
     just one window:

          (window-edges (selected-window))
               => (0 0 80 23)

     The bottom edge is at line 23 because the last line is the echo
     area.

     If WINDOW is at the upper left corner of its frame, then BOTTOM is
     the same as the value of `(window-height)', RIGHT is almost the
     same as the value of `(window-width)', and TOP and LEFT are zero.
     For example, the edges of the following window are `0 0 8 5'.
     Assuming that the frame has more than 8 columns, the last column
     of the window (column 7) holds a border rather than text.  The
     last row (row 4) holds the mode line, shown here with `xxxxxxxxx'.

                     0
                     _______
                  0 |       |
                    |       |
                    |       |
                    |       |
                    xxxxxxxxx  4
          
                            7

     In the following example, let's suppose that the frame is 7
     columns wide.  Then the edges of the left window are `0 0 4 3' and
     the edges of the right window are `4 0 8 3'.

                     ___ ___
                    |   |   |
                    |   |   |
                    xxxxxxxxx
          
                     0  34  7


File: elisp,  Node: Resizing Windows,  Next: Coordinates and Windows,  Prev: Size of Window,  Up: Windows

Changing the Size of a Window
=============================

   The window size functions fall into two classes: high-level commands
that change the size of windows and low-level functions that access
window size.  Emacs does not permit overlapping windows or gaps between
windows, so resizing one window affects other windows.

 - Command: enlarge-window size &optional horizontal
     This function makes the selected window SIZE lines taller,
     stealing lines from neighboring windows.  It takes the lines from
     one window at a time until that window is used up, then takes from
     another.  If a window from which lines are stolen shrinks below
     `window-min-height' lines, that window disappears.

     If HORIZONTAL is non-`nil', this function makes WINDOW wider by
     SIZE columns, stealing columns instead of lines.  If a window from
     which columns are stolen shrinks below `window-min-width' columns,
     that window disappears.

     If the requested size would exceed that of the window's frame,
     then the function makes the window occupy the entire height (or
     width) of the frame.

     If there are various other windows from which lines or columns can
     be stolen, and some of them specify fixed size (using
     `window-size-fixed', see below), they are left untouched while
     other windows are "robbed."  If it would be necessary to alter the
     size of a fixed-size window, `enlarge-window' gets an error
     instead.

     If SIZE is negative, this function shrinks the window by -SIZE
     lines or columns.  If that makes the window smaller than the
     minimum size (`window-min-height' and `window-min-width'),
     `enlarge-window' deletes the window.

     `enlarge-window' returns `nil'.

 - Command: enlarge-window-horizontally columns
     This function makes the selected window COLUMNS wider.  It could
     be defined as follows:

          (defun enlarge-window-horizontally (columns)
            (enlarge-window columns t))

 - Command: shrink-window size &optional horizontal
     This function is like `enlarge-window' but negates the argument
     SIZE, making the selected window smaller by giving lines (or
     columns) to the other windows.  If the window shrinks below
     `window-min-height' or `window-min-width', then it disappears.

     If SIZE is negative, the window is enlarged by -SIZE lines or
     columns.

 - Command: shrink-window-horizontally columns
     This function makes the selected window COLUMNS narrower.  It
     could be defined as follows:

          (defun shrink-window-horizontally (columns)
            (shrink-window columns t))

 - Command: shrink-window-if-larger-than-buffer &optional window
     This command shrinks WINDOW to be as small as possible while still
     showing the full contents of its buffer--but not less than
     `window-min-height' lines.  If WINDOW is not given, it defaults to
     the selected window.

     However, the command does nothing if the window is already too
     small to display the whole text of the buffer, or if part of the
     contents are currently scrolled off screen, or if the window is
     not the full width of its frame, or if the window is the only
     window in its frame.

 - Variable: window-size-fixed
     If this variable is non-`nil', in any given buffer, then the size
     of any window displaying the buffer remains fixed unless you
     explicitly change it or Emacs has no other choice.  (This feature
     is new in Emacs 21.)

     If the value is `height', then only the window's height is fixed;
     if the value is `width', then only the window's width is fixed.
     Any other non-`nil' value fixes both the width and the height.

     The usual way to use this variable is to give it a buffer-local
     value in a particular buffer.  That way, the windows (but usually
     there is only one) displaying that buffer have fixed size.

     Explicit size-change functions such as `enlarge-window' get an
     error if they would have to change a window size which is fixed.
     Therefore, when you want to change the size of such a window, you
     should bind `window-size-fixed' to `nil', like this:

          (let ((window-size-fixed nil))
             (enlarge-window 10))

     Note that changing the frame size will change the size of a
     fixed-size window, if there is no other alternative.

   The following two variables constrain the window-size-changing
functions to a minimum height and width.

 - User Option: window-min-height
     The value of this variable determines how short a window may become
     before it is automatically deleted.  Making a window smaller than
     `window-min-height' automatically deletes it, and no window may be
     created shorter than this.  The absolute minimum height is two
     (allowing one line for the mode line, and one line for the buffer
     display).  Actions that change window sizes reset this variable to
     two if it is less than two.  The default value is 4.

 - User Option: window-min-width
     The value of this variable determines how narrow a window may
     become before it is automatically deleted.  Making a window
     smaller than `window-min-width' automatically deletes it, and no
     window may be created narrower than this.  The absolute minimum
     width is one; any value below that is ignored.  The default value
     is 10.

