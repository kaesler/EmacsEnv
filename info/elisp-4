This is elisp, produced by makeinfo version 4.0f from ./elisp.texi.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp: (elisp).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This Info file contains edition 2.8 of the GNU Emacs Lisp Reference
Manual, corresponding to Emacs version 21.2.

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
2000, 2001, 2002 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Copying", with the Front-Cover texts being "A
GNU Manual", and with the Back-Cover Texts as in (a) below.  A copy of
the license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: elisp,  Node: Bitwise Operations,  Next: Math Functions,  Prev: Rounding Operations,  Up: Numbers

Bitwise Operations on Integers
==============================

   In a computer, an integer is represented as a binary number, a
sequence of "bits" (digits which are either zero or one).  A bitwise
operation acts on the individual bits of such a sequence.  For example,
"shifting" moves the whole sequence left or right one or more places,
reproducing the same pattern "moved over".

   The bitwise operations in Emacs Lisp apply only to integers.

 - Function: lsh integer1 count
     `lsh', which is an abbreviation for "logical shift", shifts the
     bits in INTEGER1 to the left COUNT places, or to the right if
     COUNT is negative, bringing zeros into the vacated bits.  If COUNT
     is negative, `lsh' shifts zeros into the leftmost
     (most-significant) bit, producing a positive result even if
     INTEGER1 is negative.  Contrast this with `ash', below.

     Here are two examples of `lsh', shifting a pattern of bits one
     place to the left.  We show only the low-order eight bits of the
     binary pattern; the rest are all zero.

          (lsh 5 1)
               => 10
          ;; Decimal 5 becomes decimal 10.
          00000101 => 00001010
          
          (lsh 7 1)
               => 14
          ;; Decimal 7 becomes decimal 14.
          00000111 => 00001110

     As the examples illustrate, shifting the pattern of bits one place
     to the left produces a number that is twice the value of the
     previous number.

     Shifting a pattern of bits two places to the left produces results
     like this (with 8-bit binary numbers):

          (lsh 3 2)
               => 12
          ;; Decimal 3 becomes decimal 12.
          00000011 => 00001100

     On the other hand, shifting one place to the right looks like this:

          (lsh 6 -1)
               => 3
          ;; Decimal 6 becomes decimal 3.
          00000110 => 00000011
          
          (lsh 5 -1)
               => 2
          ;; Decimal 5 becomes decimal 2.
          00000101 => 00000010

     As the example illustrates, shifting one place to the right
     divides the value of a positive integer by two, rounding downward.

     The function `lsh', like all Emacs Lisp arithmetic functions, does
     not check for overflow, so shifting left can discard significant
     bits and change the sign of the number.  For example, left shifting
     134,217,727 produces -2 on a 28-bit machine:

          (lsh 134217727 1)          ; left shift
               => -2

     In binary, in the 28-bit implementation, the argument looks like
     this:

          ;; Decimal 134,217,727
          0111  1111 1111  1111 1111  1111 1111

     which becomes the following when left shifted:

          ;; Decimal -2
          1111  1111 1111  1111 1111  1111 1110

 - Function: ash integer1 count
     `ash' ("arithmetic shift") shifts the bits in INTEGER1 to the left
     COUNT places, or to the right if COUNT is negative.

     `ash' gives the same results as `lsh' except when INTEGER1 and
     COUNT are both negative.  In that case, `ash' puts ones in the
     empty bit positions on the left, while `lsh' puts zeros in those
     bit positions.

     Thus, with `ash', shifting the pattern of bits one place to the
     right looks like this:

          (ash -6 -1) => -3
          ;; Decimal -6 becomes decimal -3.
          1111  1111 1111  1111 1111  1111 1010
               =>
          1111  1111 1111  1111 1111  1111 1101

     In contrast, shifting the pattern of bits one place to the right
     with `lsh' looks like this:

          (lsh -6 -1) => 134217725
          ;; Decimal -6 becomes decimal 134,217,725.
          1111  1111 1111  1111 1111  1111 1010
               =>
          0111  1111 1111  1111 1111  1111 1101

     Here are other examples:

                             ;               28-bit binary values
          
          (lsh 5 2)          ;   5  =  0000  0000 0000  0000 0000  0000 0101
               => 20         ;      =  0000  0000 0000  0000 0000  0001 0100
          (ash 5 2)
               => 20
          (lsh -5 2)         ;  -5  =  1111  1111 1111  1111 1111  1111 1011
               => -20        ;      =  1111  1111 1111  1111 1111  1110 1100
          (ash -5 2)
               => -20
          (lsh 5 -2)         ;   5  =  0000  0000 0000  0000 0000  0000 0101
               => 1          ;      =  0000  0000 0000  0000 0000  0000 0001
          (ash 5 -2)
               => 1
          (lsh -5 -2)        ;  -5  =  1111  1111 1111  1111 1111  1111 1011
               => 4194302    ;      =  0011  1111 1111  1111 1111  1111 1110
          (ash -5 -2)        ;  -5  =  1111  1111 1111  1111 1111  1111 1011
               => -2         ;      =  1111  1111 1111  1111 1111  1111 1110

 - Function: logand &rest ints-or-markers
     This function returns the "logical and" of the arguments: the Nth
     bit is set in the result if, and only if, the Nth bit is set in
     all the arguments.  ("Set" means that the value of the bit is 1
     rather than 0.)

     For example, using 4-bit binary numbers, the "logical and" of 13
     and 12 is 12: 1101 combined with 1100 produces 1100.  In both the
     binary numbers, the leftmost two bits are set (i.e., they are
     1's), so the leftmost two bits of the returned value are set.
     However, for the rightmost two bits, each is zero in at least one
     of the arguments, so the rightmost two bits of the returned value
     are 0's.

     Therefore,

          (logand 13 12)
               => 12

     If `logand' is not passed any argument, it returns a value of -1.
     This number is an identity element for `logand' because its binary
     representation consists entirely of ones.  If `logand' is passed
     just one argument, it returns that argument.

                             ;                28-bit binary values
          
          (logand 14 13)     ; 14  =  0000  0000 0000  0000 0000  0000 1110
                             ; 13  =  0000  0000 0000  0000 0000  0000 1101
               => 12         ; 12  =  0000  0000 0000  0000 0000  0000 1100
          
          (logand 14 13 4)   ; 14  =  0000  0000 0000  0000 0000  0000 1110
                             ; 13  =  0000  0000 0000  0000 0000  0000 1101
                             ;  4  =  0000  0000 0000  0000 0000  0000 0100
               => 4          ;  4  =  0000  0000 0000  0000 0000  0000 0100
          
          (logand)
               => -1         ; -1  =  1111  1111 1111  1111 1111  1111 1111

 - Function: logior &rest ints-or-markers
     This function returns the "inclusive or" of its arguments: the Nth
     bit is set in the result if, and only if, the Nth bit is set in at
     least one of the arguments.  If there are no arguments, the result
     is zero, which is an identity element for this operation.  If
     `logior' is passed just one argument, it returns that argument.

                             ;               28-bit binary values
          
          (logior 12 5)      ; 12  =  0000  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000  0000 0000  0000 0000  0000 0101
               => 13         ; 13  =  0000  0000 0000  0000 0000  0000 1101
          
          (logior 12 5 7)    ; 12  =  0000  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000  0000 0000  0000 0000  0000 0101
                             ;  7  =  0000  0000 0000  0000 0000  0000 0111
               => 15         ; 15  =  0000  0000 0000  0000 0000  0000 1111

 - Function: logxor &rest ints-or-markers
     This function returns the "exclusive or" of its arguments: the Nth
     bit is set in the result if, and only if, the Nth bit is set in an
     odd number of the arguments.  If there are no arguments, the
     result is 0, which is an identity element for this operation.  If
     `logxor' is passed just one argument, it returns that argument.

                             ;               28-bit binary values
          
          (logxor 12 5)      ; 12  =  0000  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000  0000 0000  0000 0000  0000 0101
               => 9          ;  9  =  0000  0000 0000  0000 0000  0000 1001
          
          (logxor 12 5 7)    ; 12  =  0000  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000  0000 0000  0000 0000  0000 0101
                             ;  7  =  0000  0000 0000  0000 0000  0000 0111
               => 14         ; 14  =  0000  0000 0000  0000 0000  0000 1110

 - Function: lognot integer
     This function returns the logical complement of its argument: the
     Nth bit is one in the result if, and only if, the Nth bit is zero
     in INTEGER, and vice-versa.

          (lognot 5)
               => -6
          ;;  5  =  0000  0000 0000  0000 0000  0000 0101
          ;; becomes
          ;; -6  =  1111  1111 1111  1111 1111  1111 1010


File: elisp,  Node: Math Functions,  Next: Random Numbers,  Prev: Bitwise Operations,  Up: Numbers

Standard Mathematical Functions
===============================

   These mathematical functions allow integers as well as floating point
numbers as arguments.

 - Function: sin arg
 - Function: cos arg
 - Function: tan arg
     These are the ordinary trigonometric functions, with argument
     measured in radians.

 - Function: asin arg
     The value of `(asin ARG)' is a number between -pi/2 and pi/2
     (inclusive) whose sine is ARG; if, however, ARG is out of range
     (outside [-1, 1]), then the result is a NaN.

 - Function: acos arg
     The value of `(acos ARG)' is a number between 0 and pi (inclusive)
     whose cosine is ARG; if, however, ARG is out of range (outside
     [-1, 1]), then the result is a NaN.

 - Function: atan arg
     The value of `(atan ARG)' is a number between -pi/2 and pi/2
     (exclusive) whose tangent is ARG.

 - Function: exp arg
     This is the exponential function; it returns e to the power ARG.  e
     is a fundamental mathematical constant also called the base of
     natural logarithms.

 - Function: log arg &optional base
     This function returns the logarithm of ARG, with base BASE.  If
     you don't specify BASE, the base e is used.  If ARG is negative,
     the result is a NaN.

 - Function: log10 arg
     This function returns the logarithm of ARG, with base 10.  If ARG
     is negative, the result is a NaN.  `(log10 X)' == `(log X 10)', at
     least approximately.

 - Function: expt x y
     This function returns X raised to power Y.  If both arguments are
     integers and Y is positive, the result is an integer; in this
     case, it is truncated to fit the range of possible integer values.

 - Function: sqrt arg
     This returns the square root of ARG.  If ARG is negative, the
     value is a NaN.


File: elisp,  Node: Random Numbers,  Prev: Math Functions,  Up: Numbers

Random Numbers
==============

   A deterministic computer program cannot generate true random numbers.
For most purposes, "pseudo-random numbers" suffice.  A series of
pseudo-random numbers is generated in a deterministic fashion.  The
numbers are not truly random, but they have certain properties that
mimic a random series.  For example, all possible values occur equally
often in a pseudo-random series.

   In Emacs, pseudo-random numbers are generated from a "seed" number.
Starting from any given seed, the `random' function always generates
the same sequence of numbers.  Emacs always starts with the same seed
value, so the sequence of values of `random' is actually the same in
each Emacs run!  For example, in one operating system, the first call
to `(random)' after you start Emacs always returns -1457731, and the
second one always returns -7692030.  This repeatability is helpful for
debugging.

   If you want random numbers that don't always come out the same,
execute `(random t)'.  This chooses a new seed based on the current
time of day and on Emacs's process ID number.

 - Function: random &optional limit
     This function returns a pseudo-random integer.  Repeated calls
     return a series of pseudo-random integers.

     If LIMIT is a positive integer, the value is chosen to be
     nonnegative and less than LIMIT.

     If LIMIT is `t', it means to choose a new seed based on the
     current time of day and on Emacs's process ID number.

     On some machines, any integer representable in Lisp may be the
     result of `random'.  On other machines, the result can never be
     larger than a certain maximum or less than a certain (negative)
     minimum.


File: elisp,  Node: Strings and Characters,  Next: Lists,  Prev: Numbers,  Up: Top

Strings and Characters
**********************

   A string in Emacs Lisp is an array that contains an ordered sequence
of characters.  Strings are used as names of symbols, buffers, and
files; to send messages to users; to hold text being copied between
buffers; and for many other purposes.  Because strings are so important,
Emacs Lisp has many functions expressly for manipulating them.  Emacs
Lisp programs use strings more often than individual characters.

   *Note Strings of Events::, for special considerations for strings of
keyboard character events.

* Menu:

* Basics: String Basics.      Basic properties of strings and characters.
* Predicates for Strings::    Testing whether an object is a string or char.
* Creating Strings::          Functions to allocate new strings.
* Modifying Strings::         Altering the contents of an existing string.
* Text Comparison::           Comparing characters or strings.
* String Conversion::         Converting to and from characters and strings.
* Formatting Strings::        `format': Emacs's analogue of `printf'.
* Case Conversion::           Case conversion functions.
* Case Tables::		      Customizing case conversion.


File: elisp,  Node: String Basics,  Next: Predicates for Strings,  Up: Strings and Characters

String and Character Basics
===========================

   Characters are represented in Emacs Lisp as integers; whether an
integer is a character or not is determined only by how it is used.
Thus, strings really contain integers.

   The length of a string (like any array) is fixed, and cannot be
altered once the string exists.  Strings in Lisp are _not_ terminated
by a distinguished character code.  (By contrast, strings in C are
terminated by a character with ASCII code 0.)

   Since strings are arrays, and therefore sequences as well, you can
operate on them with the general array and sequence functions.  (*Note
Sequences Arrays Vectors::.)  For example, you can access or change
individual characters in a string using the functions `aref' and `aset'
(*note Array Functions::).

   There are two text representations for non-ASCII characters in Emacs
strings (and in buffers): unibyte and multibyte (*note Text
Representations::).  An ASCII character always occupies one byte in a
string; in fact, when a string is all ASCII, there is no real
difference between the unibyte and multibyte representations.  For most
Lisp programming, you don't need to be concerned with these two
representations.

   Sometimes key sequences are represented as strings.  When a string is
a key sequence, string elements in the range 128 to 255 represent meta
characters (which are large integers) rather than character codes in
the range 128 to 255.

   Strings cannot hold characters that have the hyper, super or alt
modifiers; they can hold ASCII control characters, but no other control
characters.  They do not distinguish case in ASCII control characters.
If you want to store such characters in a sequence, such as a key
sequence, you must use a vector instead of a string.  *Note Character
Type::, for more information about the representation of meta and other
modifiers for keyboard input characters.

   Strings are useful for holding regular expressions.  You can also
match regular expressions against strings (*note Regexp Search::).  The
functions `match-string' (*note Simple Match Data::) and
`replace-match' (*note Replacing Match::) are useful for decomposing
and modifying strings based on regular expression matching.

   Like a buffer, a string can contain text properties for the
characters in it, as well as the characters themselves.  *Note Text
Properties::.  All the Lisp primitives that copy text from strings to
buffers or other strings also copy the properties of the characters
being copied.

   *Note Text::, for information about functions that display strings or
copy them into buffers.  *Note Character Type::, and *Note String
Type::, for information about the syntax of characters and strings.
*Note Non-ASCII Characters::, for functions to convert between text
representations and to encode and decode character codes.


File: elisp,  Node: Predicates for Strings,  Next: Creating Strings,  Prev: String Basics,  Up: Strings and Characters

The Predicates for Strings
==========================

   For more information about general sequence and array predicates,
see *Note Sequences Arrays Vectors::, and *Note Arrays::.

 - Function: stringp object
     This function returns `t' if OBJECT is a string, `nil' otherwise.

 - Function: char-or-string-p object
     This function returns `t' if OBJECT is a string or a character
     (i.e., an integer), `nil' otherwise.


File: elisp,  Node: Creating Strings,  Next: Modifying Strings,  Prev: Predicates for Strings,  Up: Strings and Characters

Creating Strings
================

   The following functions create strings, either from scratch, or by
putting strings together, or by taking them apart.

 - Function: make-string count character
     This function returns a string made up of COUNT repetitions of
     CHARACTER.  If COUNT is negative, an error is signaled.

          (make-string 5 ?x)
               => "xxxxx"
          (make-string 0 ?x)
               => ""

     Other functions to compare with this one include `char-to-string'
     (*note String Conversion::), `make-vector' (*note Vectors::), and
     `make-list' (*note Building Lists::).

 - Function: string &rest characters
     This returns a string containing the characters CHARACTERS.

          (string ?a ?b ?c)
               => "abc"

 - Function: substring string start &optional end
     This function returns a new string which consists of those
     characters from STRING in the range from (and including) the
     character at the index START up to (but excluding) the character
     at the index END.  The first character is at index zero.

          (substring "abcdefg" 0 3)
               => "abc"

     Here the index for `a' is 0, the index for `b' is 1, and the index
     for `c' is 2.  Thus, three letters, `abc', are copied from the
     string `"abcdefg"'.  The index 3 marks the character position up
     to which the substring is copied.  The character whose index is 3
     is actually the fourth character in the string.

     A negative number counts from the end of the string, so that -1
     signifies the index of the last character of the string.  For
     example:

          (substring "abcdefg" -3 -1)
               => "ef"

     In this example, the index for `e' is -3, the index for `f' is -2,
     and the index for `g' is -1.  Therefore, `e' and `f' are included,
     and `g' is excluded.

     When `nil' is used as an index, it stands for the length of the
     string.  Thus,

          (substring "abcdefg" -3 nil)
               => "efg"

     Omitting the argument END is equivalent to specifying `nil'.  It
     follows that `(substring STRING 0)' returns a copy of all of
     STRING.

          (substring "abcdefg" 0)
               => "abcdefg"

     But we recommend `copy-sequence' for this purpose (*note Sequence
     Functions::).

     If the characters copied from STRING have text properties, the
     properties are copied into the new string also.  *Note Text
     Properties::.

     `substring' also accepts a vector for the first argument.  For
     example:

          (substring [a b (c) "d"] 1 3)
               => [b (c)]

     A `wrong-type-argument' error is signaled if either START or END
     is not an integer or `nil'.  An `args-out-of-range' error is
     signaled if START indicates a character following END, or if
     either integer is out of range for STRING.

     Contrast this function with `buffer-substring' (*note Buffer
     Contents::), which returns a string containing a portion of the
     text in the current buffer.  The beginning of a string is at index
     0, but the beginning of a buffer is at index 1.

 - Function: concat &rest sequences
     This function returns a new string consisting of the characters in
     the arguments passed to it (along with their text properties, if
     any).  The arguments may be strings, lists of numbers, or vectors
     of numbers; they are not themselves changed.  If `concat' receives
     no arguments, it returns an empty string.

          (concat "abc" "-def")
               => "abc-def"
          (concat "abc" (list 120 121) [122])
               => "abcxyz"
          ;; `nil' is an empty sequence.
          (concat "abc" nil "-def")
               => "abc-def"
          (concat "The " "quick brown " "fox.")
               => "The quick brown fox."
          (concat)
               => ""

     The `concat' function always constructs a new string that is not
     `eq' to any existing string.

     In Emacs versions before 21, when an argument was an integer (not a
     sequence of integers), it was converted to a string of digits
     making up the decimal printed representation of the integer.  This
     obsolete usage no longer works.  The proper way to convert an
     integer to its decimal printed form is with `format' (*note
     Formatting Strings::) or `number-to-string' (*note String
     Conversion::).

     For information about other concatenation functions, see the
     description of `mapconcat' in *Note Mapping Functions::, `vconcat'
     in *Note Vectors::, and `append' in *Note Building Lists::.

 - Function: split-string string separators
     This function splits STRING into substrings at matches for the
     regular expression SEPARATORS.  Each match for SEPARATORS defines a
     splitting point; the substrings between the splitting points are
     made into a list, which is the value returned by `split-string'.
     If SEPARATORS is `nil' (or omitted), the default is `"[
     \f\t\n\r\v]+"'.

     For example,

          (split-string "Soup is good food" "o")
          => ("S" "up is g" "" "d f" "" "d")
          (split-string "Soup is good food" "o+")
          => ("S" "up is g" "d f" "d")

     When there is a match adjacent to the beginning or end of the
     string, this does not cause a null string to appear at the
     beginning or end of the list:

          (split-string "out to moo" "o+")
          => ("ut t" " m")

     Empty matches do count, when not adjacent to another match:

          (split-string "Soup is good food" "o*")
          =>("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
          (split-string "Nice doggy!" "")
          =>("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")


File: elisp,  Node: Modifying Strings,  Next: Text Comparison,  Prev: Creating Strings,  Up: Strings and Characters

Modifying Strings
=================

   The most basic way to alter the contents of an existing string is
with `aset' (*note Array Functions::).  `(aset STRING IDX CHAR)' stores
CHAR into STRING at index IDX.  Each character occupies one or more
bytes, and if CHAR needs a different number of bytes from the character
already present at that index, `aset' signals an error.

   A more powerful function is `store-substring':

 - Function: store-substring string idx obj
     This function alters part of the contents of the string STRING, by
     storing OBJ starting at index IDX.  The argument OBJ may be either
     a character or a (smaller) string.

     Since it is impossible to change the length of an existing string,
     it is an error if OBJ doesn't fit within STRING's actual length,
     or if any new character requires a different number of bytes from
     the character currently present at that point in STRING.


File: elisp,  Node: Text Comparison,  Next: String Conversion,  Prev: Modifying Strings,  Up: Strings and Characters

Comparison of Characters and Strings
====================================

 - Function: char-equal character1 character2
     This function returns `t' if the arguments represent the same
     character, `nil' otherwise.  This function ignores differences in
     case if `case-fold-search' is non-`nil'.

          (char-equal ?x ?x)
               => t
          (let ((case-fold-search nil))
            (char-equal ?x ?X))
               => nil

 - Function: string= string1 string2
     This function returns `t' if the characters of the two strings
     match exactly.  Case is always significant, regardless of
     `case-fold-search'.

          (string= "abc" "abc")
               => t
          (string= "abc" "ABC")
               => nil
          (string= "ab" "ABC")
               => nil

     The function `string=' ignores the text properties of the two
     strings.  When `equal' (*note Equality Predicates::) compares two
     strings, it uses `string='.

     If the strings contain non-ASCII characters, and one is unibyte
     while the other is multibyte, then they cannot be equal.  *Note
     Text Representations::.

 - Function: string-equal string1 string2
     `string-equal' is another name for `string='.

 - Function: string< string1 string2
     This function compares two strings a character at a time.  It
     scans both the strings at the same time to find the first pair of
     corresponding characters that do not match.  If the lesser
     character of these two is the character from STRING1, then STRING1
     is less, and this function returns `t'.  If the lesser character
     is the one from STRING2, then STRING1 is greater, and this
     function returns `nil'.  If the two strings match entirely, the
     value is `nil'.

     Pairs of characters are compared according to their character
     codes.  Keep in mind that lower case letters have higher numeric
     values in the ASCII character set than their upper case
     counterparts; digits and many punctuation characters have a lower
     numeric value than upper case letters.  An ASCII character is less
     than any non-ASCII character; a unibyte non-ASCII character is
     always less than any multibyte non-ASCII character (*note Text
     Representations::).

          (string< "abc" "abd")
               => t
          (string< "abd" "abc")
               => nil
          (string< "123" "abc")
               => t

     When the strings have different lengths, and they match up to the
     length of STRING1, then the result is `t'.  If they match up to
     the length of STRING2, the result is `nil'.  A string of no
     characters is less than any other string.

          (string< "" "abc")
               => t
          (string< "ab" "abc")
               => t
          (string< "abc" "")
               => nil
          (string< "abc" "ab")
               => nil
          (string< "" "")
               => nil

 - Function: string-lessp string1 string2
     `string-lessp' is another name for `string<'.

 - Function: compare-strings string1 start1 end1 string2 start2 end2
          &optional ignore-case
     This function compares the specified part of STRING1 with the
     specified part of STRING2.  The specified part of STRING1 runs
     from index START1 up to index END1 (`nil' means the end of the
     string).  The specified part of STRING2 runs from index START2 up
     to index END2 (`nil' means the end of the string).

     The strings are both converted to multibyte for the comparison
     (*note Text Representations::) so that a unibyte string can be
     equal to a multibyte string.  If IGNORE-CASE is non-`nil', then
     case is ignored, so that upper case letters can be equal to lower
     case letters.

     If the specified portions of the two strings match, the value is
     `t'.  Otherwise, the value is an integer which indicates how many
     leading characters agree, and which string is less.  Its absolute
     value is one plus the number of characters that agree at the
     beginning of the two strings.  The sign is negative if STRING1 (or
     its specified portion) is less.

 - Function: assoc-ignore-case key alist
     This function works like `assoc', except that KEY must be a
     string, and comparison is done using `compare-strings', ignoring
     case differences.  *Note Association Lists::.

 - Function: assoc-ignore-representation key alist
     This function works like `assoc', except that KEY must be a
     string, and comparison is done using `compare-strings'.  Case
     differences are significant.

   See also `compare-buffer-substrings' in *Note Comparing Text::, for
a way to compare text in buffers.  The function `string-match', which
matches a regular expression against a string, can be used for a kind
of string comparison; see *Note Regexp Search::.


File: elisp,  Node: String Conversion,  Next: Formatting Strings,  Prev: Text Comparison,  Up: Strings and Characters

Conversion of Characters and Strings
====================================

   This section describes functions for conversions between characters,
strings and integers.  `format' and `prin1-to-string' (*note Output
Functions::) can also convert Lisp objects into strings.
`read-from-string' (*note Input Functions::) can "convert" a string
representation of a Lisp object into an object.  The functions
`string-make-multibyte' and `string-make-unibyte' convert the text
representation of a string (*note Converting Representations::).

   *Note Documentation::, for functions that produce textual
descriptions of text characters and general input events
(`single-key-description' and `text-char-description').  These
functions are used primarily for making help messages.

 - Function: char-to-string character
     This function returns a new string containing one character,
     CHARACTER.  This function is semi-obsolete because the function
     `string' is more general.  *Note Creating Strings::.

 - Function: string-to-char string
     This function returns the first character in STRING.  If the
     string is empty, the function returns 0.  The value is also 0 when
     the first character of STRING is the null character, ASCII code 0.

          (string-to-char "ABC")
               => 65
          (string-to-char "xyz")
               => 120
          (string-to-char "")
               => 0
          (string-to-char "\000")
               => 0

     This function may be eliminated in the future if it does not seem
     useful enough to retain.

 - Function: number-to-string number
     This function returns a string consisting of the printed base-ten
     representation of NUMBER, which may be an integer or a floating
     point number.  The returned value starts with a minus sign if the
     argument is negative.

          (number-to-string 256)
               => "256"
          (number-to-string -23)
               => "-23"
          (number-to-string -23.5)
               => "-23.5"

     `int-to-string' is a semi-obsolete alias for this function.

     See also the function `format' in *Note Formatting Strings::.

 - Function: string-to-number string &optional base
     This function returns the numeric value of the characters in
     STRING.  If BASE is non-`nil', integers are converted in that
     base.  If BASE is `nil', then base ten is used.  Floating point
     conversion always uses base ten; we have not implemented other
     radices for floating point numbers, because that would be much
     more work and does not seem useful.  If STRING looks like an
     integer but its value is too large to fit into a Lisp integer,
     `string-to-number' returns a floating point result.

     The parsing skips spaces and tabs at the beginning of STRING, then
     reads as much of STRING as it can interpret as a number.  (On some
     systems it ignores other whitespace at the beginning, not just
     spaces and tabs.)  If the first character after the ignored
     whitespace is neither a digit, nor a plus or minus sign, nor the
     leading dot of a floating point number, this function returns 0.

          (string-to-number "256")
               => 256
          (string-to-number "25 is a perfect square.")
               => 25
          (string-to-number "X256")
               => 0
          (string-to-number "-4.5")
               => -4.5
          (string-to-number "1e5")
               => 100000.0

     `string-to-int' is an obsolete alias for this function.

   Here are some other functions that can convert to or from a string:

`concat'
     `concat' can convert a vector or a list into a string.  *Note
     Creating Strings::.

`vconcat'
     `vconcat' can convert a string into a vector.  *Note Vector
     Functions::.

`append'
     `append' can convert a string into a list.  *Note Building Lists::.


File: elisp,  Node: Formatting Strings,  Next: Case Conversion,  Prev: String Conversion,  Up: Strings and Characters

Formatting Strings
==================

   "Formatting" means constructing a string by substitution of computed
values at various places in a constant string.  This constant string
controls how the other values are printed, as well as where they appear;
it is called a "format string".

   Formatting is often useful for computing messages to be displayed.
In fact, the functions `message' and `error' provide the same
formatting feature described here; they differ from `format' only in
how they use the result of formatting.

 - Function: format string &rest objects
     This function returns a new string that is made by copying STRING
     and then replacing any format specification in the copy with
     encodings of the corresponding OBJECTS.  The arguments OBJECTS are
     the computed values to be formatted.

     The characters in STRING, other than the format specifications,
     are copied directly into the output; starting in Emacs 21, if they
     have text properties, these are copied into the output also.

   A format specification is a sequence of characters beginning with a
`%'.  Thus, if there is a `%d' in STRING, the `format' function
replaces it with the printed representation of one of the values to be
formatted (one of the arguments OBJECTS).  For example:

     (format "The value of fill-column is %d." fill-column)
          => "The value of fill-column is 72."

   If STRING contains more than one format specification, the format
specifications correspond to successive values from OBJECTS.  Thus, the
first format specification in STRING uses the first such value, the
second format specification uses the second such value, and so on.  Any
extra format specifications (those for which there are no corresponding
values) cause unpredictable behavior.  Any extra values to be formatted
are ignored.

   Certain format specifications require values of particular types.  If
you supply a value that doesn't fit the requirements, an error is
signaled.

   Here is a table of valid format specifications:

`%s'
     Replace the specification with the printed representation of the
     object, made without quoting (that is, using `princ', not
     `prin1'--*note Output Functions::).  Thus, strings are represented
     by their contents alone, with no `"' characters, and symbols appear
     without `\' characters.

     Starting in Emacs 21, if the object is a string, its text
     properties are copied into the output.  The text properties of the
     `%s' itself are also copied, but those of the object take priority.

     If there is no corresponding object, the empty string is used.

`%S'
     Replace the specification with the printed representation of the
     object, made with quoting (that is, using `prin1'--*note Output
     Functions::).  Thus, strings are enclosed in `"' characters, and
     `\' characters appear where necessary before special characters.

     If there is no corresponding object, the empty string is used.

`%o'
     Replace the specification with the base-eight representation of an
     integer.

`%d'
     Replace the specification with the base-ten representation of an
     integer.

`%x'
`%X'
     Replace the specification with the base-sixteen representation of
     an integer.  `%x' uses lower case and `%X' uses upper case.

`%c'
     Replace the specification with the character which is the value
     given.

`%e'
     Replace the specification with the exponential notation for a
     floating point number.

`%f'
     Replace the specification with the decimal-point notation for a
     floating point number.

`%g'
     Replace the specification with notation for a floating point
     number, using either exponential notation or decimal-point
     notation, whichever is shorter.

`%%'
     Replace the specification with a single `%'.  This format
     specification is unusual in that it does not use a value.  For
     example, `(format "%% %d" 30)' returns `"% 30"'.

   Any other format character results in an `Invalid format operation'
error.

   Here are several examples:

     (format "The name of this buffer is %s." (buffer-name))
          => "The name of this buffer is strings.texi."
     
     (format "The buffer object prints as %s." (current-buffer))
          => "The buffer object prints as strings.texi."
     
     (format "The octal value of %d is %o,
              and the hex value is %x." 18 18 18)
          => "The octal value of 18 is 22,
              and the hex value is 12."

   All the specification characters allow an optional numeric prefix
between the `%' and the character.  The optional numeric prefix defines
the minimum width for the object.  If the printed representation of the
object contains fewer characters than this, then it is padded.  The
padding is on the left if the prefix is positive (or starts with zero)
and on the right if the prefix is negative.  The padding character is
normally a space, but if the numeric prefix starts with a zero, zeros
are used for padding.  Here are some examples of padding:

     (format "%06d is padded on the left with zeros" 123)
          => "000123 is padded on the left with zeros"
     
     (format "%-6d is padded on the right" 123)
          => "123    is padded on the right"

   `format' never truncates an object's printed representation, no
matter what width you specify.  Thus, you can use a numeric prefix to
specify a minimum spacing between columns with no risk of losing
information.

   In the following three examples, `%7s' specifies a minimum width of
7.  In the first case, the string inserted in place of `%7s' has only 3
letters, so 4 blank spaces are inserted for padding.  In the second
case, the string `"specification"' is 13 letters wide but is not
truncated.  In the third case, the padding is on the right.

     (format "The word `%7s' actually has %d letters in it."
             "foo" (length "foo"))
          => "The word `    foo' actually has 3 letters in it."
     
     (format "The word `%7s' actually has %d letters in it."
             "specification" (length "specification"))
          => "The word `specification' actually has 13 letters in it."
     
     (format "The word `%-7s' actually has %d letters in it."
             "foo" (length "foo"))
          => "The word `foo    ' actually has 3 letters in it."


File: elisp,  Node: Case Conversion,  Next: Case Tables,  Prev: Formatting Strings,  Up: Strings and Characters

Case Conversion in Lisp
=======================

   The character case functions change the case of single characters or
of the contents of strings.  The functions normally convert only
alphabetic characters (the letters `A' through `Z' and `a' through `z',
as well as non-ASCII letters); other characters are not altered.  You
can specify a different case conversion mapping by specifying a case
table (*note Case Tables::).

   These functions do not modify the strings that are passed to them as
arguments.

   The examples below use the characters `X' and `x' which have ASCII
codes 88 and 120 respectively.

 - Function: downcase string-or-char
     This function converts a character or a string to lower case.

     When the argument to `downcase' is a string, the function creates
     and returns a new string in which each letter in the argument that
     is upper case is converted to lower case.  When the argument to
     `downcase' is a character, `downcase' returns the corresponding
     lower case character.  This value is an integer.  If the original
     character is lower case, or is not a letter, then the value equals
     the original character.

          (downcase "The cat in the hat")
               => "the cat in the hat"
          
          (downcase ?X)
               => 120

 - Function: upcase string-or-char
     This function converts a character or a string to upper case.

     When the argument to `upcase' is a string, the function creates
     and returns a new string in which each letter in the argument that
     is lower case is converted to upper case.

     When the argument to `upcase' is a character, `upcase' returns the
     corresponding upper case character.  This value is an integer.  If
     the original character is upper case, or is not a letter, then the
     value returned equals the original character.

          (upcase "The cat in the hat")
               => "THE CAT IN THE HAT"
          
          (upcase ?x)
               => 88

 - Function: capitalize string-or-char
     This function capitalizes strings or characters.  If
     STRING-OR-CHAR is a string, the function creates and returns a new
     string, whose contents are a copy of STRING-OR-CHAR in which each
     word has been capitalized.  This means that the first character of
     each word is converted to upper case, and the rest are converted
     to lower case.

     The definition of a word is any sequence of consecutive characters
     that are assigned to the word constituent syntax class in the
     current syntax table (*note Syntax Class Table::).

     When the argument to `capitalize' is a character, `capitalize' has
     the same result as `upcase'.

          (capitalize "The cat in the hat")
               => "The Cat In The Hat"
          
          (capitalize "THE 77TH-HATTED CAT")
               => "The 77th-Hatted Cat"
          
          (capitalize ?x)
               => 88

 - Function: upcase-initials string
     This function capitalizes the initials of the words in STRING,
     without altering any letters other than the initials.  It returns
     a new string whose contents are a copy of STRING, in which each
     word has had its initial letter converted to upper case.

     The definition of a word is any sequence of consecutive characters
     that are assigned to the word constituent syntax class in the
     current syntax table (*note Syntax Class Table::).

          (upcase-initials "The CAT in the hAt")
               => "The CAT In The HAt"

   *Note Text Comparison::, for functions that compare strings; some of
them ignore case differences, or can optionally ignore case differences.


File: elisp,  Node: Case Tables,  Prev: Case Conversion,  Up: Strings and Characters

The Case Table
==============

   You can customize case conversion by installing a special "case
table".  A case table specifies the mapping between upper case and lower
case letters.  It affects both the case conversion functions for Lisp
objects (see the previous section) and those that apply to text in the
buffer (*note Case Changes::).  Each buffer has a case table; there is
also a standard case table which is used to initialize the case table
of new buffers.

   A case table is a char-table (*note Char-Tables::) whose subtype is
`case-table'.  This char-table maps each character into the
corresponding lower case character.  It has three extra slots, which
hold related tables:

UPCASE
     The upcase table maps each character into the corresponding upper
     case character.

CANONICALIZE
     The canonicalize table maps all of a set of case-related characters
     into a particular member of that set.

EQUIVALENCES
     The equivalences table maps each one of a set of case-related
     characters into the next character in that set.

   In simple cases, all you need to specify is the mapping to
lower-case; the three related tables will be calculated automatically
from that one.

   For some languages, upper and lower case letters are not in
one-to-one correspondence.  There may be two different lower case
letters with the same upper case equivalent.  In these cases, you need
to specify the maps for both lower case and upper case.

   The extra table CANONICALIZE maps each character to a canonical
equivalent; any two characters that are related by case-conversion have
the same canonical equivalent character.  For example, since `a' and
`A' are related by case-conversion, they should have the same canonical
equivalent character (which should be either `a' for both of them, or
`A' for both of them).

   The extra table EQUIVALENCES is a map that cyclicly permutes each
equivalence class (of characters with the same canonical equivalent).
(For ordinary ASCII, this would map `a' into `A' and `A' into `a', and
likewise for each set of equivalent characters.)

   When you construct a case table, you can provide `nil' for
CANONICALIZE; then Emacs fills in this slot from the lower case and
upper case mappings.  You can also provide `nil' for EQUIVALENCES; then
Emacs fills in this slot from CANONICALIZE.  In a case table that is
actually in use, those components are non-`nil'.  Do not try to specify
EQUIVALENCES without also specifying CANONICALIZE.

   Here are the functions for working with case tables:

 - Function: case-table-p object
     This predicate returns non-`nil' if OBJECT is a valid case table.

 - Function: set-standard-case-table table
     This function makes TABLE the standard case table, so that it will
     be used in any buffers created subsequently.

 - Function: standard-case-table
     This returns the standard case table.

 - Function: current-case-table
     This function returns the current buffer's case table.

 - Function: set-case-table table
     This sets the current buffer's case table to TABLE.

   The following three functions are convenient subroutines for packages
that define non-ASCII character sets.  They modify the specified case
table CASE-TABLE; they also modify the standard syntax table.  *Note
Syntax Tables::.  Normally you would use these functions to change the
standard case table.

 - Function: set-case-syntax-pair uc lc case-table
     This function specifies a pair of corresponding letters, one upper
     case and one lower case.

 - Function: set-case-syntax-delims l r case-table
     This function makes characters L and R a matching pair of
     case-invariant delimiters.

 - Function: set-case-syntax char syntax case-table
     This function makes CHAR case-invariant, with syntax SYNTAX.

 - Command: describe-buffer-case-table
     This command displays a description of the contents of the current
     buffer's case table.


File: elisp,  Node: Lists,  Next: Sequences Arrays Vectors,  Prev: Strings and Characters,  Up: Top

Lists
*****

   A "list" represents a sequence of zero or more elements (which may
be any Lisp objects).  The important difference between lists and
vectors is that two or more lists can share part of their structure; in
addition, you can insert or delete elements in a list without copying
the whole list.

* Menu:

* Cons Cells::          How lists are made out of cons cells.
* Lists as Boxes::                 Graphical notation to explain lists.
* List-related Predicates::        Is this object a list?  Comparing two lists.
* List Elements::       Extracting the pieces of a list.
* Building Lists::      Creating list structure.
* Modifying Lists::     Storing new pieces into an existing list.
* Sets And Lists::      A list can represent a finite mathematical set.
* Association Lists::   A list can represent a finite relation or mapping.

