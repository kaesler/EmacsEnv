{\rtf0\ansi{\fonttbl\f0\fswiss Helvetica;\f1\fmodern Ohlfs;}
\paperw9840
\paperh14020
\margl120
\margr120
\pard\tx520\tx1060\tx1600\tx2120\tx2660\tx3200\tx3720\tx4260\tx4800\tx5320\f0\b0\i0\ulnone\fs24\fc0\cf0 \

\fs36 This program is released under the terms of the GNU General Public License.  Do what you want with it.\

\fs24 \
See the History.rtf file to see what this program is all about.\
\
To run, launch it from the Workspace and have it read in a .tree file (format is in ascii, as described in History.rtf).  The tree will be displayed graphically.  Click on a button to activate a node.  When a node gets sent an activation message, it prints it's contents to stdout, which means that you will see feedback in the WorkSpace Console.\
\
And that's all there is.  This program mainly serves as a programming example and a way to make available a generic Tree class.  The Tree class is particularly useful for building parse trees, and subclasses could easily be made to create a recursive pretty-printer automatically.  (I have used the Tree class in an optimizing compiler which deals with a subset of Pascal, and the Tree did pretty printing and three-address code generation automatically by just sending the appropriate message to the root node.  It worked out quite nicely.  Each subclass corresponded to a different type of programming construct¼)  Also of note is the way I use a List as a display List for the line objects.  Any type of object that can render itself could be placed in that list, which is part of how my gamekit deals with multiple types of sprites...  and in the file parsing is an example of how a List object can be used as a stack.  (It could be used as a queue, too, if you think about it.  Quite a nifty object IMHO.)\
\
If you have any questions, requests, whatever, feel free to contact me.\
\
\
Don_Yacktman@byu.edu\
\
\
\
}
