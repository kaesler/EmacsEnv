#!/home/johnh/BIN/perl5 -w
# If the above path is incorrect for your system,
# FOLLOW THE INSTALLATION INSTRUCTIONS in README.

#
# mkall
# $Id: mkall,v 1.11 1999/12/28 04:39:05 johnh Exp $
#
# Copyright (C) 1996 by John Heidemann.
# Comments to <johnh@isi.edu>.
#
# This file is under the Gnu Public License, version 2.
# For details see the COPYING which accompanies this distribution.
#

sub usage {
    print STDOUT <<END;
usage: $0
END
    exit 1;
}


require 5.000;
BEGIN { unshift(@INC, "/home/johnh/NOTES/BIN"); };
use NotesVars;
use strict;

&usage if (($#ARGV >= 0 && $ARGV[0] eq '-?'));

#
# rawindex 
#
chdir ($::notes{'dir'}) || die "$0: cannot cd to $::notes{'dir'}.\n";
# if (-f "rawindex") {
#     rename('rawindex', 'rawindex~') || die "$0: cannot rename rawindex.\n";
# };
# my($sed_arg) = '"s@' . $::notes{home} . '@/~@"';
# system(<<END);
#     $::notes{'bin_dir'}/mkrawindex $::notes{'dir'}/$::notes{'int_glob'}/$::notes{'file_glob'} |
#     sort -f -t# +1 +0 |
#     sed $sed_arg > rawindex
# END
# if ($? >> 8) {
#     rename('rawindex', 'rawindex.bad');
#     rename('rawindex~', 'rawindex');
#     die "$0: rawindex pipeline failed.";
# };
open (IF, "$::notes{'bin_dir'}/mkrawindex $::notes{'dir'}/$::notes{'int_glob'}/$::notes{'file_glob'} |") || die "$0: cannot run mkrawindex\n";
open (OF, ">rawindex+") || die "$0: cannot write to rawindex+\n";
my(@subjects) = ();
my($internal_marker) = chr(1);
foreach (<IF>) {
    chomp;
    s@$::notes{'home'}@/~@;
    my($left, $right) = /^([^#]+)\#(.*)$/;
    push(@subjects, "${right}${internal_marker}${left}");
};
close IF;
@subjects = sort { uc($a) cmp uc($b) } @subjects;
foreach (0..$#subjects) {
    my($left, $right) = ($subjects[$_] =~ /^(.+)${internal_marker}(.*)$/);
    $subjects[$_] = "$right#$left";
    print OF "$subjects[$_]\n";
};
close OF;
rename('rawindex', 'rawindex~') || die "$0: rename failed.\n";
rename('rawindex+', 'rawindex') || die "$0: rename failed.\n";

#
# index
#
if (-f 'index') {
    rename('index', 'index~') || die "$0: cannot rename index.\n";
};
open (OF, "| $::notes{'bin_dir'}/mkindex > index") || die "$0: cannot run mkindex.\n";
my($last);
foreach (@subjects) {
    if (!defined($last) || $last ne uc($_)) {
	print OF "$_\n";
	$last = uc($_);
    };
};
close OF;
if ($? >> 8) {
    rename('index', 'index.bad');
    rename('index~', 'index');
    die "$0: index pipeline failed.";
};

#
# indexel
#
# Yes, the code should probably be compiled,
# but compilation time doesn't seem to be the problem.
#
if (-f 'index_cache.el') {
    rename('index_cache.el', 'index_cache.el~') || die "$0: cannot rename indexcache.el.\n";
};
system(<<END);
    $::notes{'bin_dir'}/mkindexcache < index > index_cache.el
END
#    emacs -batch --eval '(byte-compile-file "index_cache.el")' 2>&1 | grep -v 'free variable'
if ($? >> 8) {
    rename('index_cache.el', 'index_cache.el.bad');
    rename('index_cache.el~', 'index_cache.el');
    unlink('index_cache.elc') if (-f 'index_cache.elc');
    die "$0: index pipeline failed.";
};

#
# prevnext
#
system(<<END);
    $::notes{'bin_dir'}/mkprevnext ./rawindex $::notes{'int_glob'}/$::notes{'file_glob'}
END
if ($? >> 8) {
    die "$0: mkprevnext failed.";
};

#
# mknew cache
#

my($todays_file) = &epoch_to_pathname(time);
system(<<END);
    $::notes{'bin_dir'}/mknew -c $todays_file >./mknew.cache
END

#
# fix permissions
#
my($perm);
foreach (glob("*"), glob("*/*")) {
    my($mode) = (stat($_))[2];
    if ($mode & 0077) {
	chmod (($mode & 0700), $_) || warn "$0: could not chmod $_.\n";
    };
};


exit 0;
